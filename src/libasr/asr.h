#ifndef LFORTRAN_ASR_H
#define LFORTRAN_ASR_H

// Generated by grammar/asdl_cpp.py

#include <lfortran/parser/alloc.h>
#include <lfortran/parser/location.h>
#include <lfortran/colors.h>
#include <lfortran/containers.h>
#include <lfortran/exception.h>
#include <lfortran/semantics/asr_scopes.h>


namespace LFortran::ASR {

enum asrType
{
    unit, symbol, stmt, expr, ttype, attribute, tbind, case_stmt
};

struct asr_t
{
    asrType type;
    Location loc;
};


template <class T, class U>
inline bool is_a(const U &x)
{
    return T::class_type == x.type;
}

// Cast one level down

template <class T, class U>
static inline T* down_cast(const U *f)
{
    LFORTRAN_ASSERT(f != nullptr);
    LFORTRAN_ASSERT(is_a<T>(*f));
    return (T*)f;
}

// Cast two levels down

template <class T>
static inline T* down_cast2(const asr_t *f)
{
    typedef typename T::parent_type ptype;
    ptype *t = down_cast<ptype>(f);
    return down_cast<T>(t);
}


/******************************************************************************/
// Forward declarations

struct unit_t; // Sum
struct symbol_t; // Sum
enum storage_typeType // Simple Sum
{ // Types
    Default, Save, Parameter, Allocatable
};
enum accessType // Simple Sum
{ // Types
    Public, Private
};
enum intentType // Simple Sum
{ // Types
    Local, In, Out, InOut, ReturnVar, Unspecified, AssociateBlock
};
enum deftypeType // Simple Sum
{ // Types
    Implementation, Interface
};
enum presenceType // Simple Sum
{ // Types
    Required, Optional
};
enum abiType // Simple Sum
{ // Types
    Source, LFortranModule, GFortranModule, BindC, Interactive, Intrinsic
};
struct stmt_t; // Sum
struct expr_t; // Sum
struct ttype_t; // Sum
enum boolopType // Simple Sum
{ // Types
    And, Or, Xor, NEqv, Eqv
};
enum binopType // Simple Sum
{ // Types
    Add, Sub, Mul, Div, Pow
};
enum unaryopType // Simple Sum
{ // Types
    Invert, Not, UAdd, USub
};
enum stropType // Simple Sum
{ // Types
    Concat
};
enum cmpopType // Simple Sum
{ // Types
    Eq, NotEq, Lt, LtE, Gt, GtE
};
enum bozType // Simple Sum
{ // Types
    Binary, Hex, Octal
};
enum cast_kindType // Simple Sum
{ // Types
    RealToInteger, IntegerToReal, RealToReal, IntegerToInteger, RealToComplex, IntegerToComplex, IntegerToLogical, ComplexToComplex, ComplexToReal
};
struct dimension_t; // Product
struct alloc_arg_t; // Product
struct attribute_t; // Sum
struct attribute_arg_t; // Product
struct arg_t; // Product
struct keyword_t; // Product
struct tbind_t; // Sum
struct array_index_t; // Product
struct do_loop_head_t; // Product
struct case_stmt_t; // Sum


/******************************************************************************/
// Products declarations

struct dimension_t // Product
{
    Location loc;
    expr_t* m_start;
    expr_t* m_end;
};
struct alloc_arg_t // Product
{
    Location loc;
    symbol_t* m_a;
    dimension_t* m_dims; size_t n_dims; // Sequence
};
struct attribute_arg_t // Product
{
    Location loc;
    char* m_arg;
};
struct arg_t // Product
{
    Location loc;
    char* m_arg;
};
struct keyword_t // Product
{
    Location loc;
    char* m_arg;
    expr_t* m_value;
};
struct array_index_t // Product
{
    Location loc;
    expr_t* m_left;
    expr_t* m_right;
    expr_t* m_step;
};
struct do_loop_head_t // Product
{
    Location loc;
    expr_t* m_v;
    expr_t* m_start;
    expr_t* m_end;
    expr_t* m_increment;
};


/******************************************************************************/
// Sums declarations

enum unitType // Types
{
    TranslationUnit
};

struct unit_t // Sum
{
    const static asrType class_type = asrType::unit;
    asr_t base;
    unitType type;
};

    struct TranslationUnit_t // Constructor
    {
        const static unitType class_type = unitType::TranslationUnit;
        typedef unit_t parent_type;
        unit_t base;
        SymbolTable* m_global_scope;
        asr_t** m_items; size_t n_items; // Sequence
    };
    static inline asr_t* make_TranslationUnit_t(Allocator &al, const Location &a_loc, SymbolTable* a_global_scope, asr_t** a_items, size_t n_items) {
        TranslationUnit_t *n;
        n = al.make_new<TranslationUnit_t>();
        n->base.type = unitType::TranslationUnit;
        n->base.base.type = asrType::unit;
        n->base.base.loc = a_loc;
        n->m_global_scope = a_global_scope;
        a_global_scope->asr_owner = (asr_t*)n;
        n->m_items = a_items;
        n->n_items = n_items;
        return (asr_t*)n;
    }



enum symbolType // Types
{
    Program, Module, Subroutine, Function, GenericProcedure, CustomOperator, ExternalSymbol, DerivedType, Variable, ClassType, ClassProcedure
};

struct symbol_t // Sum
{
    const static asrType class_type = asrType::symbol;
    asr_t base;
    symbolType type;
};

    struct Program_t // Constructor
    {
        const static symbolType class_type = symbolType::Program;
        typedef symbol_t parent_type;
        symbol_t base;
        SymbolTable* m_symtab;
        char* m_name;
        char** m_dependencies; size_t n_dependencies; // Sequence
        stmt_t** m_body; size_t n_body; // Sequence
    };
    static inline asr_t* make_Program_t(Allocator &al, const Location &a_loc, SymbolTable* a_symtab, char* a_name, char** a_dependencies, size_t n_dependencies, stmt_t** a_body, size_t n_body) {
        Program_t *n;
        n = al.make_new<Program_t>();
        n->base.type = symbolType::Program;
        n->base.base.type = asrType::symbol;
        n->base.base.loc = a_loc;
        n->m_symtab = a_symtab;
        a_symtab->asr_owner = (asr_t*)n;
        n->m_name = a_name;
        n->m_dependencies = a_dependencies;
        n->n_dependencies = n_dependencies;
        n->m_body = a_body;
        n->n_body = n_body;
        return (asr_t*)n;
    }

    struct Module_t // Constructor
    {
        const static symbolType class_type = symbolType::Module;
        typedef symbol_t parent_type;
        symbol_t base;
        SymbolTable* m_symtab;
        char* m_name;
        char** m_dependencies; size_t n_dependencies; // Sequence
        bool m_loaded_from_mod;
    };
    static inline asr_t* make_Module_t(Allocator &al, const Location &a_loc, SymbolTable* a_symtab, char* a_name, char** a_dependencies, size_t n_dependencies, bool a_loaded_from_mod) {
        Module_t *n;
        n = al.make_new<Module_t>();
        n->base.type = symbolType::Module;
        n->base.base.type = asrType::symbol;
        n->base.base.loc = a_loc;
        n->m_symtab = a_symtab;
        a_symtab->asr_owner = (asr_t*)n;
        n->m_name = a_name;
        n->m_dependencies = a_dependencies;
        n->n_dependencies = n_dependencies;
        n->m_loaded_from_mod = a_loaded_from_mod;
        return (asr_t*)n;
    }

    struct Subroutine_t // Constructor
    {
        const static symbolType class_type = symbolType::Subroutine;
        typedef symbol_t parent_type;
        symbol_t base;
        SymbolTable* m_symtab;
        char* m_name;
        expr_t** m_args; size_t n_args; // Sequence
        stmt_t** m_body; size_t n_body; // Sequence
        abiType m_abi;
        accessType m_access;
        deftypeType m_deftype;
        char* m_bindc_name;
        bool m_pure;
        bool m_module;
    };
    static inline asr_t* make_Subroutine_t(Allocator &al, const Location &a_loc, SymbolTable* a_symtab, char* a_name, expr_t** a_args, size_t n_args, stmt_t** a_body, size_t n_body, abiType a_abi, accessType a_access, deftypeType a_deftype, char* a_bindc_name, bool a_pure, bool a_module) {
        Subroutine_t *n;
        n = al.make_new<Subroutine_t>();
        n->base.type = symbolType::Subroutine;
        n->base.base.type = asrType::symbol;
        n->base.base.loc = a_loc;
        n->m_symtab = a_symtab;
        a_symtab->asr_owner = (asr_t*)n;
        n->m_name = a_name;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_body = a_body;
        n->n_body = n_body;
        n->m_abi = a_abi;
        n->m_access = a_access;
        n->m_deftype = a_deftype;
        n->m_bindc_name = a_bindc_name;
        n->m_pure = a_pure;
        n->m_module = a_module;
        return (asr_t*)n;
    }

    struct Function_t // Constructor
    {
        const static symbolType class_type = symbolType::Function;
        typedef symbol_t parent_type;
        symbol_t base;
        SymbolTable* m_symtab;
        char* m_name;
        expr_t** m_args; size_t n_args; // Sequence
        stmt_t** m_body; size_t n_body; // Sequence
        expr_t* m_return_var;
        abiType m_abi;
        accessType m_access;
        deftypeType m_deftype;
        char* m_bindc_name;
    };
    static inline asr_t* make_Function_t(Allocator &al, const Location &a_loc, SymbolTable* a_symtab, char* a_name, expr_t** a_args, size_t n_args, stmt_t** a_body, size_t n_body, expr_t* a_return_var, abiType a_abi, accessType a_access, deftypeType a_deftype, char* a_bindc_name) {
        Function_t *n;
        n = al.make_new<Function_t>();
        n->base.type = symbolType::Function;
        n->base.base.type = asrType::symbol;
        n->base.base.loc = a_loc;
        n->m_symtab = a_symtab;
        a_symtab->asr_owner = (asr_t*)n;
        n->m_name = a_name;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_body = a_body;
        n->n_body = n_body;
        n->m_return_var = a_return_var;
        n->m_abi = a_abi;
        n->m_access = a_access;
        n->m_deftype = a_deftype;
        n->m_bindc_name = a_bindc_name;
        return (asr_t*)n;
    }

    struct GenericProcedure_t // Constructor
    {
        const static symbolType class_type = symbolType::GenericProcedure;
        typedef symbol_t parent_type;
        symbol_t base;
        SymbolTable* m_parent_symtab;
        char* m_name;
        symbol_t** m_procs; size_t n_procs; // Sequence
        accessType m_access;
    };
    static inline asr_t* make_GenericProcedure_t(Allocator &al, const Location &a_loc, SymbolTable* a_parent_symtab, char* a_name, symbol_t** a_procs, size_t n_procs, accessType a_access) {
        GenericProcedure_t *n;
        n = al.make_new<GenericProcedure_t>();
        n->base.type = symbolType::GenericProcedure;
        n->base.base.type = asrType::symbol;
        n->base.base.loc = a_loc;
        n->m_parent_symtab = a_parent_symtab;
        n->m_name = a_name;
        n->m_procs = a_procs;
        n->n_procs = n_procs;
        n->m_access = a_access;
        return (asr_t*)n;
    }

    struct CustomOperator_t // Constructor
    {
        const static symbolType class_type = symbolType::CustomOperator;
        typedef symbol_t parent_type;
        symbol_t base;
        SymbolTable* m_parent_symtab;
        char* m_name;
        symbol_t** m_procs; size_t n_procs; // Sequence
        accessType m_access;
    };
    static inline asr_t* make_CustomOperator_t(Allocator &al, const Location &a_loc, SymbolTable* a_parent_symtab, char* a_name, symbol_t** a_procs, size_t n_procs, accessType a_access) {
        CustomOperator_t *n;
        n = al.make_new<CustomOperator_t>();
        n->base.type = symbolType::CustomOperator;
        n->base.base.type = asrType::symbol;
        n->base.base.loc = a_loc;
        n->m_parent_symtab = a_parent_symtab;
        n->m_name = a_name;
        n->m_procs = a_procs;
        n->n_procs = n_procs;
        n->m_access = a_access;
        return (asr_t*)n;
    }

    struct ExternalSymbol_t // Constructor
    {
        const static symbolType class_type = symbolType::ExternalSymbol;
        typedef symbol_t parent_type;
        symbol_t base;
        SymbolTable* m_parent_symtab;
        char* m_name;
        symbol_t* m_external;
        char* m_module_name;
        char** m_scope_names; size_t n_scope_names; // Sequence
        char* m_original_name;
        accessType m_access;
    };
    static inline asr_t* make_ExternalSymbol_t(Allocator &al, const Location &a_loc, SymbolTable* a_parent_symtab, char* a_name, symbol_t* a_external, char* a_module_name, char** a_scope_names, size_t n_scope_names, char* a_original_name, accessType a_access) {
        ExternalSymbol_t *n;
        n = al.make_new<ExternalSymbol_t>();
        n->base.type = symbolType::ExternalSymbol;
        n->base.base.type = asrType::symbol;
        n->base.base.loc = a_loc;
        n->m_parent_symtab = a_parent_symtab;
        n->m_name = a_name;
        n->m_external = a_external;
        n->m_module_name = a_module_name;
        n->m_scope_names = a_scope_names;
        n->n_scope_names = n_scope_names;
        n->m_original_name = a_original_name;
        n->m_access = a_access;
        return (asr_t*)n;
    }

    struct DerivedType_t // Constructor
    {
        const static symbolType class_type = symbolType::DerivedType;
        typedef symbol_t parent_type;
        symbol_t base;
        SymbolTable* m_symtab;
        char* m_name;
        char** m_members; size_t n_members; // Sequence
        abiType m_abi;
        accessType m_access;
        symbol_t* m_parent;
    };
    static inline asr_t* make_DerivedType_t(Allocator &al, const Location &a_loc, SymbolTable* a_symtab, char* a_name, char** a_members, size_t n_members, abiType a_abi, accessType a_access, symbol_t* a_parent) {
        DerivedType_t *n;
        n = al.make_new<DerivedType_t>();
        n->base.type = symbolType::DerivedType;
        n->base.base.type = asrType::symbol;
        n->base.base.loc = a_loc;
        n->m_symtab = a_symtab;
        a_symtab->asr_owner = (asr_t*)n;
        n->m_name = a_name;
        n->m_members = a_members;
        n->n_members = n_members;
        n->m_abi = a_abi;
        n->m_access = a_access;
        n->m_parent = a_parent;
        return (asr_t*)n;
    }

    struct Variable_t // Constructor
    {
        const static symbolType class_type = symbolType::Variable;
        typedef symbol_t parent_type;
        symbol_t base;
        SymbolTable* m_parent_symtab;
        char* m_name;
        intentType m_intent;
        expr_t* m_symbolic_value;
        expr_t* m_value;
        storage_typeType m_storage;
        ttype_t* m_type;
        abiType m_abi;
        accessType m_access;
        presenceType m_presence;
        bool m_value_attr;
    };
    static inline asr_t* make_Variable_t(Allocator &al, const Location &a_loc, SymbolTable* a_parent_symtab, char* a_name, intentType a_intent, expr_t* a_symbolic_value, expr_t* a_value, storage_typeType a_storage, ttype_t* a_type, abiType a_abi, accessType a_access, presenceType a_presence, bool a_value_attr) {
        Variable_t *n;
        n = al.make_new<Variable_t>();
        n->base.type = symbolType::Variable;
        n->base.base.type = asrType::symbol;
        n->base.base.loc = a_loc;
        n->m_parent_symtab = a_parent_symtab;
        n->m_name = a_name;
        n->m_intent = a_intent;
        n->m_symbolic_value = a_symbolic_value;
        n->m_value = a_value;
        n->m_storage = a_storage;
        n->m_type = a_type;
        n->m_abi = a_abi;
        n->m_access = a_access;
        n->m_presence = a_presence;
        n->m_value_attr = a_value_attr;
        return (asr_t*)n;
    }

    struct ClassType_t // Constructor
    {
        const static symbolType class_type = symbolType::ClassType;
        typedef symbol_t parent_type;
        symbol_t base;
        SymbolTable* m_symtab;
        char* m_name;
        abiType m_abi;
        accessType m_access;
    };
    static inline asr_t* make_ClassType_t(Allocator &al, const Location &a_loc, SymbolTable* a_symtab, char* a_name, abiType a_abi, accessType a_access) {
        ClassType_t *n;
        n = al.make_new<ClassType_t>();
        n->base.type = symbolType::ClassType;
        n->base.base.type = asrType::symbol;
        n->base.base.loc = a_loc;
        n->m_symtab = a_symtab;
        a_symtab->asr_owner = (asr_t*)n;
        n->m_name = a_name;
        n->m_abi = a_abi;
        n->m_access = a_access;
        return (asr_t*)n;
    }

    struct ClassProcedure_t // Constructor
    {
        const static symbolType class_type = symbolType::ClassProcedure;
        typedef symbol_t parent_type;
        symbol_t base;
        SymbolTable* m_parent_symtab;
        char* m_name;
        char* m_proc_name;
        symbol_t* m_proc;
        abiType m_abi;
    };
    static inline asr_t* make_ClassProcedure_t(Allocator &al, const Location &a_loc, SymbolTable* a_parent_symtab, char* a_name, char* a_proc_name, symbol_t* a_proc, abiType a_abi) {
        ClassProcedure_t *n;
        n = al.make_new<ClassProcedure_t>();
        n->base.type = symbolType::ClassProcedure;
        n->base.base.type = asrType::symbol;
        n->base.base.loc = a_loc;
        n->m_parent_symtab = a_parent_symtab;
        n->m_name = a_name;
        n->m_proc_name = a_proc_name;
        n->m_proc = a_proc;
        n->m_abi = a_abi;
        return (asr_t*)n;
    }



enum stmtType // Types
{
    Allocate, Assign, Assignment, Associate, Cycle, ExplicitDeallocate, ImplicitDeallocate, DoConcurrentLoop, DoLoop, ErrorStop, Exit, ForAllSingle, GoTo, GoToTarget, If, IfArithmetic, Print, Open, Close, Read, Write, Return, Select, Stop, SubroutineCall, Where, WhileLoop
};

struct stmt_t // Sum
{
    const static asrType class_type = asrType::stmt;
    asr_t base;
    stmtType type;
};

    struct Allocate_t // Constructor
    {
        const static stmtType class_type = stmtType::Allocate;
        typedef stmt_t parent_type;
        stmt_t base;
        alloc_arg_t* m_args; size_t n_args; // Sequence
        expr_t* m_stat;
    };
    static inline asr_t* make_Allocate_t(Allocator &al, const Location &a_loc, alloc_arg_t* a_args, size_t n_args, expr_t* a_stat) {
        Allocate_t *n;
        n = al.make_new<Allocate_t>();
        n->base.type = stmtType::Allocate;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_stat = a_stat;
        return (asr_t*)n;
    }

    struct Assign_t // Constructor
    {
        const static stmtType class_type = stmtType::Assign;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        char* m_variable;
    };
    static inline asr_t* make_Assign_t(Allocator &al, const Location &a_loc, int64_t a_label, char* a_variable) {
        Assign_t *n;
        n = al.make_new<Assign_t>();
        n->base.type = stmtType::Assign;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_variable = a_variable;
        return (asr_t*)n;
    }

    struct Assignment_t // Constructor
    {
        const static stmtType class_type = stmtType::Assignment;
        typedef stmt_t parent_type;
        stmt_t base;
        expr_t* m_target;
        expr_t* m_value;
        stmt_t* m_overloaded;
    };
    static inline asr_t* make_Assignment_t(Allocator &al, const Location &a_loc, expr_t* a_target, expr_t* a_value, stmt_t* a_overloaded) {
        Assignment_t *n;
        n = al.make_new<Assignment_t>();
        n->base.type = stmtType::Assignment;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_target = a_target;
        n->m_value = a_value;
        n->m_overloaded = a_overloaded;
        return (asr_t*)n;
    }

    struct Associate_t // Constructor
    {
        const static stmtType class_type = stmtType::Associate;
        typedef stmt_t parent_type;
        stmt_t base;
        expr_t* m_target;
        expr_t* m_value;
    };
    static inline asr_t* make_Associate_t(Allocator &al, const Location &a_loc, expr_t* a_target, expr_t* a_value) {
        Associate_t *n;
        n = al.make_new<Associate_t>();
        n->base.type = stmtType::Associate;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_target = a_target;
        n->m_value = a_value;
        return (asr_t*)n;
    }

    struct Cycle_t // Constructor
    {
        const static stmtType class_type = stmtType::Cycle;
        typedef stmt_t parent_type;
        stmt_t base;
    };
    static inline asr_t* make_Cycle_t(Allocator &al, const Location &a_loc) {
        Cycle_t *n;
        n = al.make_new<Cycle_t>();
        n->base.type = stmtType::Cycle;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        return (asr_t*)n;
    }

    struct ExplicitDeallocate_t // Constructor
    {
        const static stmtType class_type = stmtType::ExplicitDeallocate;
        typedef stmt_t parent_type;
        stmt_t base;
        symbol_t** m_vars; size_t n_vars; // Sequence
    };
    static inline asr_t* make_ExplicitDeallocate_t(Allocator &al, const Location &a_loc, symbol_t** a_vars, size_t n_vars) {
        ExplicitDeallocate_t *n;
        n = al.make_new<ExplicitDeallocate_t>();
        n->base.type = stmtType::ExplicitDeallocate;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_vars = a_vars;
        n->n_vars = n_vars;
        return (asr_t*)n;
    }

    struct ImplicitDeallocate_t // Constructor
    {
        const static stmtType class_type = stmtType::ImplicitDeallocate;
        typedef stmt_t parent_type;
        stmt_t base;
        symbol_t** m_vars; size_t n_vars; // Sequence
    };
    static inline asr_t* make_ImplicitDeallocate_t(Allocator &al, const Location &a_loc, symbol_t** a_vars, size_t n_vars) {
        ImplicitDeallocate_t *n;
        n = al.make_new<ImplicitDeallocate_t>();
        n->base.type = stmtType::ImplicitDeallocate;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_vars = a_vars;
        n->n_vars = n_vars;
        return (asr_t*)n;
    }

    struct DoConcurrentLoop_t // Constructor
    {
        const static stmtType class_type = stmtType::DoConcurrentLoop;
        typedef stmt_t parent_type;
        stmt_t base;
        do_loop_head_t m_head;
        stmt_t** m_body; size_t n_body; // Sequence
    };
    static inline asr_t* make_DoConcurrentLoop_t(Allocator &al, const Location &a_loc, do_loop_head_t a_head, stmt_t** a_body, size_t n_body) {
        DoConcurrentLoop_t *n;
        n = al.make_new<DoConcurrentLoop_t>();
        n->base.type = stmtType::DoConcurrentLoop;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_head = a_head;
        n->m_body = a_body;
        n->n_body = n_body;
        return (asr_t*)n;
    }

    struct DoLoop_t // Constructor
    {
        const static stmtType class_type = stmtType::DoLoop;
        typedef stmt_t parent_type;
        stmt_t base;
        do_loop_head_t m_head;
        stmt_t** m_body; size_t n_body; // Sequence
    };
    static inline asr_t* make_DoLoop_t(Allocator &al, const Location &a_loc, do_loop_head_t a_head, stmt_t** a_body, size_t n_body) {
        DoLoop_t *n;
        n = al.make_new<DoLoop_t>();
        n->base.type = stmtType::DoLoop;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_head = a_head;
        n->m_body = a_body;
        n->n_body = n_body;
        return (asr_t*)n;
    }

    struct ErrorStop_t // Constructor
    {
        const static stmtType class_type = stmtType::ErrorStop;
        typedef stmt_t parent_type;
        stmt_t base;
        expr_t* m_code;
    };
    static inline asr_t* make_ErrorStop_t(Allocator &al, const Location &a_loc, expr_t* a_code) {
        ErrorStop_t *n;
        n = al.make_new<ErrorStop_t>();
        n->base.type = stmtType::ErrorStop;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_code = a_code;
        return (asr_t*)n;
    }

    struct Exit_t // Constructor
    {
        const static stmtType class_type = stmtType::Exit;
        typedef stmt_t parent_type;
        stmt_t base;
    };
    static inline asr_t* make_Exit_t(Allocator &al, const Location &a_loc) {
        Exit_t *n;
        n = al.make_new<Exit_t>();
        n->base.type = stmtType::Exit;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        return (asr_t*)n;
    }

    struct ForAllSingle_t // Constructor
    {
        const static stmtType class_type = stmtType::ForAllSingle;
        typedef stmt_t parent_type;
        stmt_t base;
        do_loop_head_t m_head;
        stmt_t* m_assign_stmt;
    };
    static inline asr_t* make_ForAllSingle_t(Allocator &al, const Location &a_loc, do_loop_head_t a_head, stmt_t* a_assign_stmt) {
        ForAllSingle_t *n;
        n = al.make_new<ForAllSingle_t>();
        n->base.type = stmtType::ForAllSingle;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_head = a_head;
        n->m_assign_stmt = a_assign_stmt;
        return (asr_t*)n;
    }

    struct GoTo_t // Constructor
    {
        const static stmtType class_type = stmtType::GoTo;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_target_id;
    };
    static inline asr_t* make_GoTo_t(Allocator &al, const Location &a_loc, int64_t a_target_id) {
        GoTo_t *n;
        n = al.make_new<GoTo_t>();
        n->base.type = stmtType::GoTo;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_target_id = a_target_id;
        return (asr_t*)n;
    }

    struct GoToTarget_t // Constructor
    {
        const static stmtType class_type = stmtType::GoToTarget;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_id;
    };
    static inline asr_t* make_GoToTarget_t(Allocator &al, const Location &a_loc, int64_t a_id) {
        GoToTarget_t *n;
        n = al.make_new<GoToTarget_t>();
        n->base.type = stmtType::GoToTarget;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_id = a_id;
        return (asr_t*)n;
    }

    struct If_t // Constructor
    {
        const static stmtType class_type = stmtType::If;
        typedef stmt_t parent_type;
        stmt_t base;
        expr_t* m_test;
        stmt_t** m_body; size_t n_body; // Sequence
        stmt_t** m_orelse; size_t n_orelse; // Sequence
    };
    static inline asr_t* make_If_t(Allocator &al, const Location &a_loc, expr_t* a_test, stmt_t** a_body, size_t n_body, stmt_t** a_orelse, size_t n_orelse) {
        If_t *n;
        n = al.make_new<If_t>();
        n->base.type = stmtType::If;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_test = a_test;
        n->m_body = a_body;
        n->n_body = n_body;
        n->m_orelse = a_orelse;
        n->n_orelse = n_orelse;
        return (asr_t*)n;
    }

    struct IfArithmetic_t // Constructor
    {
        const static stmtType class_type = stmtType::IfArithmetic;
        typedef stmt_t parent_type;
        stmt_t base;
        expr_t* m_test;
        int64_t m_lt_label;
        int64_t m_eq_label;
        int64_t m_gt_label;
    };
    static inline asr_t* make_IfArithmetic_t(Allocator &al, const Location &a_loc, expr_t* a_test, int64_t a_lt_label, int64_t a_eq_label, int64_t a_gt_label) {
        IfArithmetic_t *n;
        n = al.make_new<IfArithmetic_t>();
        n->base.type = stmtType::IfArithmetic;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_test = a_test;
        n->m_lt_label = a_lt_label;
        n->m_eq_label = a_eq_label;
        n->m_gt_label = a_gt_label;
        return (asr_t*)n;
    }

    struct Print_t // Constructor
    {
        const static stmtType class_type = stmtType::Print;
        typedef stmt_t parent_type;
        stmt_t base;
        expr_t* m_fmt;
        expr_t** m_values; size_t n_values; // Sequence
    };
    static inline asr_t* make_Print_t(Allocator &al, const Location &a_loc, expr_t* a_fmt, expr_t** a_values, size_t n_values) {
        Print_t *n;
        n = al.make_new<Print_t>();
        n->base.type = stmtType::Print;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_fmt = a_fmt;
        n->m_values = a_values;
        n->n_values = n_values;
        return (asr_t*)n;
    }

    struct Open_t // Constructor
    {
        const static stmtType class_type = stmtType::Open;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t* m_newunit;
        expr_t* m_filename;
        expr_t* m_status;
    };
    static inline asr_t* make_Open_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t* a_newunit, expr_t* a_filename, expr_t* a_status) {
        Open_t *n;
        n = al.make_new<Open_t>();
        n->base.type = stmtType::Open;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_newunit = a_newunit;
        n->m_filename = a_filename;
        n->m_status = a_status;
        return (asr_t*)n;
    }

    struct Close_t // Constructor
    {
        const static stmtType class_type = stmtType::Close;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t* m_unit;
        expr_t* m_iostat;
        expr_t* m_iomsg;
        expr_t* m_err;
        expr_t* m_status;
    };
    static inline asr_t* make_Close_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t* a_unit, expr_t* a_iostat, expr_t* a_iomsg, expr_t* a_err, expr_t* a_status) {
        Close_t *n;
        n = al.make_new<Close_t>();
        n->base.type = stmtType::Close;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_unit = a_unit;
        n->m_iostat = a_iostat;
        n->m_iomsg = a_iomsg;
        n->m_err = a_err;
        n->m_status = a_status;
        return (asr_t*)n;
    }

    struct Read_t // Constructor
    {
        const static stmtType class_type = stmtType::Read;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t* m_unit;
        expr_t* m_fmt;
        expr_t* m_iomsg;
        expr_t* m_iostat;
        expr_t* m_id;
        expr_t** m_values; size_t n_values; // Sequence
    };
    static inline asr_t* make_Read_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t* a_unit, expr_t* a_fmt, expr_t* a_iomsg, expr_t* a_iostat, expr_t* a_id, expr_t** a_values, size_t n_values) {
        Read_t *n;
        n = al.make_new<Read_t>();
        n->base.type = stmtType::Read;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_unit = a_unit;
        n->m_fmt = a_fmt;
        n->m_iomsg = a_iomsg;
        n->m_iostat = a_iostat;
        n->m_id = a_id;
        n->m_values = a_values;
        n->n_values = n_values;
        return (asr_t*)n;
    }

    struct Write_t // Constructor
    {
        const static stmtType class_type = stmtType::Write;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t* m_unit;
        expr_t* m_fmt;
        expr_t* m_iomsg;
        expr_t* m_iostat;
        expr_t* m_id;
        expr_t** m_values; size_t n_values; // Sequence
    };
    static inline asr_t* make_Write_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t* a_unit, expr_t* a_fmt, expr_t* a_iomsg, expr_t* a_iostat, expr_t* a_id, expr_t** a_values, size_t n_values) {
        Write_t *n;
        n = al.make_new<Write_t>();
        n->base.type = stmtType::Write;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_unit = a_unit;
        n->m_fmt = a_fmt;
        n->m_iomsg = a_iomsg;
        n->m_iostat = a_iostat;
        n->m_id = a_id;
        n->m_values = a_values;
        n->n_values = n_values;
        return (asr_t*)n;
    }

    struct Return_t // Constructor
    {
        const static stmtType class_type = stmtType::Return;
        typedef stmt_t parent_type;
        stmt_t base;
    };
    static inline asr_t* make_Return_t(Allocator &al, const Location &a_loc) {
        Return_t *n;
        n = al.make_new<Return_t>();
        n->base.type = stmtType::Return;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        return (asr_t*)n;
    }

    struct Select_t // Constructor
    {
        const static stmtType class_type = stmtType::Select;
        typedef stmt_t parent_type;
        stmt_t base;
        expr_t* m_test;
        case_stmt_t** m_body; size_t n_body; // Sequence
        stmt_t** m_default; size_t n_default; // Sequence
    };
    static inline asr_t* make_Select_t(Allocator &al, const Location &a_loc, expr_t* a_test, case_stmt_t** a_body, size_t n_body, stmt_t** a_default, size_t n_default) {
        Select_t *n;
        n = al.make_new<Select_t>();
        n->base.type = stmtType::Select;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_test = a_test;
        n->m_body = a_body;
        n->n_body = n_body;
        n->m_default = a_default;
        n->n_default = n_default;
        return (asr_t*)n;
    }

    struct Stop_t // Constructor
    {
        const static stmtType class_type = stmtType::Stop;
        typedef stmt_t parent_type;
        stmt_t base;
        expr_t* m_code;
    };
    static inline asr_t* make_Stop_t(Allocator &al, const Location &a_loc, expr_t* a_code) {
        Stop_t *n;
        n = al.make_new<Stop_t>();
        n->base.type = stmtType::Stop;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_code = a_code;
        return (asr_t*)n;
    }

    struct SubroutineCall_t // Constructor
    {
        const static stmtType class_type = stmtType::SubroutineCall;
        typedef stmt_t parent_type;
        stmt_t base;
        symbol_t* m_name;
        symbol_t* m_original_name;
        expr_t** m_args; size_t n_args; // Sequence
        expr_t* m_dt;
    };
    static inline asr_t* make_SubroutineCall_t(Allocator &al, const Location &a_loc, symbol_t* a_name, symbol_t* a_original_name, expr_t** a_args, size_t n_args, expr_t* a_dt) {
        SubroutineCall_t *n;
        n = al.make_new<SubroutineCall_t>();
        n->base.type = stmtType::SubroutineCall;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_name = a_name;
        n->m_original_name = a_original_name;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_dt = a_dt;
        return (asr_t*)n;
    }

    struct Where_t // Constructor
    {
        const static stmtType class_type = stmtType::Where;
        typedef stmt_t parent_type;
        stmt_t base;
        expr_t* m_test;
        stmt_t** m_body; size_t n_body; // Sequence
        stmt_t** m_orelse; size_t n_orelse; // Sequence
    };
    static inline asr_t* make_Where_t(Allocator &al, const Location &a_loc, expr_t* a_test, stmt_t** a_body, size_t n_body, stmt_t** a_orelse, size_t n_orelse) {
        Where_t *n;
        n = al.make_new<Where_t>();
        n->base.type = stmtType::Where;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_test = a_test;
        n->m_body = a_body;
        n->n_body = n_body;
        n->m_orelse = a_orelse;
        n->n_orelse = n_orelse;
        return (asr_t*)n;
    }

    struct WhileLoop_t // Constructor
    {
        const static stmtType class_type = stmtType::WhileLoop;
        typedef stmt_t parent_type;
        stmt_t base;
        expr_t* m_test;
        stmt_t** m_body; size_t n_body; // Sequence
    };
    static inline asr_t* make_WhileLoop_t(Allocator &al, const Location &a_loc, expr_t* a_test, stmt_t** a_body, size_t n_body) {
        WhileLoop_t *n;
        n = al.make_new<WhileLoop_t>();
        n->base.type = stmtType::WhileLoop;
        n->base.base.type = asrType::stmt;
        n->base.base.loc = a_loc;
        n->m_test = a_test;
        n->m_body = a_body;
        n->n_body = n_body;
        return (asr_t*)n;
    }



enum exprType // Types
{
    BoolOp, BinOp, StrOp, UnaryOp, ComplexConstructor, Compare, FunctionCall, DerivedTypeConstructor, ConstantArray, ImpliedDoLoop, ConstantInteger, ConstantReal, ConstantComplex, ConstantLogical, ConstantString, BOZ, Var, ArrayRef, DerivedRef, ImplicitCast, ExplicitCast
};

struct expr_t // Sum
{
    const static asrType class_type = asrType::expr;
    asr_t base;
    exprType type;
};

    struct BoolOp_t // Constructor
    {
        const static exprType class_type = exprType::BoolOp;
        typedef expr_t parent_type;
        expr_t base;
        expr_t* m_left;
        boolopType m_op;
        expr_t* m_right;
        ttype_t* m_type;
        expr_t* m_value;
    };
    static inline asr_t* make_BoolOp_t(Allocator &al, const Location &a_loc, expr_t* a_left, boolopType a_op, expr_t* a_right, ttype_t* a_type, expr_t* a_value) {
        BoolOp_t *n;
        n = al.make_new<BoolOp_t>();
        n->base.type = exprType::BoolOp;
        n->base.base.type = asrType::expr;
        n->base.base.loc = a_loc;
        n->m_left = a_left;
        n->m_op = a_op;
        n->m_right = a_right;
        n->m_type = a_type;
        n->m_value = a_value;
        return (asr_t*)n;
    }

    struct BinOp_t // Constructor
    {
        const static exprType class_type = exprType::BinOp;
        typedef expr_t parent_type;
        expr_t base;
        expr_t* m_left;
        binopType m_op;
        expr_t* m_right;
        ttype_t* m_type;
        expr_t* m_value;
        expr_t* m_overloaded;
    };
    static inline asr_t* make_BinOp_t(Allocator &al, const Location &a_loc, expr_t* a_left, binopType a_op, expr_t* a_right, ttype_t* a_type, expr_t* a_value, expr_t* a_overloaded) {
        BinOp_t *n;
        n = al.make_new<BinOp_t>();
        n->base.type = exprType::BinOp;
        n->base.base.type = asrType::expr;
        n->base.base.loc = a_loc;
        n->m_left = a_left;
        n->m_op = a_op;
        n->m_right = a_right;
        n->m_type = a_type;
        n->m_value = a_value;
        n->m_overloaded = a_overloaded;
        return (asr_t*)n;
    }

    struct StrOp_t // Constructor
    {
        const static exprType class_type = exprType::StrOp;
        typedef expr_t parent_type;
        expr_t base;
        expr_t* m_left;
        stropType m_op;
        expr_t* m_right;
        ttype_t* m_type;
        expr_t* m_value;
    };
    static inline asr_t* make_StrOp_t(Allocator &al, const Location &a_loc, expr_t* a_left, stropType a_op, expr_t* a_right, ttype_t* a_type, expr_t* a_value) {
        StrOp_t *n;
        n = al.make_new<StrOp_t>();
        n->base.type = exprType::StrOp;
        n->base.base.type = asrType::expr;
        n->base.base.loc = a_loc;
        n->m_left = a_left;
        n->m_op = a_op;
        n->m_right = a_right;
        n->m_type = a_type;
        n->m_value = a_value;
        return (asr_t*)n;
    }

    struct UnaryOp_t // Constructor
    {
        const static exprType class_type = exprType::UnaryOp;
        typedef expr_t parent_type;
        expr_t base;
        unaryopType m_op;
        expr_t* m_operand;
        ttype_t* m_type;
        expr_t* m_value;
    };
    static inline asr_t* make_UnaryOp_t(Allocator &al, const Location &a_loc, unaryopType a_op, expr_t* a_operand, ttype_t* a_type, expr_t* a_value) {
        UnaryOp_t *n;
        n = al.make_new<UnaryOp_t>();
        n->base.type = exprType::UnaryOp;
        n->base.base.type = asrType::expr;
        n->base.base.loc = a_loc;
        n->m_op = a_op;
        n->m_operand = a_operand;
        n->m_type = a_type;
        n->m_value = a_value;
        return (asr_t*)n;
    }

    struct ComplexConstructor_t // Constructor
    {
        const static exprType class_type = exprType::ComplexConstructor;
        typedef expr_t parent_type;
        expr_t base;
        expr_t* m_re;
        expr_t* m_im;
        ttype_t* m_type;
        expr_t* m_value;
    };
    static inline asr_t* make_ComplexConstructor_t(Allocator &al, const Location &a_loc, expr_t* a_re, expr_t* a_im, ttype_t* a_type, expr_t* a_value) {
        ComplexConstructor_t *n;
        n = al.make_new<ComplexConstructor_t>();
        n->base.type = exprType::ComplexConstructor;
        n->base.base.type = asrType::expr;
        n->base.base.loc = a_loc;
        n->m_re = a_re;
        n->m_im = a_im;
        n->m_type = a_type;
        n->m_value = a_value;
        return (asr_t*)n;
    }

    struct Compare_t // Constructor
    {
        const static exprType class_type = exprType::Compare;
        typedef expr_t parent_type;
        expr_t base;
        expr_t* m_left;
        cmpopType m_op;
        expr_t* m_right;
        ttype_t* m_type;
        expr_t* m_value;
        expr_t* m_overloaded;
    };
    static inline asr_t* make_Compare_t(Allocator &al, const Location &a_loc, expr_t* a_left, cmpopType a_op, expr_t* a_right, ttype_t* a_type, expr_t* a_value, expr_t* a_overloaded) {
        Compare_t *n;
        n = al.make_new<Compare_t>();
        n->base.type = exprType::Compare;
        n->base.base.type = asrType::expr;
        n->base.base.loc = a_loc;
        n->m_left = a_left;
        n->m_op = a_op;
        n->m_right = a_right;
        n->m_type = a_type;
        n->m_value = a_value;
        n->m_overloaded = a_overloaded;
        return (asr_t*)n;
    }

    struct FunctionCall_t // Constructor
    {
        const static exprType class_type = exprType::FunctionCall;
        typedef expr_t parent_type;
        expr_t base;
        symbol_t* m_name;
        symbol_t* m_original_name;
        expr_t** m_args; size_t n_args; // Sequence
        keyword_t* m_keywords; size_t n_keywords; // Sequence
        ttype_t* m_type;
        expr_t* m_value;
        expr_t* m_dt;
    };
    static inline asr_t* make_FunctionCall_t(Allocator &al, const Location &a_loc, symbol_t* a_name, symbol_t* a_original_name, expr_t** a_args, size_t n_args, keyword_t* a_keywords, size_t n_keywords, ttype_t* a_type, expr_t* a_value, expr_t* a_dt) {
        FunctionCall_t *n;
        n = al.make_new<FunctionCall_t>();
        n->base.type = exprType::FunctionCall;
        n->base.base.type = asrType::expr;
        n->base.base.loc = a_loc;
        n->m_name = a_name;
        n->m_original_name = a_original_name;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_keywords = a_keywords;
        n->n_keywords = n_keywords;
        n->m_type = a_type;
        n->m_value = a_value;
        n->m_dt = a_dt;
        return (asr_t*)n;
    }

    struct DerivedTypeConstructor_t // Constructor
    {
        const static exprType class_type = exprType::DerivedTypeConstructor;
        typedef expr_t parent_type;
        expr_t base;
        symbol_t* m_dt_sym;
        expr_t** m_args; size_t n_args; // Sequence
        ttype_t* m_type;
    };
    static inline asr_t* make_DerivedTypeConstructor_t(Allocator &al, const Location &a_loc, symbol_t* a_dt_sym, expr_t** a_args, size_t n_args, ttype_t* a_type) {
        DerivedTypeConstructor_t *n;
        n = al.make_new<DerivedTypeConstructor_t>();
        n->base.type = exprType::DerivedTypeConstructor;
        n->base.base.type = asrType::expr;
        n->base.base.loc = a_loc;
        n->m_dt_sym = a_dt_sym;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_type = a_type;
        return (asr_t*)n;
    }

    struct ConstantArray_t // Constructor
    {
        const static exprType class_type = exprType::ConstantArray;
        typedef expr_t parent_type;
        expr_t base;
        expr_t** m_args; size_t n_args; // Sequence
        ttype_t* m_type;
    };
    static inline asr_t* make_ConstantArray_t(Allocator &al, const Location &a_loc, expr_t** a_args, size_t n_args, ttype_t* a_type) {
        ConstantArray_t *n;
        n = al.make_new<ConstantArray_t>();
        n->base.type = exprType::ConstantArray;
        n->base.base.type = asrType::expr;
        n->base.base.loc = a_loc;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_type = a_type;
        return (asr_t*)n;
    }

    struct ImpliedDoLoop_t // Constructor
    {
        const static exprType class_type = exprType::ImpliedDoLoop;
        typedef expr_t parent_type;
        expr_t base;
        expr_t** m_values; size_t n_values; // Sequence
        expr_t* m_var;
        expr_t* m_start;
        expr_t* m_end;
        expr_t* m_increment;
        ttype_t* m_type;
        expr_t* m_value;
    };
    static inline asr_t* make_ImpliedDoLoop_t(Allocator &al, const Location &a_loc, expr_t** a_values, size_t n_values, expr_t* a_var, expr_t* a_start, expr_t* a_end, expr_t* a_increment, ttype_t* a_type, expr_t* a_value) {
        ImpliedDoLoop_t *n;
        n = al.make_new<ImpliedDoLoop_t>();
        n->base.type = exprType::ImpliedDoLoop;
        n->base.base.type = asrType::expr;
        n->base.base.loc = a_loc;
        n->m_values = a_values;
        n->n_values = n_values;
        n->m_var = a_var;
        n->m_start = a_start;
        n->m_end = a_end;
        n->m_increment = a_increment;
        n->m_type = a_type;
        n->m_value = a_value;
        return (asr_t*)n;
    }

    struct ConstantInteger_t // Constructor
    {
        const static exprType class_type = exprType::ConstantInteger;
        typedef expr_t parent_type;
        expr_t base;
        int64_t m_n;
        ttype_t* m_type;
    };
    static inline asr_t* make_ConstantInteger_t(Allocator &al, const Location &a_loc, int64_t a_n, ttype_t* a_type) {
        ConstantInteger_t *n;
        n = al.make_new<ConstantInteger_t>();
        n->base.type = exprType::ConstantInteger;
        n->base.base.type = asrType::expr;
        n->base.base.loc = a_loc;
        n->m_n = a_n;
        n->m_type = a_type;
        return (asr_t*)n;
    }

    struct ConstantReal_t // Constructor
    {
        const static exprType class_type = exprType::ConstantReal;
        typedef expr_t parent_type;
        expr_t base;
        double m_r;
        ttype_t* m_type;
    };
    static inline asr_t* make_ConstantReal_t(Allocator &al, const Location &a_loc, double a_r, ttype_t* a_type) {
        ConstantReal_t *n;
        n = al.make_new<ConstantReal_t>();
        n->base.type = exprType::ConstantReal;
        n->base.base.type = asrType::expr;
        n->base.base.loc = a_loc;
        n->m_r = a_r;
        n->m_type = a_type;
        return (asr_t*)n;
    }

    struct ConstantComplex_t // Constructor
    {
        const static exprType class_type = exprType::ConstantComplex;
        typedef expr_t parent_type;
        expr_t base;
        double m_re;
        double m_im;
        ttype_t* m_type;
    };
    static inline asr_t* make_ConstantComplex_t(Allocator &al, const Location &a_loc, double a_re, double a_im, ttype_t* a_type) {
        ConstantComplex_t *n;
        n = al.make_new<ConstantComplex_t>();
        n->base.type = exprType::ConstantComplex;
        n->base.base.type = asrType::expr;
        n->base.base.loc = a_loc;
        n->m_re = a_re;
        n->m_im = a_im;
        n->m_type = a_type;
        return (asr_t*)n;
    }

    struct ConstantLogical_t // Constructor
    {
        const static exprType class_type = exprType::ConstantLogical;
        typedef expr_t parent_type;
        expr_t base;
        bool m_value;
        ttype_t* m_type;
    };
    static inline asr_t* make_ConstantLogical_t(Allocator &al, const Location &a_loc, bool a_value, ttype_t* a_type) {
        ConstantLogical_t *n;
        n = al.make_new<ConstantLogical_t>();
        n->base.type = exprType::ConstantLogical;
        n->base.base.type = asrType::expr;
        n->base.base.loc = a_loc;
        n->m_value = a_value;
        n->m_type = a_type;
        return (asr_t*)n;
    }

    struct ConstantString_t // Constructor
    {
        const static exprType class_type = exprType::ConstantString;
        typedef expr_t parent_type;
        expr_t base;
        char* m_s;
        ttype_t* m_type;
    };
    static inline asr_t* make_ConstantString_t(Allocator &al, const Location &a_loc, char* a_s, ttype_t* a_type) {
        ConstantString_t *n;
        n = al.make_new<ConstantString_t>();
        n->base.type = exprType::ConstantString;
        n->base.base.type = asrType::expr;
        n->base.base.loc = a_loc;
        n->m_s = a_s;
        n->m_type = a_type;
        return (asr_t*)n;
    }

    struct BOZ_t // Constructor
    {
        const static exprType class_type = exprType::BOZ;
        typedef expr_t parent_type;
        expr_t base;
        int64_t m_v;
        bozType m_boz_type;
        ttype_t* m_type;
    };
    static inline asr_t* make_BOZ_t(Allocator &al, const Location &a_loc, int64_t a_v, bozType a_boz_type, ttype_t* a_type) {
        BOZ_t *n;
        n = al.make_new<BOZ_t>();
        n->base.type = exprType::BOZ;
        n->base.base.type = asrType::expr;
        n->base.base.loc = a_loc;
        n->m_v = a_v;
        n->m_boz_type = a_boz_type;
        n->m_type = a_type;
        return (asr_t*)n;
    }

    struct Var_t // Constructor
    {
        const static exprType class_type = exprType::Var;
        typedef expr_t parent_type;
        expr_t base;
        symbol_t* m_v;
    };
    static inline asr_t* make_Var_t(Allocator &al, const Location &a_loc, symbol_t* a_v) {
        Var_t *n;
        n = al.make_new<Var_t>();
        n->base.type = exprType::Var;
        n->base.base.type = asrType::expr;
        n->base.base.loc = a_loc;
        n->m_v = a_v;
        return (asr_t*)n;
    }

    struct ArrayRef_t // Constructor
    {
        const static exprType class_type = exprType::ArrayRef;
        typedef expr_t parent_type;
        expr_t base;
        symbol_t* m_v;
        array_index_t* m_args; size_t n_args; // Sequence
        ttype_t* m_type;
        expr_t* m_value;
    };
    static inline asr_t* make_ArrayRef_t(Allocator &al, const Location &a_loc, symbol_t* a_v, array_index_t* a_args, size_t n_args, ttype_t* a_type, expr_t* a_value) {
        ArrayRef_t *n;
        n = al.make_new<ArrayRef_t>();
        n->base.type = exprType::ArrayRef;
        n->base.base.type = asrType::expr;
        n->base.base.loc = a_loc;
        n->m_v = a_v;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_type = a_type;
        n->m_value = a_value;
        return (asr_t*)n;
    }

    struct DerivedRef_t // Constructor
    {
        const static exprType class_type = exprType::DerivedRef;
        typedef expr_t parent_type;
        expr_t base;
        expr_t* m_v;
        symbol_t* m_m;
        ttype_t* m_type;
        expr_t* m_value;
    };
    static inline asr_t* make_DerivedRef_t(Allocator &al, const Location &a_loc, expr_t* a_v, symbol_t* a_m, ttype_t* a_type, expr_t* a_value) {
        DerivedRef_t *n;
        n = al.make_new<DerivedRef_t>();
        n->base.type = exprType::DerivedRef;
        n->base.base.type = asrType::expr;
        n->base.base.loc = a_loc;
        n->m_v = a_v;
        n->m_m = a_m;
        n->m_type = a_type;
        n->m_value = a_value;
        return (asr_t*)n;
    }

    struct ImplicitCast_t // Constructor
    {
        const static exprType class_type = exprType::ImplicitCast;
        typedef expr_t parent_type;
        expr_t base;
        expr_t* m_arg;
        cast_kindType m_kind;
        ttype_t* m_type;
        expr_t* m_value;
    };
    static inline asr_t* make_ImplicitCast_t(Allocator &al, const Location &a_loc, expr_t* a_arg, cast_kindType a_kind, ttype_t* a_type, expr_t* a_value) {
        ImplicitCast_t *n;
        n = al.make_new<ImplicitCast_t>();
        n->base.type = exprType::ImplicitCast;
        n->base.base.type = asrType::expr;
        n->base.base.loc = a_loc;
        n->m_arg = a_arg;
        n->m_kind = a_kind;
        n->m_type = a_type;
        n->m_value = a_value;
        return (asr_t*)n;
    }

    struct ExplicitCast_t // Constructor
    {
        const static exprType class_type = exprType::ExplicitCast;
        typedef expr_t parent_type;
        expr_t base;
        expr_t* m_arg;
        cast_kindType m_kind;
        ttype_t* m_type;
        expr_t* m_value;
    };
    static inline asr_t* make_ExplicitCast_t(Allocator &al, const Location &a_loc, expr_t* a_arg, cast_kindType a_kind, ttype_t* a_type, expr_t* a_value) {
        ExplicitCast_t *n;
        n = al.make_new<ExplicitCast_t>();
        n->base.type = exprType::ExplicitCast;
        n->base.base.type = asrType::expr;
        n->base.base.loc = a_loc;
        n->m_arg = a_arg;
        n->m_kind = a_kind;
        n->m_type = a_type;
        n->m_value = a_value;
        return (asr_t*)n;
    }



enum ttypeType // Types
{
    Integer, Real, Complex, Character, Logical, Derived, Class, Pointer
};

struct ttype_t // Sum
{
    const static asrType class_type = asrType::ttype;
    asr_t base;
    ttypeType type;
};

    struct Integer_t // Constructor
    {
        const static ttypeType class_type = ttypeType::Integer;
        typedef ttype_t parent_type;
        ttype_t base;
        int64_t m_kind;
        dimension_t* m_dims; size_t n_dims; // Sequence
    };
    static inline asr_t* make_Integer_t(Allocator &al, const Location &a_loc, int64_t a_kind, dimension_t* a_dims, size_t n_dims) {
        Integer_t *n;
        n = al.make_new<Integer_t>();
        n->base.type = ttypeType::Integer;
        n->base.base.type = asrType::ttype;
        n->base.base.loc = a_loc;
        n->m_kind = a_kind;
        n->m_dims = a_dims;
        n->n_dims = n_dims;
        return (asr_t*)n;
    }

    struct Real_t // Constructor
    {
        const static ttypeType class_type = ttypeType::Real;
        typedef ttype_t parent_type;
        ttype_t base;
        int64_t m_kind;
        dimension_t* m_dims; size_t n_dims; // Sequence
    };
    static inline asr_t* make_Real_t(Allocator &al, const Location &a_loc, int64_t a_kind, dimension_t* a_dims, size_t n_dims) {
        Real_t *n;
        n = al.make_new<Real_t>();
        n->base.type = ttypeType::Real;
        n->base.base.type = asrType::ttype;
        n->base.base.loc = a_loc;
        n->m_kind = a_kind;
        n->m_dims = a_dims;
        n->n_dims = n_dims;
        return (asr_t*)n;
    }

    struct Complex_t // Constructor
    {
        const static ttypeType class_type = ttypeType::Complex;
        typedef ttype_t parent_type;
        ttype_t base;
        int64_t m_kind;
        dimension_t* m_dims; size_t n_dims; // Sequence
    };
    static inline asr_t* make_Complex_t(Allocator &al, const Location &a_loc, int64_t a_kind, dimension_t* a_dims, size_t n_dims) {
        Complex_t *n;
        n = al.make_new<Complex_t>();
        n->base.type = ttypeType::Complex;
        n->base.base.type = asrType::ttype;
        n->base.base.loc = a_loc;
        n->m_kind = a_kind;
        n->m_dims = a_dims;
        n->n_dims = n_dims;
        return (asr_t*)n;
    }

    struct Character_t // Constructor
    {
        const static ttypeType class_type = ttypeType::Character;
        typedef ttype_t parent_type;
        ttype_t base;
        int64_t m_kind;
        int64_t m_len;
        expr_t* m_len_expr;
        dimension_t* m_dims; size_t n_dims; // Sequence
    };
    static inline asr_t* make_Character_t(Allocator &al, const Location &a_loc, int64_t a_kind, int64_t a_len, expr_t* a_len_expr, dimension_t* a_dims, size_t n_dims) {
        Character_t *n;
        n = al.make_new<Character_t>();
        n->base.type = ttypeType::Character;
        n->base.base.type = asrType::ttype;
        n->base.base.loc = a_loc;
        n->m_kind = a_kind;
        n->m_len = a_len;
        n->m_len_expr = a_len_expr;
        n->m_dims = a_dims;
        n->n_dims = n_dims;
        return (asr_t*)n;
    }

    struct Logical_t // Constructor
    {
        const static ttypeType class_type = ttypeType::Logical;
        typedef ttype_t parent_type;
        ttype_t base;
        int64_t m_kind;
        dimension_t* m_dims; size_t n_dims; // Sequence
    };
    static inline asr_t* make_Logical_t(Allocator &al, const Location &a_loc, int64_t a_kind, dimension_t* a_dims, size_t n_dims) {
        Logical_t *n;
        n = al.make_new<Logical_t>();
        n->base.type = ttypeType::Logical;
        n->base.base.type = asrType::ttype;
        n->base.base.loc = a_loc;
        n->m_kind = a_kind;
        n->m_dims = a_dims;
        n->n_dims = n_dims;
        return (asr_t*)n;
    }

    struct Derived_t // Constructor
    {
        const static ttypeType class_type = ttypeType::Derived;
        typedef ttype_t parent_type;
        ttype_t base;
        symbol_t* m_derived_type;
        dimension_t* m_dims; size_t n_dims; // Sequence
    };
    static inline asr_t* make_Derived_t(Allocator &al, const Location &a_loc, symbol_t* a_derived_type, dimension_t* a_dims, size_t n_dims) {
        Derived_t *n;
        n = al.make_new<Derived_t>();
        n->base.type = ttypeType::Derived;
        n->base.base.type = asrType::ttype;
        n->base.base.loc = a_loc;
        n->m_derived_type = a_derived_type;
        n->m_dims = a_dims;
        n->n_dims = n_dims;
        return (asr_t*)n;
    }

    struct Class_t // Constructor
    {
        const static ttypeType class_type = ttypeType::Class;
        typedef ttype_t parent_type;
        ttype_t base;
        symbol_t* m_class_type;
        dimension_t* m_dims; size_t n_dims; // Sequence
    };
    static inline asr_t* make_Class_t(Allocator &al, const Location &a_loc, symbol_t* a_class_type, dimension_t* a_dims, size_t n_dims) {
        Class_t *n;
        n = al.make_new<Class_t>();
        n->base.type = ttypeType::Class;
        n->base.base.type = asrType::ttype;
        n->base.base.loc = a_loc;
        n->m_class_type = a_class_type;
        n->m_dims = a_dims;
        n->n_dims = n_dims;
        return (asr_t*)n;
    }

    struct Pointer_t // Constructor
    {
        const static ttypeType class_type = ttypeType::Pointer;
        typedef ttype_t parent_type;
        ttype_t base;
        ttype_t* m_type;
    };
    static inline asr_t* make_Pointer_t(Allocator &al, const Location &a_loc, ttype_t* a_type) {
        Pointer_t *n;
        n = al.make_new<Pointer_t>();
        n->base.type = ttypeType::Pointer;
        n->base.base.type = asrType::ttype;
        n->base.base.loc = a_loc;
        n->m_type = a_type;
        return (asr_t*)n;
    }



enum attributeType // Types
{
    Attribute
};

struct attribute_t // Sum
{
    const static asrType class_type = asrType::attribute;
    asr_t base;
    attributeType type;
};

    struct Attribute_t // Constructor
    {
        const static attributeType class_type = attributeType::Attribute;
        typedef attribute_t parent_type;
        attribute_t base;
        char* m_name;
        attribute_arg_t* m_args; size_t n_args; // Sequence
    };
    static inline asr_t* make_Attribute_t(Allocator &al, const Location &a_loc, char* a_name, attribute_arg_t* a_args, size_t n_args) {
        Attribute_t *n;
        n = al.make_new<Attribute_t>();
        n->base.type = attributeType::Attribute;
        n->base.base.type = asrType::attribute;
        n->base.base.loc = a_loc;
        n->m_name = a_name;
        n->m_args = a_args;
        n->n_args = n_args;
        return (asr_t*)n;
    }



enum tbindType // Types
{
    Bind
};

struct tbind_t // Sum
{
    const static asrType class_type = asrType::tbind;
    asr_t base;
    tbindType type;
};

    struct Bind_t // Constructor
    {
        const static tbindType class_type = tbindType::Bind;
        typedef tbind_t parent_type;
        tbind_t base;
        char* m_lang;
        char* m_name;
    };
    static inline asr_t* make_Bind_t(Allocator &al, const Location &a_loc, char* a_lang, char* a_name) {
        Bind_t *n;
        n = al.make_new<Bind_t>();
        n->base.type = tbindType::Bind;
        n->base.base.type = asrType::tbind;
        n->base.base.loc = a_loc;
        n->m_lang = a_lang;
        n->m_name = a_name;
        return (asr_t*)n;
    }



enum case_stmtType // Types
{
    CaseStmt, CaseStmt_Range
};

struct case_stmt_t // Sum
{
    const static asrType class_type = asrType::case_stmt;
    asr_t base;
    case_stmtType type;
};

    struct CaseStmt_t // Constructor
    {
        const static case_stmtType class_type = case_stmtType::CaseStmt;
        typedef case_stmt_t parent_type;
        case_stmt_t base;
        expr_t** m_test; size_t n_test; // Sequence
        stmt_t** m_body; size_t n_body; // Sequence
    };
    static inline asr_t* make_CaseStmt_t(Allocator &al, const Location &a_loc, expr_t** a_test, size_t n_test, stmt_t** a_body, size_t n_body) {
        CaseStmt_t *n;
        n = al.make_new<CaseStmt_t>();
        n->base.type = case_stmtType::CaseStmt;
        n->base.base.type = asrType::case_stmt;
        n->base.base.loc = a_loc;
        n->m_test = a_test;
        n->n_test = n_test;
        n->m_body = a_body;
        n->n_body = n_body;
        return (asr_t*)n;
    }

    struct CaseStmt_Range_t // Constructor
    {
        const static case_stmtType class_type = case_stmtType::CaseStmt_Range;
        typedef case_stmt_t parent_type;
        case_stmt_t base;
        expr_t* m_start;
        expr_t* m_end;
        stmt_t** m_body; size_t n_body; // Sequence
    };
    static inline asr_t* make_CaseStmt_Range_t(Allocator &al, const Location &a_loc, expr_t* a_start, expr_t* a_end, stmt_t** a_body, size_t n_body) {
        CaseStmt_Range_t *n;
        n = al.make_new<CaseStmt_Range_t>();
        n->base.type = case_stmtType::CaseStmt_Range;
        n->base.base.type = asrType::case_stmt;
        n->base.base.loc = a_loc;
        n->m_start = a_start;
        n->m_end = a_end;
        n->m_body = a_body;
        n->n_body = n_body;
        return (asr_t*)n;
    }





/******************************************************************************/
// Visitor functions

template <class Visitor>
static void visit_unit_t(const unit_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == asrType::unit)
    switch (x.type) {
        case unitType::TranslationUnit: { v.visit_TranslationUnit((const TranslationUnit_t &)x); return; }
    }
}

template <class Visitor>
static void visit_symbol_t(const symbol_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == asrType::symbol)
    switch (x.type) {
        case symbolType::Program: { v.visit_Program((const Program_t &)x); return; }
        case symbolType::Module: { v.visit_Module((const Module_t &)x); return; }
        case symbolType::Subroutine: { v.visit_Subroutine((const Subroutine_t &)x); return; }
        case symbolType::Function: { v.visit_Function((const Function_t &)x); return; }
        case symbolType::GenericProcedure: { v.visit_GenericProcedure((const GenericProcedure_t &)x); return; }
        case symbolType::CustomOperator: { v.visit_CustomOperator((const CustomOperator_t &)x); return; }
        case symbolType::ExternalSymbol: { v.visit_ExternalSymbol((const ExternalSymbol_t &)x); return; }
        case symbolType::DerivedType: { v.visit_DerivedType((const DerivedType_t &)x); return; }
        case symbolType::Variable: { v.visit_Variable((const Variable_t &)x); return; }
        case symbolType::ClassType: { v.visit_ClassType((const ClassType_t &)x); return; }
        case symbolType::ClassProcedure: { v.visit_ClassProcedure((const ClassProcedure_t &)x); return; }
    }
}

template <class Visitor>
static void visit_stmt_t(const stmt_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == asrType::stmt)
    switch (x.type) {
        case stmtType::Allocate: { v.visit_Allocate((const Allocate_t &)x); return; }
        case stmtType::Assign: { v.visit_Assign((const Assign_t &)x); return; }
        case stmtType::Assignment: { v.visit_Assignment((const Assignment_t &)x); return; }
        case stmtType::Associate: { v.visit_Associate((const Associate_t &)x); return; }
        case stmtType::Cycle: { v.visit_Cycle((const Cycle_t &)x); return; }
        case stmtType::ExplicitDeallocate: { v.visit_ExplicitDeallocate((const ExplicitDeallocate_t &)x); return; }
        case stmtType::ImplicitDeallocate: { v.visit_ImplicitDeallocate((const ImplicitDeallocate_t &)x); return; }
        case stmtType::DoConcurrentLoop: { v.visit_DoConcurrentLoop((const DoConcurrentLoop_t &)x); return; }
        case stmtType::DoLoop: { v.visit_DoLoop((const DoLoop_t &)x); return; }
        case stmtType::ErrorStop: { v.visit_ErrorStop((const ErrorStop_t &)x); return; }
        case stmtType::Exit: { v.visit_Exit((const Exit_t &)x); return; }
        case stmtType::ForAllSingle: { v.visit_ForAllSingle((const ForAllSingle_t &)x); return; }
        case stmtType::GoTo: { v.visit_GoTo((const GoTo_t &)x); return; }
        case stmtType::GoToTarget: { v.visit_GoToTarget((const GoToTarget_t &)x); return; }
        case stmtType::If: { v.visit_If((const If_t &)x); return; }
        case stmtType::IfArithmetic: { v.visit_IfArithmetic((const IfArithmetic_t &)x); return; }
        case stmtType::Print: { v.visit_Print((const Print_t &)x); return; }
        case stmtType::Open: { v.visit_Open((const Open_t &)x); return; }
        case stmtType::Close: { v.visit_Close((const Close_t &)x); return; }
        case stmtType::Read: { v.visit_Read((const Read_t &)x); return; }
        case stmtType::Write: { v.visit_Write((const Write_t &)x); return; }
        case stmtType::Return: { v.visit_Return((const Return_t &)x); return; }
        case stmtType::Select: { v.visit_Select((const Select_t &)x); return; }
        case stmtType::Stop: { v.visit_Stop((const Stop_t &)x); return; }
        case stmtType::SubroutineCall: { v.visit_SubroutineCall((const SubroutineCall_t &)x); return; }
        case stmtType::Where: { v.visit_Where((const Where_t &)x); return; }
        case stmtType::WhileLoop: { v.visit_WhileLoop((const WhileLoop_t &)x); return; }
    }
}

template <class Visitor>
static void visit_expr_t(const expr_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == asrType::expr)
    switch (x.type) {
        case exprType::BoolOp: { v.visit_BoolOp((const BoolOp_t &)x); return; }
        case exprType::BinOp: { v.visit_BinOp((const BinOp_t &)x); return; }
        case exprType::StrOp: { v.visit_StrOp((const StrOp_t &)x); return; }
        case exprType::UnaryOp: { v.visit_UnaryOp((const UnaryOp_t &)x); return; }
        case exprType::ComplexConstructor: { v.visit_ComplexConstructor((const ComplexConstructor_t &)x); return; }
        case exprType::Compare: { v.visit_Compare((const Compare_t &)x); return; }
        case exprType::FunctionCall: { v.visit_FunctionCall((const FunctionCall_t &)x); return; }
        case exprType::DerivedTypeConstructor: { v.visit_DerivedTypeConstructor((const DerivedTypeConstructor_t &)x); return; }
        case exprType::ConstantArray: { v.visit_ConstantArray((const ConstantArray_t &)x); return; }
        case exprType::ImpliedDoLoop: { v.visit_ImpliedDoLoop((const ImpliedDoLoop_t &)x); return; }
        case exprType::ConstantInteger: { v.visit_ConstantInteger((const ConstantInteger_t &)x); return; }
        case exprType::ConstantReal: { v.visit_ConstantReal((const ConstantReal_t &)x); return; }
        case exprType::ConstantComplex: { v.visit_ConstantComplex((const ConstantComplex_t &)x); return; }
        case exprType::ConstantLogical: { v.visit_ConstantLogical((const ConstantLogical_t &)x); return; }
        case exprType::ConstantString: { v.visit_ConstantString((const ConstantString_t &)x); return; }
        case exprType::BOZ: { v.visit_BOZ((const BOZ_t &)x); return; }
        case exprType::Var: { v.visit_Var((const Var_t &)x); return; }
        case exprType::ArrayRef: { v.visit_ArrayRef((const ArrayRef_t &)x); return; }
        case exprType::DerivedRef: { v.visit_DerivedRef((const DerivedRef_t &)x); return; }
        case exprType::ImplicitCast: { v.visit_ImplicitCast((const ImplicitCast_t &)x); return; }
        case exprType::ExplicitCast: { v.visit_ExplicitCast((const ExplicitCast_t &)x); return; }
    }
}

template <class Visitor>
static void visit_ttype_t(const ttype_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == asrType::ttype)
    switch (x.type) {
        case ttypeType::Integer: { v.visit_Integer((const Integer_t &)x); return; }
        case ttypeType::Real: { v.visit_Real((const Real_t &)x); return; }
        case ttypeType::Complex: { v.visit_Complex((const Complex_t &)x); return; }
        case ttypeType::Character: { v.visit_Character((const Character_t &)x); return; }
        case ttypeType::Logical: { v.visit_Logical((const Logical_t &)x); return; }
        case ttypeType::Derived: { v.visit_Derived((const Derived_t &)x); return; }
        case ttypeType::Class: { v.visit_Class((const Class_t &)x); return; }
        case ttypeType::Pointer: { v.visit_Pointer((const Pointer_t &)x); return; }
    }
}

template <class Visitor>
static void visit_attribute_t(const attribute_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == asrType::attribute)
    switch (x.type) {
        case attributeType::Attribute: { v.visit_Attribute((const Attribute_t &)x); return; }
    }
}

template <class Visitor>
static void visit_tbind_t(const tbind_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == asrType::tbind)
    switch (x.type) {
        case tbindType::Bind: { v.visit_Bind((const Bind_t &)x); return; }
    }
}

template <class Visitor>
static void visit_case_stmt_t(const case_stmt_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == asrType::case_stmt)
    switch (x.type) {
        case case_stmtType::CaseStmt: { v.visit_CaseStmt((const CaseStmt_t &)x); return; }
        case case_stmtType::CaseStmt_Range: { v.visit_CaseStmt_Range((const CaseStmt_Range_t &)x); return; }
    }
}



template <class Visitor>
static void visit_asr_t(const asr_t &x, Visitor &v) {
    switch (x.type) {
        case asrType::unit: { v.visit_unit((const unit_t &)x); return; }
        case asrType::symbol: { v.visit_symbol((const symbol_t &)x); return; }
        case asrType::stmt: { v.visit_stmt((const stmt_t &)x); return; }
        case asrType::expr: { v.visit_expr((const expr_t &)x); return; }
        case asrType::ttype: { v.visit_ttype((const ttype_t &)x); return; }
        case asrType::attribute: { v.visit_attribute((const attribute_t &)x); return; }
        case asrType::tbind: { v.visit_tbind((const tbind_t &)x); return; }
        case asrType::case_stmt: { v.visit_case_stmt((const case_stmt_t &)x); return; }
    }
}



/******************************************************************************/
// Visitor base class

template <class Derived>
class BaseVisitor
{
private:
    Derived& self() { return static_cast<Derived&>(*this); }
public:
    void visit_asr(const asr_t &b) { visit_asr_t(b, self()); }
    void visit_unit(const unit_t &b) { visit_unit_t(b, self()); }
        void visit_TranslationUnit(const TranslationUnit_t & /* x */) { throw LFortran::LFortranException("visit_TranslationUnit() not implemented"); }
    void visit_symbol(const symbol_t &b) { visit_symbol_t(b, self()); }
        void visit_Program(const Program_t & /* x */) { throw LFortran::LFortranException("visit_Program() not implemented"); }
        void visit_Module(const Module_t & /* x */) { throw LFortran::LFortranException("visit_Module() not implemented"); }
        void visit_Subroutine(const Subroutine_t & /* x */) { throw LFortran::LFortranException("visit_Subroutine() not implemented"); }
        void visit_Function(const Function_t & /* x */) { throw LFortran::LFortranException("visit_Function() not implemented"); }
        void visit_GenericProcedure(const GenericProcedure_t & /* x */) { throw LFortran::LFortranException("visit_GenericProcedure() not implemented"); }
        void visit_CustomOperator(const CustomOperator_t & /* x */) { throw LFortran::LFortranException("visit_CustomOperator() not implemented"); }
        void visit_ExternalSymbol(const ExternalSymbol_t & /* x */) { throw LFortran::LFortranException("visit_ExternalSymbol() not implemented"); }
        void visit_DerivedType(const DerivedType_t & /* x */) { throw LFortran::LFortranException("visit_DerivedType() not implemented"); }
        void visit_Variable(const Variable_t & /* x */) { throw LFortran::LFortranException("visit_Variable() not implemented"); }
        void visit_ClassType(const ClassType_t & /* x */) { throw LFortran::LFortranException("visit_ClassType() not implemented"); }
        void visit_ClassProcedure(const ClassProcedure_t & /* x */) { throw LFortran::LFortranException("visit_ClassProcedure() not implemented"); }
    void visit_stmt(const stmt_t &b) { visit_stmt_t(b, self()); }
        void visit_Allocate(const Allocate_t & /* x */) { throw LFortran::LFortranException("visit_Allocate() not implemented"); }
        void visit_Assign(const Assign_t & /* x */) { throw LFortran::LFortranException("visit_Assign() not implemented"); }
        void visit_Assignment(const Assignment_t & /* x */) { throw LFortran::LFortranException("visit_Assignment() not implemented"); }
        void visit_Associate(const Associate_t & /* x */) { throw LFortran::LFortranException("visit_Associate() not implemented"); }
        void visit_Cycle(const Cycle_t & /* x */) { throw LFortran::LFortranException("visit_Cycle() not implemented"); }
        void visit_ExplicitDeallocate(const ExplicitDeallocate_t & /* x */) { throw LFortran::LFortranException("visit_ExplicitDeallocate() not implemented"); }
        void visit_ImplicitDeallocate(const ImplicitDeallocate_t & /* x */) { throw LFortran::LFortranException("visit_ImplicitDeallocate() not implemented"); }
        void visit_DoConcurrentLoop(const DoConcurrentLoop_t & /* x */) { throw LFortran::LFortranException("visit_DoConcurrentLoop() not implemented"); }
        void visit_DoLoop(const DoLoop_t & /* x */) { throw LFortran::LFortranException("visit_DoLoop() not implemented"); }
        void visit_ErrorStop(const ErrorStop_t & /* x */) { throw LFortran::LFortranException("visit_ErrorStop() not implemented"); }
        void visit_Exit(const Exit_t & /* x */) { throw LFortran::LFortranException("visit_Exit() not implemented"); }
        void visit_ForAllSingle(const ForAllSingle_t & /* x */) { throw LFortran::LFortranException("visit_ForAllSingle() not implemented"); }
        void visit_GoTo(const GoTo_t & /* x */) { throw LFortran::LFortranException("visit_GoTo() not implemented"); }
        void visit_GoToTarget(const GoToTarget_t & /* x */) { throw LFortran::LFortranException("visit_GoToTarget() not implemented"); }
        void visit_If(const If_t & /* x */) { throw LFortran::LFortranException("visit_If() not implemented"); }
        void visit_IfArithmetic(const IfArithmetic_t & /* x */) { throw LFortran::LFortranException("visit_IfArithmetic() not implemented"); }
        void visit_Print(const Print_t & /* x */) { throw LFortran::LFortranException("visit_Print() not implemented"); }
        void visit_Open(const Open_t & /* x */) { throw LFortran::LFortranException("visit_Open() not implemented"); }
        void visit_Close(const Close_t & /* x */) { throw LFortran::LFortranException("visit_Close() not implemented"); }
        void visit_Read(const Read_t & /* x */) { throw LFortran::LFortranException("visit_Read() not implemented"); }
        void visit_Write(const Write_t & /* x */) { throw LFortran::LFortranException("visit_Write() not implemented"); }
        void visit_Return(const Return_t & /* x */) { throw LFortran::LFortranException("visit_Return() not implemented"); }
        void visit_Select(const Select_t & /* x */) { throw LFortran::LFortranException("visit_Select() not implemented"); }
        void visit_Stop(const Stop_t & /* x */) { throw LFortran::LFortranException("visit_Stop() not implemented"); }
        void visit_SubroutineCall(const SubroutineCall_t & /* x */) { throw LFortran::LFortranException("visit_SubroutineCall() not implemented"); }
        void visit_Where(const Where_t & /* x */) { throw LFortran::LFortranException("visit_Where() not implemented"); }
        void visit_WhileLoop(const WhileLoop_t & /* x */) { throw LFortran::LFortranException("visit_WhileLoop() not implemented"); }
    void visit_expr(const expr_t &b) { visit_expr_t(b, self()); }
        void visit_BoolOp(const BoolOp_t & /* x */) { throw LFortran::LFortranException("visit_BoolOp() not implemented"); }
        void visit_BinOp(const BinOp_t & /* x */) { throw LFortran::LFortranException("visit_BinOp() not implemented"); }
        void visit_StrOp(const StrOp_t & /* x */) { throw LFortran::LFortranException("visit_StrOp() not implemented"); }
        void visit_UnaryOp(const UnaryOp_t & /* x */) { throw LFortran::LFortranException("visit_UnaryOp() not implemented"); }
        void visit_ComplexConstructor(const ComplexConstructor_t & /* x */) { throw LFortran::LFortranException("visit_ComplexConstructor() not implemented"); }
        void visit_Compare(const Compare_t & /* x */) { throw LFortran::LFortranException("visit_Compare() not implemented"); }
        void visit_FunctionCall(const FunctionCall_t & /* x */) { throw LFortran::LFortranException("visit_FunctionCall() not implemented"); }
        void visit_DerivedTypeConstructor(const DerivedTypeConstructor_t & /* x */) { throw LFortran::LFortranException("visit_DerivedTypeConstructor() not implemented"); }
        void visit_ConstantArray(const ConstantArray_t & /* x */) { throw LFortran::LFortranException("visit_ConstantArray() not implemented"); }
        void visit_ImpliedDoLoop(const ImpliedDoLoop_t & /* x */) { throw LFortran::LFortranException("visit_ImpliedDoLoop() not implemented"); }
        void visit_ConstantInteger(const ConstantInteger_t & /* x */) { throw LFortran::LFortranException("visit_ConstantInteger() not implemented"); }
        void visit_ConstantReal(const ConstantReal_t & /* x */) { throw LFortran::LFortranException("visit_ConstantReal() not implemented"); }
        void visit_ConstantComplex(const ConstantComplex_t & /* x */) { throw LFortran::LFortranException("visit_ConstantComplex() not implemented"); }
        void visit_ConstantLogical(const ConstantLogical_t & /* x */) { throw LFortran::LFortranException("visit_ConstantLogical() not implemented"); }
        void visit_ConstantString(const ConstantString_t & /* x */) { throw LFortran::LFortranException("visit_ConstantString() not implemented"); }
        void visit_BOZ(const BOZ_t & /* x */) { throw LFortran::LFortranException("visit_BOZ() not implemented"); }
        void visit_Var(const Var_t & /* x */) { throw LFortran::LFortranException("visit_Var() not implemented"); }
        void visit_ArrayRef(const ArrayRef_t & /* x */) { throw LFortran::LFortranException("visit_ArrayRef() not implemented"); }
        void visit_DerivedRef(const DerivedRef_t & /* x */) { throw LFortran::LFortranException("visit_DerivedRef() not implemented"); }
        void visit_ImplicitCast(const ImplicitCast_t & /* x */) { throw LFortran::LFortranException("visit_ImplicitCast() not implemented"); }
        void visit_ExplicitCast(const ExplicitCast_t & /* x */) { throw LFortran::LFortranException("visit_ExplicitCast() not implemented"); }
    void visit_ttype(const ttype_t &b) { visit_ttype_t(b, self()); }
        void visit_Integer(const Integer_t & /* x */) { throw LFortran::LFortranException("visit_Integer() not implemented"); }
        void visit_Real(const Real_t & /* x */) { throw LFortran::LFortranException("visit_Real() not implemented"); }
        void visit_Complex(const Complex_t & /* x */) { throw LFortran::LFortranException("visit_Complex() not implemented"); }
        void visit_Character(const Character_t & /* x */) { throw LFortran::LFortranException("visit_Character() not implemented"); }
        void visit_Logical(const Logical_t & /* x */) { throw LFortran::LFortranException("visit_Logical() not implemented"); }
        void visit_Derived(const Derived_t & /* x */) { throw LFortran::LFortranException("visit_Derived() not implemented"); }
        void visit_Class(const Class_t & /* x */) { throw LFortran::LFortranException("visit_Class() not implemented"); }
        void visit_Pointer(const Pointer_t & /* x */) { throw LFortran::LFortranException("visit_Pointer() not implemented"); }
    void visit_attribute(const attribute_t &b) { visit_attribute_t(b, self()); }
        void visit_Attribute(const Attribute_t & /* x */) { throw LFortran::LFortranException("visit_Attribute() not implemented"); }
    void visit_tbind(const tbind_t &b) { visit_tbind_t(b, self()); }
        void visit_Bind(const Bind_t & /* x */) { throw LFortran::LFortranException("visit_Bind() not implemented"); }
    void visit_case_stmt(const case_stmt_t &b) { visit_case_stmt_t(b, self()); }
        void visit_CaseStmt(const CaseStmt_t & /* x */) { throw LFortran::LFortranException("visit_CaseStmt() not implemented"); }
        void visit_CaseStmt_Range(const CaseStmt_Range_t & /* x */) { throw LFortran::LFortranException("visit_CaseStmt_Range() not implemented"); }
};


/******************************************************************************/
// Walk Visitor base class

template <class Derived>
class BaseWalkVisitor : public BaseVisitor<Derived>
{
private:
    Derived& self() { return static_cast<Derived&>(*this); }
public:
    void visit_TranslationUnit(const TranslationUnit_t &x) {
        for (auto &a : x.m_global_scope->scope) {
            this->visit_symbol(*a.second);
        }
    }
    void visit_Program(const Program_t &x) {
        for (auto &a : x.m_symtab->scope) {
            this->visit_symbol(*a.second);
        }
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_Module(const Module_t &x) {
        for (auto &a : x.m_symtab->scope) {
            this->visit_symbol(*a.second);
        }
    }
    void visit_Subroutine(const Subroutine_t &x) {
        for (auto &a : x.m_symtab->scope) {
            this->visit_symbol(*a.second);
        }
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_Function(const Function_t &x) {
        for (auto &a : x.m_symtab->scope) {
            this->visit_symbol(*a.second);
        }
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        self().visit_expr(*x.m_return_var);
    }
    void visit_GenericProcedure(const GenericProcedure_t &x) {
        for (size_t i=0; i<x.n_procs; i++) {
        }
    }
    void visit_CustomOperator(const CustomOperator_t &x) {
        for (size_t i=0; i<x.n_procs; i++) {
        }
    }
    void visit_ExternalSymbol(const ExternalSymbol_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_DerivedType(const DerivedType_t &x) {
        for (auto &a : x.m_symtab->scope) {
            this->visit_symbol(*a.second);
        }
    }
    void visit_Variable(const Variable_t &x) {
        if (x.m_symbolic_value)
            self().visit_expr(*x.m_symbolic_value);
        if (x.m_value)
            self().visit_expr(*x.m_value);
        self().visit_ttype(*x.m_type);
    }
    void visit_ClassType(const ClassType_t &x) {
        for (auto &a : x.m_symtab->scope) {
            this->visit_symbol(*a.second);
        }
    }
    void visit_ClassProcedure(const ClassProcedure_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Allocate(const Allocate_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_alloc_arg(x.m_args[i]);
        }
        if (x.m_stat)
            self().visit_expr(*x.m_stat);
    }
    void visit_Assign(const Assign_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Assignment(const Assignment_t &x) {
        self().visit_expr(*x.m_target);
        self().visit_expr(*x.m_value);
        if (x.m_overloaded)
            self().visit_stmt(*x.m_overloaded);
    }
    void visit_Associate(const Associate_t &x) {
        self().visit_expr(*x.m_target);
        self().visit_expr(*x.m_value);
    }
    void visit_Cycle(const Cycle_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ExplicitDeallocate(const ExplicitDeallocate_t &x) {
        for (size_t i=0; i<x.n_vars; i++) {
        }
    }
    void visit_ImplicitDeallocate(const ImplicitDeallocate_t &x) {
        for (size_t i=0; i<x.n_vars; i++) {
        }
    }
    void visit_DoConcurrentLoop(const DoConcurrentLoop_t &x) {
        self().visit_do_loop_head(x.m_head);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_DoLoop(const DoLoop_t &x) {
        self().visit_do_loop_head(x.m_head);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_ErrorStop(const ErrorStop_t &x) {
        if (x.m_code)
            self().visit_expr(*x.m_code);
    }
    void visit_Exit(const Exit_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ForAllSingle(const ForAllSingle_t &x) {
        self().visit_do_loop_head(x.m_head);
        self().visit_stmt(*x.m_assign_stmt);
    }
    void visit_GoTo(const GoTo_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_GoToTarget(const GoToTarget_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_If(const If_t &x) {
        self().visit_expr(*x.m_test);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        for (size_t i=0; i<x.n_orelse; i++) {
            self().visit_stmt(*x.m_orelse[i]);
        }
    }
    void visit_IfArithmetic(const IfArithmetic_t &x) {
        self().visit_expr(*x.m_test);
    }
    void visit_Print(const Print_t &x) {
        if (x.m_fmt)
            self().visit_expr(*x.m_fmt);
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
        }
    }
    void visit_Open(const Open_t &x) {
        if (x.m_newunit)
            self().visit_expr(*x.m_newunit);
        if (x.m_filename)
            self().visit_expr(*x.m_filename);
        if (x.m_status)
            self().visit_expr(*x.m_status);
    }
    void visit_Close(const Close_t &x) {
        if (x.m_unit)
            self().visit_expr(*x.m_unit);
        if (x.m_iostat)
            self().visit_expr(*x.m_iostat);
        if (x.m_iomsg)
            self().visit_expr(*x.m_iomsg);
        if (x.m_err)
            self().visit_expr(*x.m_err);
        if (x.m_status)
            self().visit_expr(*x.m_status);
    }
    void visit_Read(const Read_t &x) {
        if (x.m_unit)
            self().visit_expr(*x.m_unit);
        if (x.m_fmt)
            self().visit_expr(*x.m_fmt);
        if (x.m_iomsg)
            self().visit_expr(*x.m_iomsg);
        if (x.m_iostat)
            self().visit_expr(*x.m_iostat);
        if (x.m_id)
            self().visit_expr(*x.m_id);
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
        }
    }
    void visit_Write(const Write_t &x) {
        if (x.m_unit)
            self().visit_expr(*x.m_unit);
        if (x.m_fmt)
            self().visit_expr(*x.m_fmt);
        if (x.m_iomsg)
            self().visit_expr(*x.m_iomsg);
        if (x.m_iostat)
            self().visit_expr(*x.m_iostat);
        if (x.m_id)
            self().visit_expr(*x.m_id);
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
        }
    }
    void visit_Return(const Return_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Select(const Select_t &x) {
        self().visit_expr(*x.m_test);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_case_stmt(*x.m_body[i]);
        }
        for (size_t i=0; i<x.n_default; i++) {
            self().visit_stmt(*x.m_default[i]);
        }
    }
    void visit_Stop(const Stop_t &x) {
        if (x.m_code)
            self().visit_expr(*x.m_code);
    }
    void visit_SubroutineCall(const SubroutineCall_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        if (x.m_dt)
            self().visit_expr(*x.m_dt);
    }
    void visit_Where(const Where_t &x) {
        self().visit_expr(*x.m_test);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        for (size_t i=0; i<x.n_orelse; i++) {
            self().visit_stmt(*x.m_orelse[i]);
        }
    }
    void visit_WhileLoop(const WhileLoop_t &x) {
        self().visit_expr(*x.m_test);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_BoolOp(const BoolOp_t &x) {
        self().visit_expr(*x.m_left);
        self().visit_expr(*x.m_right);
        self().visit_ttype(*x.m_type);
        if (x.m_value)
            self().visit_expr(*x.m_value);
    }
    void visit_BinOp(const BinOp_t &x) {
        self().visit_expr(*x.m_left);
        self().visit_expr(*x.m_right);
        self().visit_ttype(*x.m_type);
        if (x.m_value)
            self().visit_expr(*x.m_value);
        if (x.m_overloaded)
            self().visit_expr(*x.m_overloaded);
    }
    void visit_StrOp(const StrOp_t &x) {
        self().visit_expr(*x.m_left);
        self().visit_expr(*x.m_right);
        self().visit_ttype(*x.m_type);
        if (x.m_value)
            self().visit_expr(*x.m_value);
    }
    void visit_UnaryOp(const UnaryOp_t &x) {
        self().visit_expr(*x.m_operand);
        self().visit_ttype(*x.m_type);
        if (x.m_value)
            self().visit_expr(*x.m_value);
    }
    void visit_ComplexConstructor(const ComplexConstructor_t &x) {
        self().visit_expr(*x.m_re);
        self().visit_expr(*x.m_im);
        self().visit_ttype(*x.m_type);
        if (x.m_value)
            self().visit_expr(*x.m_value);
    }
    void visit_Compare(const Compare_t &x) {
        self().visit_expr(*x.m_left);
        self().visit_expr(*x.m_right);
        self().visit_ttype(*x.m_type);
        if (x.m_value)
            self().visit_expr(*x.m_value);
        if (x.m_overloaded)
            self().visit_expr(*x.m_overloaded);
    }
    void visit_FunctionCall(const FunctionCall_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        for (size_t i=0; i<x.n_keywords; i++) {
            self().visit_keyword(x.m_keywords[i]);
        }
        self().visit_ttype(*x.m_type);
        if (x.m_value)
            self().visit_expr(*x.m_value);
        if (x.m_dt)
            self().visit_expr(*x.m_dt);
    }
    void visit_DerivedTypeConstructor(const DerivedTypeConstructor_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        self().visit_ttype(*x.m_type);
    }
    void visit_ConstantArray(const ConstantArray_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        self().visit_ttype(*x.m_type);
    }
    void visit_ImpliedDoLoop(const ImpliedDoLoop_t &x) {
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
        }
        self().visit_expr(*x.m_var);
        self().visit_expr(*x.m_start);
        self().visit_expr(*x.m_end);
        if (x.m_increment)
            self().visit_expr(*x.m_increment);
        self().visit_ttype(*x.m_type);
        if (x.m_value)
            self().visit_expr(*x.m_value);
    }
    void visit_ConstantInteger(const ConstantInteger_t &x) {
        self().visit_ttype(*x.m_type);
    }
    void visit_ConstantReal(const ConstantReal_t &x) {
        self().visit_ttype(*x.m_type);
    }
    void visit_ConstantComplex(const ConstantComplex_t &x) {
        self().visit_ttype(*x.m_type);
    }
    void visit_ConstantLogical(const ConstantLogical_t &x) {
        self().visit_ttype(*x.m_type);
    }
    void visit_ConstantString(const ConstantString_t &x) {
        self().visit_ttype(*x.m_type);
    }
    void visit_BOZ(const BOZ_t &x) {
        if (x.m_type)
            self().visit_ttype(*x.m_type);
    }
    void visit_Var(const Var_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ArrayRef(const ArrayRef_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_array_index(x.m_args[i]);
        }
        self().visit_ttype(*x.m_type);
        if (x.m_value)
            self().visit_expr(*x.m_value);
    }
    void visit_DerivedRef(const DerivedRef_t &x) {
        self().visit_expr(*x.m_v);
        self().visit_ttype(*x.m_type);
        if (x.m_value)
            self().visit_expr(*x.m_value);
    }
    void visit_ImplicitCast(const ImplicitCast_t &x) {
        self().visit_expr(*x.m_arg);
        self().visit_ttype(*x.m_type);
        if (x.m_value)
            self().visit_expr(*x.m_value);
    }
    void visit_ExplicitCast(const ExplicitCast_t &x) {
        self().visit_expr(*x.m_arg);
        self().visit_ttype(*x.m_type);
        if (x.m_value)
            self().visit_expr(*x.m_value);
    }
    void visit_Integer(const Integer_t &x) {
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
        }
    }
    void visit_Real(const Real_t &x) {
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
        }
    }
    void visit_Complex(const Complex_t &x) {
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
        }
    }
    void visit_Character(const Character_t &x) {
        if (x.m_len_expr)
            self().visit_expr(*x.m_len_expr);
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
        }
    }
    void visit_Logical(const Logical_t &x) {
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
        }
    }
    void visit_Derived(const Derived_t &x) {
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
        }
    }
    void visit_Class(const Class_t &x) {
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
        }
    }
    void visit_Pointer(const Pointer_t &x) {
        self().visit_ttype(*x.m_type);
    }
    void visit_dimension(const dimension_t &x) {
        if (x.m_start)
            self().visit_expr(*x.m_start);
        if (x.m_end)
            self().visit_expr(*x.m_end);
    }
    void visit_alloc_arg(const alloc_arg_t &x) {
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
        }
    }
    void visit_Attribute(const Attribute_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_attribute_arg(x.m_args[i]);
        }
    }
    void visit_attribute_arg(const attribute_arg_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_arg(const arg_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_keyword(const keyword_t &x) {
        self().visit_expr(*x.m_value);
    }
    void visit_Bind(const Bind_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_array_index(const array_index_t &x) {
        if (x.m_left)
            self().visit_expr(*x.m_left);
        if (x.m_right)
            self().visit_expr(*x.m_right);
        if (x.m_step)
            self().visit_expr(*x.m_step);
    }
    void visit_do_loop_head(const do_loop_head_t &x) {
        self().visit_expr(*x.m_v);
        self().visit_expr(*x.m_start);
        self().visit_expr(*x.m_end);
        if (x.m_increment)
            self().visit_expr(*x.m_increment);
    }
    void visit_CaseStmt(const CaseStmt_t &x) {
        for (size_t i=0; i<x.n_test; i++) {
            self().visit_expr(*x.m_test[i]);
        }
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_CaseStmt_Range(const CaseStmt_Range_t &x) {
        if (x.m_start)
            self().visit_expr(*x.m_start);
        if (x.m_end)
            self().visit_expr(*x.m_end);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
};


/******************************************************************************/
// Pickle Visitor base class

template <class Derived>
class PickleBaseVisitor : public BaseVisitor<Derived>
{
private:
    Derived& self() { return static_cast<Derived&>(*this); }
public:
    std::string s, indtd;
    bool use_colors;
    bool indent, start_line = true;
    int indent_level = 0, indent_spaces = 3, lvl = 0;
    int tmp = 0, tmp1 = 0, tmp2 = 2;
    int curly[2000], round[2000];
public:
    PickleBaseVisitor() : use_colors(false), indent(false) { s.reserve(100000); }
    void inc_indent() {
        indent_level++;
        indtd = std::string(indent_level*indent_spaces, ' ');
    }
    void dec_indent() {
        indent_level--;
        LFORTRAN_ASSERT(indent_level >= 0);
        indtd = std::string(indent_level*indent_spaces, ' ');
    }
    void visit_TranslationUnit(const TranslationUnit_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("TranslationUnit");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) {
            s.append("\n"+indtd);
            round[++tmp1] = indent_level;
            inc_indent();
        }
        s.append("(");
        if (use_colors) {
            s.append(color(fg::yellow));
        }
        s.append("SymbolTable");
        if (use_colors) {
            s.append(color(fg::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_global_scope->get_counter());
        s.append(" ");
        if(indent) {
            s.append("\n"+indtd);
            curly[++tmp] = indent_level;
            tmp2 = 1;
            inc_indent();
        }
        s.append("{");
        {
            size_t i = 0;
            for (auto &a : x.m_global_scope->scope) {
        if(indent) {
            s.append("\n"+indtd);
            inc_indent();
        }
              s.append(a.first + ": ");
                this->visit_symbol(*a.second);
                if (i < x.m_global_scope->scope.size()-1) { 
                    s.append(", ");
                    if(indent) {
                            for(int times = 0; times < tmp2; times++)
                             dec_indent();
                     }
                }
                i++;
            }
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - curly[tmp] ); times++)
                dec_indent();
            curly[tmp] = 0; if(tmp > 1) tmp--;
            tmp2++;
            s.append("\n"+indtd);
        }
        s.append("})");
        if(indent) dec_indent();
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append("[");
        for (size_t i=0; i<x.n_items; i++) {
            self().visit_asr(*x.m_items[i]);
            if (i < x.n_items-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Program(const Program_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Program");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) {
            s.append("\n"+indtd);
            round[++tmp1] = indent_level;
            inc_indent();
        }
        s.append("(");
        if (use_colors) {
            s.append(color(fg::yellow));
        }
        s.append("SymbolTable");
        if (use_colors) {
            s.append(color(fg::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_symtab->get_counter());
        s.append(" ");
        if(indent) {
            s.append("\n"+indtd);
            curly[++tmp] = indent_level;
            tmp2 = 1;
            inc_indent();
        }
        s.append("{");
        {
            size_t i = 0;
            for (auto &a : x.m_symtab->scope) {
        if(indent) {
            s.append("\n"+indtd);
            inc_indent();
        }
              s.append(a.first + ": ");
                this->visit_symbol(*a.second);
                if (i < x.m_symtab->scope.size()-1) { 
                    s.append(", ");
                    if(indent) {
                            for(int times = 0; times < tmp2; times++)
                             dec_indent();
                     }
                }
                i++;
            }
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - curly[tmp] ); times++)
                dec_indent();
            curly[tmp] = 0; if(tmp > 1) tmp--;
            tmp2++;
            s.append("\n"+indtd);
        }
        s.append("})");
        if(indent) dec_indent();
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_dependencies; i++) {
            s.append(x.m_dependencies[i]);
            if (i < x.n_dependencies-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Module(const Module_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Module");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) {
            s.append("\n"+indtd);
            round[++tmp1] = indent_level;
            inc_indent();
        }
        s.append("(");
        if (use_colors) {
            s.append(color(fg::yellow));
        }
        s.append("SymbolTable");
        if (use_colors) {
            s.append(color(fg::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_symtab->get_counter());
        s.append(" ");
        if(indent) {
            s.append("\n"+indtd);
            curly[++tmp] = indent_level;
            tmp2 = 1;
            inc_indent();
        }
        s.append("{");
        {
            size_t i = 0;
            for (auto &a : x.m_symtab->scope) {
        if(indent) {
            s.append("\n"+indtd);
            inc_indent();
        }
              s.append(a.first + ": ");
                this->visit_symbol(*a.second);
                if (i < x.m_symtab->scope.size()-1) { 
                    s.append(", ");
                    if(indent) {
                            for(int times = 0; times < tmp2; times++)
                             dec_indent();
                     }
                }
                i++;
            }
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - curly[tmp] ); times++)
                dec_indent();
            curly[tmp] = 0; if(tmp > 1) tmp--;
            tmp2++;
            s.append("\n"+indtd);
        }
        s.append("})");
        if(indent) dec_indent();
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_dependencies; i++) {
            s.append(x.m_dependencies[i]);
            if (i < x.n_dependencies-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_loaded_from_mod) {
            s.append(".true.");
        } else {
            s.append(".false.");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Subroutine(const Subroutine_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Subroutine");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) {
            s.append("\n"+indtd);
            round[++tmp1] = indent_level;
            inc_indent();
        }
        s.append("(");
        if (use_colors) {
            s.append(color(fg::yellow));
        }
        s.append("SymbolTable");
        if (use_colors) {
            s.append(color(fg::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_symtab->get_counter());
        s.append(" ");
        if(indent) {
            s.append("\n"+indtd);
            curly[++tmp] = indent_level;
            tmp2 = 1;
            inc_indent();
        }
        s.append("{");
        {
            size_t i = 0;
            for (auto &a : x.m_symtab->scope) {
        if(indent) {
            s.append("\n"+indtd);
            inc_indent();
        }
              s.append(a.first + ": ");
                this->visit_symbol(*a.second);
                if (i < x.m_symtab->scope.size()-1) { 
                    s.append(", ");
                    if(indent) {
                            for(int times = 0; times < tmp2; times++)
                             dec_indent();
                     }
                }
                i++;
            }
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - curly[tmp] ); times++)
                dec_indent();
            curly[tmp] = 0; if(tmp > 1) tmp--;
            tmp2++;
            s.append("\n"+indtd);
        }
        s.append("})");
        if(indent) dec_indent();
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        visit_abiType(x.m_abi);
        s.append(" ");
        visit_accessType(x.m_access);
        s.append(" ");
        visit_deftypeType(x.m_deftype);
        s.append(" ");
        if (x.m_bindc_name) {
            s.append("\"" + std::string(x.m_bindc_name) + "\"");
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_pure) {
            s.append(".true.");
        } else {
            s.append(".false.");
        }
        s.append(" ");
        if (x.m_module) {
            s.append(".true.");
        } else {
            s.append(".false.");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Function(const Function_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Function");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) {
            s.append("\n"+indtd);
            round[++tmp1] = indent_level;
            inc_indent();
        }
        s.append("(");
        if (use_colors) {
            s.append(color(fg::yellow));
        }
        s.append("SymbolTable");
        if (use_colors) {
            s.append(color(fg::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_symtab->get_counter());
        s.append(" ");
        if(indent) {
            s.append("\n"+indtd);
            curly[++tmp] = indent_level;
            tmp2 = 1;
            inc_indent();
        }
        s.append("{");
        {
            size_t i = 0;
            for (auto &a : x.m_symtab->scope) {
        if(indent) {
            s.append("\n"+indtd);
            inc_indent();
        }
              s.append(a.first + ": ");
                this->visit_symbol(*a.second);
                if (i < x.m_symtab->scope.size()-1) { 
                    s.append(", ");
                    if(indent) {
                            for(int times = 0; times < tmp2; times++)
                             dec_indent();
                     }
                }
                i++;
            }
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - curly[tmp] ); times++)
                dec_indent();
            curly[tmp] = 0; if(tmp > 1) tmp--;
            tmp2++;
            s.append("\n"+indtd);
        }
        s.append("})");
        if(indent) dec_indent();
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        self().visit_expr(*x.m_return_var);
        s.append(" ");
        visit_abiType(x.m_abi);
        s.append(" ");
        visit_accessType(x.m_access);
        s.append(" ");
        visit_deftypeType(x.m_deftype);
        s.append(" ");
        if (x.m_bindc_name) {
            s.append("\"" + std::string(x.m_bindc_name) + "\"");
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_GenericProcedure(const GenericProcedure_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("GenericProcedure");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_parent_symtab->get_counter());
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_procs; i++) {
            self().visit_symbol(*x.m_procs[i]);
            if (i < x.n_procs-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        visit_accessType(x.m_access);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_CustomOperator(const CustomOperator_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("CustomOperator");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_parent_symtab->get_counter());
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_procs; i++) {
            self().visit_symbol(*x.m_procs[i]);
            if (i < x.n_procs-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        visit_accessType(x.m_access);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ExternalSymbol(const ExternalSymbol_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ExternalSymbol");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_parent_symtab->get_counter());
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        self().visit_symbol(*x.m_external);
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_module_name);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_scope_names; i++) {
            s.append(x.m_scope_names[i]);
            if (i < x.n_scope_names-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_original_name);
        s.append(" ");
        visit_accessType(x.m_access);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_DerivedType(const DerivedType_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("DerivedType");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) {
            s.append("\n"+indtd);
            round[++tmp1] = indent_level;
            inc_indent();
        }
        s.append("(");
        if (use_colors) {
            s.append(color(fg::yellow));
        }
        s.append("SymbolTable");
        if (use_colors) {
            s.append(color(fg::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_symtab->get_counter());
        s.append(" ");
        if(indent) {
            s.append("\n"+indtd);
            curly[++tmp] = indent_level;
            tmp2 = 1;
            inc_indent();
        }
        s.append("{");
        {
            size_t i = 0;
            for (auto &a : x.m_symtab->scope) {
        if(indent) {
            s.append("\n"+indtd);
            inc_indent();
        }
              s.append(a.first + ": ");
                this->visit_symbol(*a.second);
                if (i < x.m_symtab->scope.size()-1) { 
                    s.append(", ");
                    if(indent) {
                            for(int times = 0; times < tmp2; times++)
                             dec_indent();
                     }
                }
                i++;
            }
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - curly[tmp] ); times++)
                dec_indent();
            curly[tmp] = 0; if(tmp > 1) tmp--;
            tmp2++;
            s.append("\n"+indtd);
        }
        s.append("})");
        if(indent) dec_indent();
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_members; i++) {
            s.append(x.m_members[i]);
            if (i < x.n_members-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        visit_abiType(x.m_abi);
        s.append(" ");
        visit_accessType(x.m_access);
        s.append(" ");
        if (x.m_parent) {
            self().visit_symbol(*x.m_parent);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Variable(const Variable_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Variable");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_parent_symtab->get_counter());
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        visit_intentType(x.m_intent);
        s.append(" ");
        if (x.m_symbolic_value) {
            self().visit_expr(*x.m_symbolic_value);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_value) {
            self().visit_expr(*x.m_value);
        } else {
            s.append("()");
        }
        s.append(" ");
        visit_storage_typeType(x.m_storage);
        s.append(" ");
        self().visit_ttype(*x.m_type);
        s.append(" ");
        visit_abiType(x.m_abi);
        s.append(" ");
        visit_accessType(x.m_access);
        s.append(" ");
        visit_presenceType(x.m_presence);
        s.append(" ");
        if (x.m_value_attr) {
            s.append(".true.");
        } else {
            s.append(".false.");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ClassType(const ClassType_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ClassType");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) {
            s.append("\n"+indtd);
            round[++tmp1] = indent_level;
            inc_indent();
        }
        s.append("(");
        if (use_colors) {
            s.append(color(fg::yellow));
        }
        s.append("SymbolTable");
        if (use_colors) {
            s.append(color(fg::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_symtab->get_counter());
        s.append(" ");
        if(indent) {
            s.append("\n"+indtd);
            curly[++tmp] = indent_level;
            tmp2 = 1;
            inc_indent();
        }
        s.append("{");
        {
            size_t i = 0;
            for (auto &a : x.m_symtab->scope) {
        if(indent) {
            s.append("\n"+indtd);
            inc_indent();
        }
              s.append(a.first + ": ");
                this->visit_symbol(*a.second);
                if (i < x.m_symtab->scope.size()-1) { 
                    s.append(", ");
                    if(indent) {
                            for(int times = 0; times < tmp2; times++)
                             dec_indent();
                     }
                }
                i++;
            }
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - curly[tmp] ); times++)
                dec_indent();
            curly[tmp] = 0; if(tmp > 1) tmp--;
            tmp2++;
            s.append("\n"+indtd);
        }
        s.append("})");
        if(indent) dec_indent();
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        visit_abiType(x.m_abi);
        s.append(" ");
        visit_accessType(x.m_access);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ClassProcedure(const ClassProcedure_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ClassProcedure");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_parent_symtab->get_counter());
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_proc_name);
        s.append(" ");
        self().visit_symbol(*x.m_proc);
        s.append(" ");
        visit_abiType(x.m_abi);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_storage_typeType(const storage_typeType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (storage_typeType::Default) : {
                if(indent) s.append("\n"+indtd);
                s.append("Default");
             break; }
            case (storage_typeType::Save) : {
                if(indent) s.append("\n"+indtd);
                s.append("Save");
             break; }
            case (storage_typeType::Parameter) : {
                if(indent) s.append("\n"+indtd);
                s.append("Parameter");
             break; }
            case (storage_typeType::Allocatable) : {
                if(indent) s.append("\n"+indtd);
                s.append("Allocatable");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_accessType(const accessType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (accessType::Public) : {
                if(indent) s.append("\n"+indtd);
                s.append("Public");
             break; }
            case (accessType::Private) : {
                if(indent) s.append("\n"+indtd);
                s.append("Private");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_intentType(const intentType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (intentType::Local) : {
                if(indent) s.append("\n"+indtd);
                s.append("Local");
             break; }
            case (intentType::In) : {
                if(indent) s.append("\n"+indtd);
                s.append("In");
             break; }
            case (intentType::Out) : {
                if(indent) s.append("\n"+indtd);
                s.append("Out");
             break; }
            case (intentType::InOut) : {
                if(indent) s.append("\n"+indtd);
                s.append("InOut");
             break; }
            case (intentType::ReturnVar) : {
                if(indent) s.append("\n"+indtd);
                s.append("ReturnVar");
             break; }
            case (intentType::Unspecified) : {
                if(indent) s.append("\n"+indtd);
                s.append("Unspecified");
             break; }
            case (intentType::AssociateBlock) : {
                if(indent) s.append("\n"+indtd);
                s.append("AssociateBlock");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_deftypeType(const deftypeType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (deftypeType::Implementation) : {
                if(indent) s.append("\n"+indtd);
                s.append("Implementation");
             break; }
            case (deftypeType::Interface) : {
                if(indent) s.append("\n"+indtd);
                s.append("Interface");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_presenceType(const presenceType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (presenceType::Required) : {
                if(indent) s.append("\n"+indtd);
                s.append("Required");
             break; }
            case (presenceType::Optional) : {
                if(indent) s.append("\n"+indtd);
                s.append("Optional");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_abiType(const abiType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (abiType::Source) : {
                if(indent) s.append("\n"+indtd);
                s.append("Source");
             break; }
            case (abiType::LFortranModule) : {
                if(indent) s.append("\n"+indtd);
                s.append("LFortranModule");
             break; }
            case (abiType::GFortranModule) : {
                if(indent) s.append("\n"+indtd);
                s.append("GFortranModule");
             break; }
            case (abiType::BindC) : {
                if(indent) s.append("\n"+indtd);
                s.append("BindC");
             break; }
            case (abiType::Interactive) : {
                if(indent) s.append("\n"+indtd);
                s.append("Interactive");
             break; }
            case (abiType::Intrinsic) : {
                if(indent) s.append("\n"+indtd);
                s.append("Intrinsic");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_Allocate(const Allocate_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Allocate");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_alloc_arg(x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_stat) {
            self().visit_expr(*x.m_stat);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Assign(const Assign_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Assign");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_variable);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Assignment(const Assignment_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("=");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_target);
        s.append(" ");
        self().visit_expr(*x.m_value);
        s.append(" ");
        if (x.m_overloaded) {
            self().visit_stmt(*x.m_overloaded);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Associate(const Associate_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("=>");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_target);
        s.append(" ");
        self().visit_expr(*x.m_value);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Cycle(const Cycle_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Cycle");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ExplicitDeallocate(const ExplicitDeallocate_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ExplicitDeallocate");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_vars; i++) {
            self().visit_symbol(*x.m_vars[i]);
            if (i < x.n_vars-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ImplicitDeallocate(const ImplicitDeallocate_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ImplicitDeallocate");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_vars; i++) {
            self().visit_symbol(*x.m_vars[i]);
            if (i < x.n_vars-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_DoConcurrentLoop(const DoConcurrentLoop_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("DoConcurrentLoop");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_do_loop_head(x.m_head);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_DoLoop(const DoLoop_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("DoLoop");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_do_loop_head(x.m_head);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ErrorStop(const ErrorStop_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ErrorStop");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_code) {
            self().visit_expr(*x.m_code);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Exit(const Exit_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Exit");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ForAllSingle(const ForAllSingle_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ForAllSingle");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_do_loop_head(x.m_head);
        s.append(" ");
        self().visit_stmt(*x.m_assign_stmt);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_GoTo(const GoTo_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("GoTo");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_target_id));
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_GoToTarget(const GoToTarget_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("GoToTarget");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_id));
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_If(const If_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("If");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_test);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_orelse; i++) {
            self().visit_stmt(*x.m_orelse[i]);
            if (i < x.n_orelse-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_IfArithmetic(const IfArithmetic_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("IfArithmetic");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_test);
        s.append(" ");
        s.append(std::to_string(x.m_lt_label));
        s.append(" ");
        s.append(std::to_string(x.m_eq_label));
        s.append(" ");
        s.append(std::to_string(x.m_gt_label));
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Print(const Print_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Print");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_fmt) {
            self().visit_expr(*x.m_fmt);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
            if (i < x.n_values-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Open(const Open_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Open");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_newunit) {
            self().visit_expr(*x.m_newunit);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_filename) {
            self().visit_expr(*x.m_filename);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_status) {
            self().visit_expr(*x.m_status);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Close(const Close_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Close");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_unit) {
            self().visit_expr(*x.m_unit);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_iostat) {
            self().visit_expr(*x.m_iostat);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_iomsg) {
            self().visit_expr(*x.m_iomsg);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_err) {
            self().visit_expr(*x.m_err);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_status) {
            self().visit_expr(*x.m_status);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Read(const Read_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Read");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_unit) {
            self().visit_expr(*x.m_unit);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_fmt) {
            self().visit_expr(*x.m_fmt);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_iomsg) {
            self().visit_expr(*x.m_iomsg);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_iostat) {
            self().visit_expr(*x.m_iostat);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_id) {
            self().visit_expr(*x.m_id);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
            if (i < x.n_values-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Write(const Write_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Write");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_unit) {
            self().visit_expr(*x.m_unit);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_fmt) {
            self().visit_expr(*x.m_fmt);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_iomsg) {
            self().visit_expr(*x.m_iomsg);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_iostat) {
            self().visit_expr(*x.m_iostat);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_id) {
            self().visit_expr(*x.m_id);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
            if (i < x.n_values-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Return(const Return_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Return");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Select(const Select_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Select");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_test);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_case_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_default; i++) {
            self().visit_stmt(*x.m_default[i]);
            if (i < x.n_default-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Stop(const Stop_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Stop");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_code) {
            self().visit_expr(*x.m_code);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_SubroutineCall(const SubroutineCall_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("SubroutineCall");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_symbol(*x.m_name);
        s.append(" ");
        if (x.m_original_name) {
            self().visit_symbol(*x.m_original_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_dt) {
            self().visit_expr(*x.m_dt);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Where(const Where_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Where");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_test);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_orelse; i++) {
            self().visit_stmt(*x.m_orelse[i]);
            if (i < x.n_orelse-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_WhileLoop(const WhileLoop_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("WhileLoop");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_test);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_BoolOp(const BoolOp_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("BoolOp");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_left);
        s.append(" ");
        visit_boolopType(x.m_op);
        s.append(" ");
        self().visit_expr(*x.m_right);
        s.append(" ");
        self().visit_ttype(*x.m_type);
        s.append(" ");
        if (x.m_value) {
            self().visit_expr(*x.m_value);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_BinOp(const BinOp_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("BinOp");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_left);
        s.append(" ");
        visit_binopType(x.m_op);
        s.append(" ");
        self().visit_expr(*x.m_right);
        s.append(" ");
        self().visit_ttype(*x.m_type);
        s.append(" ");
        if (x.m_value) {
            self().visit_expr(*x.m_value);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_overloaded) {
            self().visit_expr(*x.m_overloaded);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_StrOp(const StrOp_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("StrOp");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_left);
        s.append(" ");
        visit_stropType(x.m_op);
        s.append(" ");
        self().visit_expr(*x.m_right);
        s.append(" ");
        self().visit_ttype(*x.m_type);
        s.append(" ");
        if (x.m_value) {
            self().visit_expr(*x.m_value);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_UnaryOp(const UnaryOp_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("UnaryOp");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        visit_unaryopType(x.m_op);
        s.append(" ");
        self().visit_expr(*x.m_operand);
        s.append(" ");
        self().visit_ttype(*x.m_type);
        s.append(" ");
        if (x.m_value) {
            self().visit_expr(*x.m_value);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ComplexConstructor(const ComplexConstructor_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ComplexConstructor");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_re);
        s.append(" ");
        self().visit_expr(*x.m_im);
        s.append(" ");
        self().visit_ttype(*x.m_type);
        s.append(" ");
        if (x.m_value) {
            self().visit_expr(*x.m_value);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Compare(const Compare_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Compare");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_left);
        s.append(" ");
        visit_cmpopType(x.m_op);
        s.append(" ");
        self().visit_expr(*x.m_right);
        s.append(" ");
        self().visit_ttype(*x.m_type);
        s.append(" ");
        if (x.m_value) {
            self().visit_expr(*x.m_value);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_overloaded) {
            self().visit_expr(*x.m_overloaded);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_FunctionCall(const FunctionCall_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("FunctionCall");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_symbol(*x.m_name);
        s.append(" ");
        if (x.m_original_name) {
            self().visit_symbol(*x.m_original_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_keywords; i++) {
            self().visit_keyword(x.m_keywords[i]);
            if (i < x.n_keywords-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        self().visit_ttype(*x.m_type);
        s.append(" ");
        if (x.m_value) {
            self().visit_expr(*x.m_value);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_dt) {
            self().visit_expr(*x.m_dt);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_DerivedTypeConstructor(const DerivedTypeConstructor_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("DerivedTypeConstructor");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_symbol(*x.m_dt_sym);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        self().visit_ttype(*x.m_type);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ConstantArray(const ConstantArray_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ConstantArray");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        self().visit_ttype(*x.m_type);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ImpliedDoLoop(const ImpliedDoLoop_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ImpliedDoLoop");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
            if (i < x.n_values-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        self().visit_expr(*x.m_var);
        s.append(" ");
        self().visit_expr(*x.m_start);
        s.append(" ");
        self().visit_expr(*x.m_end);
        s.append(" ");
        if (x.m_increment) {
            self().visit_expr(*x.m_increment);
        } else {
            s.append("()");
        }
        s.append(" ");
        self().visit_ttype(*x.m_type);
        s.append(" ");
        if (x.m_value) {
            self().visit_expr(*x.m_value);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ConstantInteger(const ConstantInteger_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ConstantInteger");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_n));
        s.append(" ");
        self().visit_ttype(*x.m_type);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ConstantReal(const ConstantReal_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ConstantReal");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_r));
        s.append(" ");
        self().visit_ttype(*x.m_type);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ConstantComplex(const ConstantComplex_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ConstantComplex");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_re));
        s.append(" ");
        s.append(std::to_string(x.m_im));
        s.append(" ");
        self().visit_ttype(*x.m_type);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ConstantLogical(const ConstantLogical_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ConstantLogical");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_value) {
            s.append(".true.");
        } else {
            s.append(".false.");
        }
        s.append(" ");
        self().visit_ttype(*x.m_type);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ConstantString(const ConstantString_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ConstantString");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("\"" + std::string(x.m_s) + "\"");
        s.append(" ");
        self().visit_ttype(*x.m_type);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_BOZ(const BOZ_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("BOZ");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_v));
        s.append(" ");
        visit_bozType(x.m_boz_type);
        s.append(" ");
        if (x.m_type) {
            self().visit_ttype(*x.m_type);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Var(const Var_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Var");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_symbol(*x.m_v);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ArrayRef(const ArrayRef_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ArrayRef");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_symbol(*x.m_v);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_array_index(x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        self().visit_ttype(*x.m_type);
        s.append(" ");
        if (x.m_value) {
            self().visit_expr(*x.m_value);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_DerivedRef(const DerivedRef_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("DerivedRef");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_v);
        s.append(" ");
        self().visit_symbol(*x.m_m);
        s.append(" ");
        self().visit_ttype(*x.m_type);
        s.append(" ");
        if (x.m_value) {
            self().visit_expr(*x.m_value);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ImplicitCast(const ImplicitCast_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ImplicitCast");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_arg);
        s.append(" ");
        visit_cast_kindType(x.m_kind);
        s.append(" ");
        self().visit_ttype(*x.m_type);
        s.append(" ");
        if (x.m_value) {
            self().visit_expr(*x.m_value);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ExplicitCast(const ExplicitCast_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ExplicitCast");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_arg);
        s.append(" ");
        visit_cast_kindType(x.m_kind);
        s.append(" ");
        self().visit_ttype(*x.m_type);
        s.append(" ");
        if (x.m_value) {
            self().visit_expr(*x.m_value);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Integer(const Integer_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Integer");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_kind));
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
            if (i < x.n_dims-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Real(const Real_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Real");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_kind));
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
            if (i < x.n_dims-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Complex(const Complex_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Complex");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_kind));
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
            if (i < x.n_dims-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Character(const Character_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Character");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_kind));
        s.append(" ");
        s.append(std::to_string(x.m_len));
        s.append(" ");
        if (x.m_len_expr) {
            self().visit_expr(*x.m_len_expr);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
            if (i < x.n_dims-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Logical(const Logical_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Logical");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_kind));
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
            if (i < x.n_dims-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Derived(const Derived_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Derived");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_symbol(*x.m_derived_type);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
            if (i < x.n_dims-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Class(const Class_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Class");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_symbol(*x.m_class_type);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
            if (i < x.n_dims-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Pointer(const Pointer_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Pointer");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_ttype(*x.m_type);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_boolopType(const boolopType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (boolopType::And) : {
                if(indent) s.append("\n"+indtd);
                s.append("And");
             break; }
            case (boolopType::Or) : {
                if(indent) s.append("\n"+indtd);
                s.append("Or");
             break; }
            case (boolopType::Xor) : {
                if(indent) s.append("\n"+indtd);
                s.append("Xor");
             break; }
            case (boolopType::NEqv) : {
                if(indent) s.append("\n"+indtd);
                s.append("NEqv");
             break; }
            case (boolopType::Eqv) : {
                if(indent) s.append("\n"+indtd);
                s.append("Eqv");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_binopType(const binopType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (binopType::Add) : {
                if(indent) s.append("\n"+indtd);
                s.append("Add");
             break; }
            case (binopType::Sub) : {
                if(indent) s.append("\n"+indtd);
                s.append("Sub");
             break; }
            case (binopType::Mul) : {
                if(indent) s.append("\n"+indtd);
                s.append("Mul");
             break; }
            case (binopType::Div) : {
                if(indent) s.append("\n"+indtd);
                s.append("Div");
             break; }
            case (binopType::Pow) : {
                if(indent) s.append("\n"+indtd);
                s.append("Pow");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_unaryopType(const unaryopType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (unaryopType::Invert) : {
                if(indent) s.append("\n"+indtd);
                s.append("Invert");
             break; }
            case (unaryopType::Not) : {
                if(indent) s.append("\n"+indtd);
                s.append("Not");
             break; }
            case (unaryopType::UAdd) : {
                if(indent) s.append("\n"+indtd);
                s.append("UAdd");
             break; }
            case (unaryopType::USub) : {
                if(indent) s.append("\n"+indtd);
                s.append("USub");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_stropType(const stropType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (stropType::Concat) : {
                if(indent) s.append("\n"+indtd);
                s.append("Concat");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_cmpopType(const cmpopType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (cmpopType::Eq) : {
                if(indent) s.append("\n"+indtd);
                s.append("Eq");
             break; }
            case (cmpopType::NotEq) : {
                if(indent) s.append("\n"+indtd);
                s.append("NotEq");
             break; }
            case (cmpopType::Lt) : {
                if(indent) s.append("\n"+indtd);
                s.append("Lt");
             break; }
            case (cmpopType::LtE) : {
                if(indent) s.append("\n"+indtd);
                s.append("LtE");
             break; }
            case (cmpopType::Gt) : {
                if(indent) s.append("\n"+indtd);
                s.append("Gt");
             break; }
            case (cmpopType::GtE) : {
                if(indent) s.append("\n"+indtd);
                s.append("GtE");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_bozType(const bozType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (bozType::Binary) : {
                if(indent) s.append("\n"+indtd);
                s.append("Binary");
             break; }
            case (bozType::Hex) : {
                if(indent) s.append("\n"+indtd);
                s.append("Hex");
             break; }
            case (bozType::Octal) : {
                if(indent) s.append("\n"+indtd);
                s.append("Octal");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_cast_kindType(const cast_kindType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (cast_kindType::RealToInteger) : {
                if(indent) s.append("\n"+indtd);
                s.append("RealToInteger");
             break; }
            case (cast_kindType::IntegerToReal) : {
                if(indent) s.append("\n"+indtd);
                s.append("IntegerToReal");
             break; }
            case (cast_kindType::RealToReal) : {
                if(indent) s.append("\n"+indtd);
                s.append("RealToReal");
             break; }
            case (cast_kindType::IntegerToInteger) : {
                if(indent) s.append("\n"+indtd);
                s.append("IntegerToInteger");
             break; }
            case (cast_kindType::RealToComplex) : {
                if(indent) s.append("\n"+indtd);
                s.append("RealToComplex");
             break; }
            case (cast_kindType::IntegerToComplex) : {
                if(indent) s.append("\n"+indtd);
                s.append("IntegerToComplex");
             break; }
            case (cast_kindType::IntegerToLogical) : {
                if(indent) s.append("\n"+indtd);
                s.append("IntegerToLogical");
             break; }
            case (cast_kindType::ComplexToComplex) : {
                if(indent) s.append("\n"+indtd);
                s.append("ComplexToComplex");
             break; }
            case (cast_kindType::ComplexToReal) : {
                if(indent) s.append("\n"+indtd);
                s.append("ComplexToReal");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_dimension(const dimension_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (x.m_start) {
            self().visit_expr(*x.m_start);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_end) {
            self().visit_expr(*x.m_end);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_alloc_arg(const alloc_arg_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        self().visit_symbol(*x.m_a);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
            if (i < x.n_dims-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Attribute(const Attribute_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Attribute");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_attribute_arg(x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_attribute_arg(const attribute_arg_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_arg);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_arg(const arg_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_arg);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_keyword(const keyword_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (x.m_arg) {
            s.append(x.m_arg);
        } else {
            s.append("()");
        }
        s.append(" ");
        self().visit_expr(*x.m_value);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Bind(const Bind_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Bind");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("\"" + std::string(x.m_lang) + "\"");
        s.append(" ");
        s.append("\"" + std::string(x.m_name) + "\"");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_array_index(const array_index_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (x.m_left) {
            self().visit_expr(*x.m_left);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_right) {
            self().visit_expr(*x.m_right);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_step) {
            self().visit_expr(*x.m_step);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_do_loop_head(const do_loop_head_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        self().visit_expr(*x.m_v);
        s.append(" ");
        self().visit_expr(*x.m_start);
        s.append(" ");
        self().visit_expr(*x.m_end);
        s.append(" ");
        if (x.m_increment) {
            self().visit_expr(*x.m_increment);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_CaseStmt(const CaseStmt_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("CaseStmt");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_test; i++) {
            self().visit_expr(*x.m_test[i]);
            if (i < x.n_test-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_CaseStmt_Range(const CaseStmt_Range_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("CaseStmt_Range");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_start) {
            self().visit_expr(*x.m_start);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_end) {
            self().visit_expr(*x.m_end);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
};


/******************************************************************************/
// Serialization Visitor base class

template <class Derived>
class SerializationBaseVisitor : public BaseVisitor<Derived>
{
private:
    Derived& self() { return static_cast<Derived&>(*this); }
public:
    void visit_TranslationUnit(const TranslationUnit_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_global_scope->counter);
        self().write_int64(x.m_global_scope->scope.size());
        for (auto &a : x.m_global_scope->scope) {
            self().write_string(a.first);
            this->visit_symbol(*a.second);
        }
        self().write_int64(x.n_items);
        for (size_t i=0; i<x.n_items; i++) {
            self().write_int8(x.m_items[i]->type);
            self().visit_asr(*x.m_items[i]);
        }
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Program(const Program_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_symtab->counter);
        self().write_int64(x.m_symtab->scope.size());
        for (auto &a : x.m_symtab->scope) {
            self().write_string(a.first);
            this->visit_symbol(*a.second);
        }
        self().write_string(x.m_name);
        self().write_int64(x.n_dependencies);
        for (size_t i=0; i<x.n_dependencies; i++) {
            self().write_string(x.m_dependencies[i]);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_Module(const Module_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_symtab->counter);
        self().write_int64(x.m_symtab->scope.size());
        for (auto &a : x.m_symtab->scope) {
            self().write_string(a.first);
            this->visit_symbol(*a.second);
        }
        self().write_string(x.m_name);
        self().write_int64(x.n_dependencies);
        for (size_t i=0; i<x.n_dependencies; i++) {
            self().write_string(x.m_dependencies[i]);
        }
        if (x.m_loaded_from_mod) {
            self().write_bool(true);
        } else {
            self().write_bool(false);
        }
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Subroutine(const Subroutine_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_symtab->counter);
        self().write_int64(x.m_symtab->scope.size());
        for (auto &a : x.m_symtab->scope) {
            self().write_string(a.first);
            this->visit_symbol(*a.second);
        }
        self().write_string(x.m_name);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        visit_abiType(x.m_abi);
        visit_accessType(x.m_access);
        visit_deftypeType(x.m_deftype);
        if (x.m_bindc_name) {
            self().write_bool(true);
            self().write_string(x.m_bindc_name);
        } else {
            self().write_bool(false);
        }
        if (x.m_pure) {
            self().write_bool(true);
        } else {
            self().write_bool(false);
        }
        if (x.m_module) {
            self().write_bool(true);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Function(const Function_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_symtab->counter);
        self().write_int64(x.m_symtab->scope.size());
        for (auto &a : x.m_symtab->scope) {
            self().write_string(a.first);
            this->visit_symbol(*a.second);
        }
        self().write_string(x.m_name);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        self().visit_expr(*x.m_return_var);
        visit_abiType(x.m_abi);
        visit_accessType(x.m_access);
        visit_deftypeType(x.m_deftype);
        if (x.m_bindc_name) {
            self().write_bool(true);
            self().write_string(x.m_bindc_name);
        } else {
            self().write_bool(false);
        }
    }
    void visit_GenericProcedure(const GenericProcedure_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_parent_symtab->counter);
        self().write_string(x.m_name);
        self().write_int64(x.n_procs);
        for (size_t i=0; i<x.n_procs; i++) {
            self().write_symbol(*x.m_procs[i]);
        }
        visit_accessType(x.m_access);
    }
    void visit_CustomOperator(const CustomOperator_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_parent_symtab->counter);
        self().write_string(x.m_name);
        self().write_int64(x.n_procs);
        for (size_t i=0; i<x.n_procs; i++) {
            self().write_symbol(*x.m_procs[i]);
        }
        visit_accessType(x.m_access);
    }
    void visit_ExternalSymbol(const ExternalSymbol_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_parent_symtab->counter);
        self().write_string(x.m_name);
        // We skip the symbol for ExternalSymbol
        self().write_string(x.m_module_name);
        self().write_int64(x.n_scope_names);
        for (size_t i=0; i<x.n_scope_names; i++) {
            self().write_string(x.m_scope_names[i]);
        }
        self().write_string(x.m_original_name);
        visit_accessType(x.m_access);
    }
    void visit_DerivedType(const DerivedType_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_symtab->counter);
        self().write_int64(x.m_symtab->scope.size());
        for (auto &a : x.m_symtab->scope) {
            self().write_string(a.first);
            this->visit_symbol(*a.second);
        }
        self().write_string(x.m_name);
        self().write_int64(x.n_members);
        for (size_t i=0; i<x.n_members; i++) {
            self().write_string(x.m_members[i]);
        }
        visit_abiType(x.m_abi);
        visit_accessType(x.m_access);
        if (x.m_parent) {
            self().write_bool(true);
            self().write_symbol(*x.m_parent);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Variable(const Variable_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_parent_symtab->counter);
        self().write_string(x.m_name);
        visit_intentType(x.m_intent);
        if (x.m_symbolic_value) {
            self().write_bool(true);
            self().visit_expr(*x.m_symbolic_value);
        } else {
            self().write_bool(false);
        }
        if (x.m_value) {
            self().write_bool(true);
            self().visit_expr(*x.m_value);
        } else {
            self().write_bool(false);
        }
        visit_storage_typeType(x.m_storage);
        self().visit_ttype(*x.m_type);
        visit_abiType(x.m_abi);
        visit_accessType(x.m_access);
        visit_presenceType(x.m_presence);
        if (x.m_value_attr) {
            self().write_bool(true);
        } else {
            self().write_bool(false);
        }
    }
    void visit_ClassType(const ClassType_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_symtab->counter);
        self().write_int64(x.m_symtab->scope.size());
        for (auto &a : x.m_symtab->scope) {
            self().write_string(a.first);
            this->visit_symbol(*a.second);
        }
        self().write_string(x.m_name);
        visit_abiType(x.m_abi);
        visit_accessType(x.m_access);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ClassProcedure(const ClassProcedure_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_parent_symtab->counter);
        self().write_string(x.m_name);
        self().write_string(x.m_proc_name);
        self().write_symbol(*x.m_proc);
        visit_abiType(x.m_abi);
    }
    void visit_storage_typeType(const storage_typeType &x) {
        self().write_int8(x);
    }
    void visit_accessType(const accessType &x) {
        self().write_int8(x);
    }
    void visit_intentType(const intentType &x) {
        self().write_int8(x);
    }
    void visit_deftypeType(const deftypeType &x) {
        self().write_int8(x);
    }
    void visit_presenceType(const presenceType &x) {
        self().write_int8(x);
    }
    void visit_abiType(const abiType &x) {
        self().write_int8(x);
    }
    void visit_Allocate(const Allocate_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_alloc_arg(x.m_args[i]);
        }
        if (x.m_stat) {
            self().write_bool(true);
            self().visit_expr(*x.m_stat);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Assign(const Assign_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().write_string(x.m_variable);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Assignment(const Assignment_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_target);
        self().visit_expr(*x.m_value);
        if (x.m_overloaded) {
            self().write_bool(true);
            self().visit_stmt(*x.m_overloaded);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Associate(const Associate_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_target);
        self().visit_expr(*x.m_value);
    }
    void visit_Cycle(const Cycle_t &x) {
        self().write_int8(x.base.type);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ExplicitDeallocate(const ExplicitDeallocate_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_vars);
        for (size_t i=0; i<x.n_vars; i++) {
            self().write_symbol(*x.m_vars[i]);
        }
    }
    void visit_ImplicitDeallocate(const ImplicitDeallocate_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_vars);
        for (size_t i=0; i<x.n_vars; i++) {
            self().write_symbol(*x.m_vars[i]);
        }
    }
    void visit_DoConcurrentLoop(const DoConcurrentLoop_t &x) {
        self().write_int8(x.base.type);
        self().visit_do_loop_head(x.m_head);
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_DoLoop(const DoLoop_t &x) {
        self().write_int8(x.base.type);
        self().visit_do_loop_head(x.m_head);
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_ErrorStop(const ErrorStop_t &x) {
        self().write_int8(x.base.type);
        if (x.m_code) {
            self().write_bool(true);
            self().visit_expr(*x.m_code);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Exit(const Exit_t &x) {
        self().write_int8(x.base.type);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ForAllSingle(const ForAllSingle_t &x) {
        self().write_int8(x.base.type);
        self().visit_do_loop_head(x.m_head);
        self().visit_stmt(*x.m_assign_stmt);
    }
    void visit_GoTo(const GoTo_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_target_id);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_GoToTarget(const GoToTarget_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_id);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_If(const If_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_test);
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        self().write_int64(x.n_orelse);
        for (size_t i=0; i<x.n_orelse; i++) {
            self().visit_stmt(*x.m_orelse[i]);
        }
    }
    void visit_IfArithmetic(const IfArithmetic_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_test);
        self().write_int64(x.m_lt_label);
        self().write_int64(x.m_eq_label);
        self().write_int64(x.m_gt_label);
    }
    void visit_Print(const Print_t &x) {
        self().write_int8(x.base.type);
        if (x.m_fmt) {
            self().write_bool(true);
            self().visit_expr(*x.m_fmt);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_values);
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
        }
    }
    void visit_Open(const Open_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_newunit) {
            self().write_bool(true);
            self().visit_expr(*x.m_newunit);
        } else {
            self().write_bool(false);
        }
        if (x.m_filename) {
            self().write_bool(true);
            self().visit_expr(*x.m_filename);
        } else {
            self().write_bool(false);
        }
        if (x.m_status) {
            self().write_bool(true);
            self().visit_expr(*x.m_status);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Close(const Close_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_unit) {
            self().write_bool(true);
            self().visit_expr(*x.m_unit);
        } else {
            self().write_bool(false);
        }
        if (x.m_iostat) {
            self().write_bool(true);
            self().visit_expr(*x.m_iostat);
        } else {
            self().write_bool(false);
        }
        if (x.m_iomsg) {
            self().write_bool(true);
            self().visit_expr(*x.m_iomsg);
        } else {
            self().write_bool(false);
        }
        if (x.m_err) {
            self().write_bool(true);
            self().visit_expr(*x.m_err);
        } else {
            self().write_bool(false);
        }
        if (x.m_status) {
            self().write_bool(true);
            self().visit_expr(*x.m_status);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Read(const Read_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_unit) {
            self().write_bool(true);
            self().visit_expr(*x.m_unit);
        } else {
            self().write_bool(false);
        }
        if (x.m_fmt) {
            self().write_bool(true);
            self().visit_expr(*x.m_fmt);
        } else {
            self().write_bool(false);
        }
        if (x.m_iomsg) {
            self().write_bool(true);
            self().visit_expr(*x.m_iomsg);
        } else {
            self().write_bool(false);
        }
        if (x.m_iostat) {
            self().write_bool(true);
            self().visit_expr(*x.m_iostat);
        } else {
            self().write_bool(false);
        }
        if (x.m_id) {
            self().write_bool(true);
            self().visit_expr(*x.m_id);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_values);
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
        }
    }
    void visit_Write(const Write_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_unit) {
            self().write_bool(true);
            self().visit_expr(*x.m_unit);
        } else {
            self().write_bool(false);
        }
        if (x.m_fmt) {
            self().write_bool(true);
            self().visit_expr(*x.m_fmt);
        } else {
            self().write_bool(false);
        }
        if (x.m_iomsg) {
            self().write_bool(true);
            self().visit_expr(*x.m_iomsg);
        } else {
            self().write_bool(false);
        }
        if (x.m_iostat) {
            self().write_bool(true);
            self().visit_expr(*x.m_iostat);
        } else {
            self().write_bool(false);
        }
        if (x.m_id) {
            self().write_bool(true);
            self().visit_expr(*x.m_id);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_values);
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
        }
    }
    void visit_Return(const Return_t &x) {
        self().write_int8(x.base.type);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Select(const Select_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_test);
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_case_stmt(*x.m_body[i]);
        }
        self().write_int64(x.n_default);
        for (size_t i=0; i<x.n_default; i++) {
            self().visit_stmt(*x.m_default[i]);
        }
    }
    void visit_Stop(const Stop_t &x) {
        self().write_int8(x.base.type);
        if (x.m_code) {
            self().write_bool(true);
            self().visit_expr(*x.m_code);
        } else {
            self().write_bool(false);
        }
    }
    void visit_SubroutineCall(const SubroutineCall_t &x) {
        self().write_int8(x.base.type);
        self().write_symbol(*x.m_name);
        if (x.m_original_name) {
            self().write_bool(true);
            self().write_symbol(*x.m_original_name);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        if (x.m_dt) {
            self().write_bool(true);
            self().visit_expr(*x.m_dt);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Where(const Where_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_test);
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        self().write_int64(x.n_orelse);
        for (size_t i=0; i<x.n_orelse; i++) {
            self().visit_stmt(*x.m_orelse[i]);
        }
    }
    void visit_WhileLoop(const WhileLoop_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_test);
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_BoolOp(const BoolOp_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_left);
        visit_boolopType(x.m_op);
        self().visit_expr(*x.m_right);
        self().visit_ttype(*x.m_type);
        if (x.m_value) {
            self().write_bool(true);
            self().visit_expr(*x.m_value);
        } else {
            self().write_bool(false);
        }
    }
    void visit_BinOp(const BinOp_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_left);
        visit_binopType(x.m_op);
        self().visit_expr(*x.m_right);
        self().visit_ttype(*x.m_type);
        if (x.m_value) {
            self().write_bool(true);
            self().visit_expr(*x.m_value);
        } else {
            self().write_bool(false);
        }
        if (x.m_overloaded) {
            self().write_bool(true);
            self().visit_expr(*x.m_overloaded);
        } else {
            self().write_bool(false);
        }
    }
    void visit_StrOp(const StrOp_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_left);
        visit_stropType(x.m_op);
        self().visit_expr(*x.m_right);
        self().visit_ttype(*x.m_type);
        if (x.m_value) {
            self().write_bool(true);
            self().visit_expr(*x.m_value);
        } else {
            self().write_bool(false);
        }
    }
    void visit_UnaryOp(const UnaryOp_t &x) {
        self().write_int8(x.base.type);
        visit_unaryopType(x.m_op);
        self().visit_expr(*x.m_operand);
        self().visit_ttype(*x.m_type);
        if (x.m_value) {
            self().write_bool(true);
            self().visit_expr(*x.m_value);
        } else {
            self().write_bool(false);
        }
    }
    void visit_ComplexConstructor(const ComplexConstructor_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_re);
        self().visit_expr(*x.m_im);
        self().visit_ttype(*x.m_type);
        if (x.m_value) {
            self().write_bool(true);
            self().visit_expr(*x.m_value);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Compare(const Compare_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_left);
        visit_cmpopType(x.m_op);
        self().visit_expr(*x.m_right);
        self().visit_ttype(*x.m_type);
        if (x.m_value) {
            self().write_bool(true);
            self().visit_expr(*x.m_value);
        } else {
            self().write_bool(false);
        }
        if (x.m_overloaded) {
            self().write_bool(true);
            self().visit_expr(*x.m_overloaded);
        } else {
            self().write_bool(false);
        }
    }
    void visit_FunctionCall(const FunctionCall_t &x) {
        self().write_int8(x.base.type);
        self().write_symbol(*x.m_name);
        if (x.m_original_name) {
            self().write_bool(true);
            self().write_symbol(*x.m_original_name);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        self().write_int64(x.n_keywords);
        for (size_t i=0; i<x.n_keywords; i++) {
            self().visit_keyword(x.m_keywords[i]);
        }
        self().visit_ttype(*x.m_type);
        if (x.m_value) {
            self().write_bool(true);
            self().visit_expr(*x.m_value);
        } else {
            self().write_bool(false);
        }
        if (x.m_dt) {
            self().write_bool(true);
            self().visit_expr(*x.m_dt);
        } else {
            self().write_bool(false);
        }
    }
    void visit_DerivedTypeConstructor(const DerivedTypeConstructor_t &x) {
        self().write_int8(x.base.type);
        self().write_symbol(*x.m_dt_sym);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        self().visit_ttype(*x.m_type);
    }
    void visit_ConstantArray(const ConstantArray_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        self().visit_ttype(*x.m_type);
    }
    void visit_ImpliedDoLoop(const ImpliedDoLoop_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_values);
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
        }
        self().visit_expr(*x.m_var);
        self().visit_expr(*x.m_start);
        self().visit_expr(*x.m_end);
        if (x.m_increment) {
            self().write_bool(true);
            self().visit_expr(*x.m_increment);
        } else {
            self().write_bool(false);
        }
        self().visit_ttype(*x.m_type);
        if (x.m_value) {
            self().write_bool(true);
            self().visit_expr(*x.m_value);
        } else {
            self().write_bool(false);
        }
    }
    void visit_ConstantInteger(const ConstantInteger_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_n);
        self().visit_ttype(*x.m_type);
    }
    void visit_ConstantReal(const ConstantReal_t &x) {
        self().write_int8(x.base.type);
        self().write_float64(x.m_r);
        self().visit_ttype(*x.m_type);
    }
    void visit_ConstantComplex(const ConstantComplex_t &x) {
        self().write_int8(x.base.type);
        self().write_float64(x.m_re);
        self().write_float64(x.m_im);
        self().visit_ttype(*x.m_type);
    }
    void visit_ConstantLogical(const ConstantLogical_t &x) {
        self().write_int8(x.base.type);
        if (x.m_value) {
            self().write_bool(true);
        } else {
            self().write_bool(false);
        }
        self().visit_ttype(*x.m_type);
    }
    void visit_ConstantString(const ConstantString_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_s);
        self().visit_ttype(*x.m_type);
    }
    void visit_BOZ(const BOZ_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_v);
        visit_bozType(x.m_boz_type);
        if (x.m_type) {
            self().write_bool(true);
            self().visit_ttype(*x.m_type);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Var(const Var_t &x) {
        self().write_int8(x.base.type);
        self().write_symbol(*x.m_v);
    }
    void visit_ArrayRef(const ArrayRef_t &x) {
        self().write_int8(x.base.type);
        self().write_symbol(*x.m_v);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_array_index(x.m_args[i]);
        }
        self().visit_ttype(*x.m_type);
        if (x.m_value) {
            self().write_bool(true);
            self().visit_expr(*x.m_value);
        } else {
            self().write_bool(false);
        }
    }
    void visit_DerivedRef(const DerivedRef_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_v);
        self().write_symbol(*x.m_m);
        self().visit_ttype(*x.m_type);
        if (x.m_value) {
            self().write_bool(true);
            self().visit_expr(*x.m_value);
        } else {
            self().write_bool(false);
        }
    }
    void visit_ImplicitCast(const ImplicitCast_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_arg);
        visit_cast_kindType(x.m_kind);
        self().visit_ttype(*x.m_type);
        if (x.m_value) {
            self().write_bool(true);
            self().visit_expr(*x.m_value);
        } else {
            self().write_bool(false);
        }
    }
    void visit_ExplicitCast(const ExplicitCast_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_arg);
        visit_cast_kindType(x.m_kind);
        self().visit_ttype(*x.m_type);
        if (x.m_value) {
            self().write_bool(true);
            self().visit_expr(*x.m_value);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Integer(const Integer_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_kind);
        self().write_int64(x.n_dims);
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
        }
    }
    void visit_Real(const Real_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_kind);
        self().write_int64(x.n_dims);
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
        }
    }
    void visit_Complex(const Complex_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_kind);
        self().write_int64(x.n_dims);
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
        }
    }
    void visit_Character(const Character_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_kind);
        self().write_int64(x.m_len);
        if (x.m_len_expr) {
            self().write_bool(true);
            self().visit_expr(*x.m_len_expr);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_dims);
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
        }
    }
    void visit_Logical(const Logical_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_kind);
        self().write_int64(x.n_dims);
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
        }
    }
    void visit_Derived(const Derived_t &x) {
        self().write_int8(x.base.type);
        self().write_symbol(*x.m_derived_type);
        self().write_int64(x.n_dims);
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
        }
    }
    void visit_Class(const Class_t &x) {
        self().write_int8(x.base.type);
        self().write_symbol(*x.m_class_type);
        self().write_int64(x.n_dims);
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
        }
    }
    void visit_Pointer(const Pointer_t &x) {
        self().write_int8(x.base.type);
        self().visit_ttype(*x.m_type);
    }
    void visit_boolopType(const boolopType &x) {
        self().write_int8(x);
    }
    void visit_binopType(const binopType &x) {
        self().write_int8(x);
    }
    void visit_unaryopType(const unaryopType &x) {
        self().write_int8(x);
    }
    void visit_stropType(const stropType &x) {
        self().write_int8(x);
    }
    void visit_cmpopType(const cmpopType &x) {
        self().write_int8(x);
    }
    void visit_bozType(const bozType &x) {
        self().write_int8(x);
    }
    void visit_cast_kindType(const cast_kindType &x) {
        self().write_int8(x);
    }
    void visit_dimension(const dimension_t &x) {
        if (x.m_start) {
            self().write_bool(true);
            self().visit_expr(*x.m_start);
        } else {
            self().write_bool(false);
        }
        if (x.m_end) {
            self().write_bool(true);
            self().visit_expr(*x.m_end);
        } else {
            self().write_bool(false);
        }
    }
    void visit_alloc_arg(const alloc_arg_t &x) {
        self().write_symbol(*x.m_a);
        self().write_int64(x.n_dims);
        for (size_t i=0; i<x.n_dims; i++) {
            self().visit_dimension(x.m_dims[i]);
        }
    }
    void visit_Attribute(const Attribute_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_name);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_attribute_arg(x.m_args[i]);
        }
    }
    void visit_attribute_arg(const attribute_arg_t &x) {
        self().write_string(x.m_arg);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_arg(const arg_t &x) {
        self().write_string(x.m_arg);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_keyword(const keyword_t &x) {
        if (x.m_arg) {
            self().write_bool(true);
            self().write_string(x.m_arg);
        } else {
            self().write_bool(false);
        }
        self().visit_expr(*x.m_value);
    }
    void visit_Bind(const Bind_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_lang);
        self().write_string(x.m_name);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_array_index(const array_index_t &x) {
        if (x.m_left) {
            self().write_bool(true);
            self().visit_expr(*x.m_left);
        } else {
            self().write_bool(false);
        }
        if (x.m_right) {
            self().write_bool(true);
            self().visit_expr(*x.m_right);
        } else {
            self().write_bool(false);
        }
        if (x.m_step) {
            self().write_bool(true);
            self().visit_expr(*x.m_step);
        } else {
            self().write_bool(false);
        }
    }
    void visit_do_loop_head(const do_loop_head_t &x) {
        self().visit_expr(*x.m_v);
        self().visit_expr(*x.m_start);
        self().visit_expr(*x.m_end);
        if (x.m_increment) {
            self().write_bool(true);
            self().visit_expr(*x.m_increment);
        } else {
            self().write_bool(false);
        }
    }
    void visit_CaseStmt(const CaseStmt_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_test);
        for (size_t i=0; i<x.n_test; i++) {
            self().visit_expr(*x.m_test[i]);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_CaseStmt_Range(const CaseStmt_Range_t &x) {
        self().write_int8(x.base.type);
        if (x.m_start) {
            self().write_bool(true);
            self().visit_expr(*x.m_start);
        } else {
            self().write_bool(false);
        }
        if (x.m_end) {
            self().write_bool(true);
            self().visit_expr(*x.m_end);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
};


/******************************************************************************/
// Deserialization Visitor base class

template <class Derived>
class DeserializationBaseVisitor : public BaseVisitor<Derived>
{
private:
    Derived& self() { return static_cast<Derived&>(*this); }
public:
    Allocator &al;
    bool load_symtab_id;
    std::map<uint64_t,SymbolTable*> id_symtab_map;
    DeserializationBaseVisitor(Allocator &al, bool load_symtab_id) : al{al}, load_symtab_id{load_symtab_id} {}
    asr_t* deserialize_node() {
        uint8_t t = self().read_int8();
        ASR::asrType ty = static_cast<ASR::asrType>(t);
        switch (ty) {
            case (ASR::asrType::unit) : return self().deserialize_unit();
            case (ASR::asrType::symbol) : return self().deserialize_symbol();
            case (ASR::asrType::stmt) : return self().deserialize_stmt();
            case (ASR::asrType::expr) : return self().deserialize_expr();
            case (ASR::asrType::ttype) : return self().deserialize_ttype();
            case (ASR::asrType::attribute) : return self().deserialize_attribute();
            case (ASR::asrType::tbind) : return self().deserialize_tbind();
            case (ASR::asrType::case_stmt) : return self().deserialize_case_stmt();
            default : throw LFortranException("Unknown type in deserialize_node()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    asr_t* deserialize_TranslationUnit() {
        size_t n_items; // Sequence
        uint64_t m_global_scope_counter = self().read_int64();
        LFORTRAN_ASSERT(id_symtab_map.find(m_global_scope_counter) == id_symtab_map.end());
        SymbolTable *m_global_scope = al.make_new<SymbolTable>(nullptr);
        if (load_symtab_id) m_global_scope->counter = m_global_scope_counter;
        id_symtab_map[m_global_scope_counter] = m_global_scope;
        {
            size_t n = self().read_int64();
            for (size_t i=0; i<n; i++) {
                std::string name = self().read_string();
                symbol_t *sym = down_cast<symbol_t>(deserialize_symbol());
                self().symtab_insert_symbol(*m_global_scope, name, sym);
            }
        }
        n_items = self().read_int64();
        Vec<asr_t*> v_items;
        v_items.reserve(al, n_items);
        for (size_t i=0; i<n_items; i++) {
            v_items.push_back(al, self().deserialize_node());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_TranslationUnit_t(al, loc, m_global_scope, v_items.p, v_items.n);
    }
    asr_t* deserialize_unit() {
        uint8_t t = self().read_int8();
        ASR::unitType ty = static_cast<ASR::unitType>(t);
        switch (ty) {
            case (ASR::unitType::TranslationUnit) : return self().deserialize_TranslationUnit();
            default : throw LFortranException("Unknown type in deserialize_unit()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    asr_t* deserialize_Program() {
        size_t n_dependencies; // Sequence
        size_t n_body; // Sequence
        uint64_t m_symtab_counter = self().read_int64();
        LFORTRAN_ASSERT(id_symtab_map.find(m_symtab_counter) == id_symtab_map.end());
        SymbolTable *m_symtab = al.make_new<SymbolTable>(nullptr);
        if (load_symtab_id) m_symtab->counter = m_symtab_counter;
        id_symtab_map[m_symtab_counter] = m_symtab;
        {
            size_t n = self().read_int64();
            for (size_t i=0; i<n; i++) {
                std::string name = self().read_string();
                symbol_t *sym = down_cast<symbol_t>(deserialize_symbol());
                self().symtab_insert_symbol(*m_symtab, name, sym);
            }
        }
        char *m_name;
        m_name = self().read_cstring();
        n_dependencies = self().read_int64();
        Vec<char*> v_dependencies;
        v_dependencies.reserve(al, n_dependencies);
        for (size_t i=0; i<n_dependencies; i++) {
            v_dependencies.push_back(al, self().read_cstring());
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, ASR::down_cast<ASR::stmt_t>(self().deserialize_stmt()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Program_t(al, loc, m_symtab, m_name, v_dependencies.p, v_dependencies.n, v_body.p, v_body.n);
    }
    asr_t* deserialize_Module() {
        size_t n_dependencies; // Sequence
        uint64_t m_symtab_counter = self().read_int64();
        LFORTRAN_ASSERT(id_symtab_map.find(m_symtab_counter) == id_symtab_map.end());
        SymbolTable *m_symtab = al.make_new<SymbolTable>(nullptr);
        if (load_symtab_id) m_symtab->counter = m_symtab_counter;
        id_symtab_map[m_symtab_counter] = m_symtab;
        {
            size_t n = self().read_int64();
            for (size_t i=0; i<n; i++) {
                std::string name = self().read_string();
                symbol_t *sym = down_cast<symbol_t>(deserialize_symbol());
                self().symtab_insert_symbol(*m_symtab, name, sym);
            }
        }
        char *m_name;
        m_name = self().read_cstring();
        n_dependencies = self().read_int64();
        Vec<char*> v_dependencies;
        v_dependencies.reserve(al, n_dependencies);
        for (size_t i=0; i<n_dependencies; i++) {
            v_dependencies.push_back(al, self().read_cstring());
        }
        bool m_loaded_from_mod = self().read_bool();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Module_t(al, loc, m_symtab, m_name, v_dependencies.p, v_dependencies.n, m_loaded_from_mod);
    }
    asr_t* deserialize_Subroutine() {
        size_t n_args; // Sequence
        size_t n_body; // Sequence
        uint64_t m_symtab_counter = self().read_int64();
        LFORTRAN_ASSERT(id_symtab_map.find(m_symtab_counter) == id_symtab_map.end());
        SymbolTable *m_symtab = al.make_new<SymbolTable>(nullptr);
        if (load_symtab_id) m_symtab->counter = m_symtab_counter;
        id_symtab_map[m_symtab_counter] = m_symtab;
        {
            size_t n = self().read_int64();
            for (size_t i=0; i<n; i++) {
                std::string name = self().read_string();
                symbol_t *sym = down_cast<symbol_t>(deserialize_symbol());
                self().symtab_insert_symbol(*m_symtab, name, sym);
            }
        }
        char *m_name;
        m_name = self().read_cstring();
        n_args = self().read_int64();
        Vec<expr_t*> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, ASR::down_cast<ASR::expr_t>(self().deserialize_expr()));
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, ASR::down_cast<ASR::stmt_t>(self().deserialize_stmt()));
        }
        ASR::abiType m_abi = self().deserialize_abi();
        ASR::accessType m_access = self().deserialize_access();
        ASR::deftypeType m_deftype = self().deserialize_deftype();
        char *m_bindc_name;
        bool m_bindc_name_present = self().read_bool();
        if (m_bindc_name_present) {
        m_bindc_name = self().read_cstring();
        } else {
        m_bindc_name = nullptr;
        }
        bool m_pure = self().read_bool();
        bool m_module = self().read_bool();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Subroutine_t(al, loc, m_symtab, m_name, v_args.p, v_args.n, v_body.p, v_body.n, m_abi, m_access, m_deftype, m_bindc_name, m_pure, m_module);
    }
    asr_t* deserialize_Function() {
        size_t n_args; // Sequence
        size_t n_body; // Sequence
        uint64_t m_symtab_counter = self().read_int64();
        LFORTRAN_ASSERT(id_symtab_map.find(m_symtab_counter) == id_symtab_map.end());
        SymbolTable *m_symtab = al.make_new<SymbolTable>(nullptr);
        if (load_symtab_id) m_symtab->counter = m_symtab_counter;
        id_symtab_map[m_symtab_counter] = m_symtab;
        {
            size_t n = self().read_int64();
            for (size_t i=0; i<n; i++) {
                std::string name = self().read_string();
                symbol_t *sym = down_cast<symbol_t>(deserialize_symbol());
                self().symtab_insert_symbol(*m_symtab, name, sym);
            }
        }
        char *m_name;
        m_name = self().read_cstring();
        n_args = self().read_int64();
        Vec<expr_t*> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, ASR::down_cast<ASR::expr_t>(self().deserialize_expr()));
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, ASR::down_cast<ASR::stmt_t>(self().deserialize_stmt()));
        }
        ASR::expr_t *m_return_var;
        m_return_var = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        ASR::abiType m_abi = self().deserialize_abi();
        ASR::accessType m_access = self().deserialize_access();
        ASR::deftypeType m_deftype = self().deserialize_deftype();
        char *m_bindc_name;
        bool m_bindc_name_present = self().read_bool();
        if (m_bindc_name_present) {
        m_bindc_name = self().read_cstring();
        } else {
        m_bindc_name = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Function_t(al, loc, m_symtab, m_name, v_args.p, v_args.n, v_body.p, v_body.n, m_return_var, m_abi, m_access, m_deftype, m_bindc_name);
    }
    asr_t* deserialize_GenericProcedure() {
        size_t n_procs; // Sequence
        uint64_t m_parent_symtab_counter = self().read_int64();
        LFORTRAN_ASSERT(id_symtab_map.find(m_parent_symtab_counter) != id_symtab_map.end());
        SymbolTable *m_parent_symtab = id_symtab_map[m_parent_symtab_counter];
        char *m_name;
        m_name = self().read_cstring();
        n_procs = self().read_int64();
        Vec<symbol_t*> v_procs;
        v_procs.reserve(al, n_procs);
        for (size_t i=0; i<n_procs; i++) {
            v_procs.push_back(al, self().read_symbol());
        }
        ASR::accessType m_access = self().deserialize_access();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_GenericProcedure_t(al, loc, m_parent_symtab, m_name, v_procs.p, v_procs.n, m_access);
    }
    asr_t* deserialize_CustomOperator() {
        size_t n_procs; // Sequence
        uint64_t m_parent_symtab_counter = self().read_int64();
        LFORTRAN_ASSERT(id_symtab_map.find(m_parent_symtab_counter) != id_symtab_map.end());
        SymbolTable *m_parent_symtab = id_symtab_map[m_parent_symtab_counter];
        char *m_name;
        m_name = self().read_cstring();
        n_procs = self().read_int64();
        Vec<symbol_t*> v_procs;
        v_procs.reserve(al, n_procs);
        for (size_t i=0; i<n_procs; i++) {
            v_procs.push_back(al, self().read_symbol());
        }
        ASR::accessType m_access = self().deserialize_access();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_CustomOperator_t(al, loc, m_parent_symtab, m_name, v_procs.p, v_procs.n, m_access);
    }
    asr_t* deserialize_ExternalSymbol() {
        size_t n_scope_names; // Sequence
        uint64_t m_parent_symtab_counter = self().read_int64();
        LFORTRAN_ASSERT(id_symtab_map.find(m_parent_symtab_counter) != id_symtab_map.end());
        SymbolTable *m_parent_symtab = id_symtab_map[m_parent_symtab_counter];
        char *m_name;
        m_name = self().read_cstring();
        ASR::symbol_t *m_external;
        // We skip the symbol for ExternalSymbol
        m_external = nullptr;
        char *m_module_name;
        m_module_name = self().read_cstring();
        n_scope_names = self().read_int64();
        Vec<char*> v_scope_names;
        v_scope_names.reserve(al, n_scope_names);
        for (size_t i=0; i<n_scope_names; i++) {
            v_scope_names.push_back(al, self().read_cstring());
        }
        char *m_original_name;
        m_original_name = self().read_cstring();
        ASR::accessType m_access = self().deserialize_access();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_ExternalSymbol_t(al, loc, m_parent_symtab, m_name, m_external, m_module_name, v_scope_names.p, v_scope_names.n, m_original_name, m_access);
    }
    asr_t* deserialize_DerivedType() {
        size_t n_members; // Sequence
        uint64_t m_symtab_counter = self().read_int64();
        LFORTRAN_ASSERT(id_symtab_map.find(m_symtab_counter) == id_symtab_map.end());
        SymbolTable *m_symtab = al.make_new<SymbolTable>(nullptr);
        if (load_symtab_id) m_symtab->counter = m_symtab_counter;
        id_symtab_map[m_symtab_counter] = m_symtab;
        {
            size_t n = self().read_int64();
            for (size_t i=0; i<n; i++) {
                std::string name = self().read_string();
                symbol_t *sym = down_cast<symbol_t>(deserialize_symbol());
                self().symtab_insert_symbol(*m_symtab, name, sym);
            }
        }
        char *m_name;
        m_name = self().read_cstring();
        n_members = self().read_int64();
        Vec<char*> v_members;
        v_members.reserve(al, n_members);
        for (size_t i=0; i<n_members; i++) {
            v_members.push_back(al, self().read_cstring());
        }
        ASR::abiType m_abi = self().deserialize_abi();
        ASR::accessType m_access = self().deserialize_access();
        ASR::symbol_t *m_parent;
        if (self().read_bool()) {
        m_parent = self().read_symbol();
        } else {
        m_parent = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_DerivedType_t(al, loc, m_symtab, m_name, v_members.p, v_members.n, m_abi, m_access, m_parent);
    }
    asr_t* deserialize_Variable() {
        uint64_t m_parent_symtab_counter = self().read_int64();
        LFORTRAN_ASSERT(id_symtab_map.find(m_parent_symtab_counter) != id_symtab_map.end());
        SymbolTable *m_parent_symtab = id_symtab_map[m_parent_symtab_counter];
        char *m_name;
        m_name = self().read_cstring();
        ASR::intentType m_intent = self().deserialize_intent();
        ASR::expr_t *m_symbolic_value;
        if (self().read_bool()) {
        m_symbolic_value = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_symbolic_value = nullptr;
        }
        ASR::expr_t *m_value;
        if (self().read_bool()) {
        m_value = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_value = nullptr;
        }
        ASR::storage_typeType m_storage = self().deserialize_storage_type();
        ASR::ttype_t *m_type;
        m_type = ASR::down_cast<ASR::ttype_t>(self().deserialize_ttype());
        ASR::abiType m_abi = self().deserialize_abi();
        ASR::accessType m_access = self().deserialize_access();
        ASR::presenceType m_presence = self().deserialize_presence();
        bool m_value_attr = self().read_bool();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Variable_t(al, loc, m_parent_symtab, m_name, m_intent, m_symbolic_value, m_value, m_storage, m_type, m_abi, m_access, m_presence, m_value_attr);
    }
    asr_t* deserialize_ClassType() {
        uint64_t m_symtab_counter = self().read_int64();
        LFORTRAN_ASSERT(id_symtab_map.find(m_symtab_counter) == id_symtab_map.end());
        SymbolTable *m_symtab = al.make_new<SymbolTable>(nullptr);
        if (load_symtab_id) m_symtab->counter = m_symtab_counter;
        id_symtab_map[m_symtab_counter] = m_symtab;
        {
            size_t n = self().read_int64();
            for (size_t i=0; i<n; i++) {
                std::string name = self().read_string();
                symbol_t *sym = down_cast<symbol_t>(deserialize_symbol());
                self().symtab_insert_symbol(*m_symtab, name, sym);
            }
        }
        char *m_name;
        m_name = self().read_cstring();
        ASR::abiType m_abi = self().deserialize_abi();
        ASR::accessType m_access = self().deserialize_access();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_ClassType_t(al, loc, m_symtab, m_name, m_abi, m_access);
    }
    asr_t* deserialize_ClassProcedure() {
        uint64_t m_parent_symtab_counter = self().read_int64();
        LFORTRAN_ASSERT(id_symtab_map.find(m_parent_symtab_counter) != id_symtab_map.end());
        SymbolTable *m_parent_symtab = id_symtab_map[m_parent_symtab_counter];
        char *m_name;
        m_name = self().read_cstring();
        char *m_proc_name;
        m_proc_name = self().read_cstring();
        ASR::symbol_t *m_proc;
        m_proc = self().read_symbol();
        ASR::abiType m_abi = self().deserialize_abi();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_ClassProcedure_t(al, loc, m_parent_symtab, m_name, m_proc_name, m_proc, m_abi);
    }
    asr_t* deserialize_symbol() {
        uint8_t t = self().read_int8();
        ASR::symbolType ty = static_cast<ASR::symbolType>(t);
        switch (ty) {
            case (ASR::symbolType::Program) : return self().deserialize_Program();
            case (ASR::symbolType::Module) : return self().deserialize_Module();
            case (ASR::symbolType::Subroutine) : return self().deserialize_Subroutine();
            case (ASR::symbolType::Function) : return self().deserialize_Function();
            case (ASR::symbolType::GenericProcedure) : return self().deserialize_GenericProcedure();
            case (ASR::symbolType::CustomOperator) : return self().deserialize_CustomOperator();
            case (ASR::symbolType::ExternalSymbol) : return self().deserialize_ExternalSymbol();
            case (ASR::symbolType::DerivedType) : return self().deserialize_DerivedType();
            case (ASR::symbolType::Variable) : return self().deserialize_Variable();
            case (ASR::symbolType::ClassType) : return self().deserialize_ClassType();
            case (ASR::symbolType::ClassProcedure) : return self().deserialize_ClassProcedure();
            default : throw LFortranException("Unknown type in deserialize_symbol()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    storage_typeType deserialize_storage_type() {
        uint8_t t = self().read_int8();
        storage_typeType ty = static_cast<storage_typeType>(t);
        return ty;
    }
    accessType deserialize_access() {
        uint8_t t = self().read_int8();
        accessType ty = static_cast<accessType>(t);
        return ty;
    }
    intentType deserialize_intent() {
        uint8_t t = self().read_int8();
        intentType ty = static_cast<intentType>(t);
        return ty;
    }
    deftypeType deserialize_deftype() {
        uint8_t t = self().read_int8();
        deftypeType ty = static_cast<deftypeType>(t);
        return ty;
    }
    presenceType deserialize_presence() {
        uint8_t t = self().read_int8();
        presenceType ty = static_cast<presenceType>(t);
        return ty;
    }
    abiType deserialize_abi() {
        uint8_t t = self().read_int8();
        abiType ty = static_cast<abiType>(t);
        return ty;
    }
    asr_t* deserialize_Allocate() {
        size_t n_args; // Sequence
        n_args = self().read_int64();
        Vec<alloc_arg_t> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, self().deserialize_alloc_arg());
        }
        ASR::expr_t *m_stat;
        if (self().read_bool()) {
        m_stat = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_stat = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Allocate_t(al, loc, v_args.p, v_args.n, m_stat);
    }
    asr_t* deserialize_Assign() {
        int64_t m_label = self().read_int64();
        char *m_variable;
        m_variable = self().read_cstring();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Assign_t(al, loc, m_label, m_variable);
    }
    asr_t* deserialize_Assignment() {
        ASR::expr_t *m_target;
        m_target = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        ASR::expr_t *m_value;
        m_value = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        ASR::stmt_t *m_overloaded;
        if (self().read_bool()) {
        m_overloaded = ASR::down_cast<ASR::stmt_t>(self().deserialize_stmt());
        } else {
        m_overloaded = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Assignment_t(al, loc, m_target, m_value, m_overloaded);
    }
    asr_t* deserialize_Associate() {
        ASR::expr_t *m_target;
        m_target = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        ASR::expr_t *m_value;
        m_value = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Associate_t(al, loc, m_target, m_value);
    }
    asr_t* deserialize_Cycle() {
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Cycle_t(al, loc);
    }
    asr_t* deserialize_ExplicitDeallocate() {
        size_t n_vars; // Sequence
        n_vars = self().read_int64();
        Vec<symbol_t*> v_vars;
        v_vars.reserve(al, n_vars);
        for (size_t i=0; i<n_vars; i++) {
            v_vars.push_back(al, self().read_symbol());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_ExplicitDeallocate_t(al, loc, v_vars.p, v_vars.n);
    }
    asr_t* deserialize_ImplicitDeallocate() {
        size_t n_vars; // Sequence
        n_vars = self().read_int64();
        Vec<symbol_t*> v_vars;
        v_vars.reserve(al, n_vars);
        for (size_t i=0; i<n_vars; i++) {
            v_vars.push_back(al, self().read_symbol());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_ImplicitDeallocate_t(al, loc, v_vars.p, v_vars.n);
    }
    asr_t* deserialize_DoConcurrentLoop() {
        size_t n_body; // Sequence
        ASR::do_loop_head_t m_head = self().deserialize_do_loop_head();
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, ASR::down_cast<ASR::stmt_t>(self().deserialize_stmt()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_DoConcurrentLoop_t(al, loc, m_head, v_body.p, v_body.n);
    }
    asr_t* deserialize_DoLoop() {
        size_t n_body; // Sequence
        ASR::do_loop_head_t m_head = self().deserialize_do_loop_head();
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, ASR::down_cast<ASR::stmt_t>(self().deserialize_stmt()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_DoLoop_t(al, loc, m_head, v_body.p, v_body.n);
    }
    asr_t* deserialize_ErrorStop() {
        ASR::expr_t *m_code;
        if (self().read_bool()) {
        m_code = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_code = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_ErrorStop_t(al, loc, m_code);
    }
    asr_t* deserialize_Exit() {
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Exit_t(al, loc);
    }
    asr_t* deserialize_ForAllSingle() {
        ASR::do_loop_head_t m_head = self().deserialize_do_loop_head();
        ASR::stmt_t *m_assign_stmt;
        m_assign_stmt = ASR::down_cast<ASR::stmt_t>(self().deserialize_stmt());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_ForAllSingle_t(al, loc, m_head, m_assign_stmt);
    }
    asr_t* deserialize_GoTo() {
        int64_t m_target_id = self().read_int64();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_GoTo_t(al, loc, m_target_id);
    }
    asr_t* deserialize_GoToTarget() {
        int64_t m_id = self().read_int64();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_GoToTarget_t(al, loc, m_id);
    }
    asr_t* deserialize_If() {
        size_t n_body; // Sequence
        size_t n_orelse; // Sequence
        ASR::expr_t *m_test;
        m_test = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, ASR::down_cast<ASR::stmt_t>(self().deserialize_stmt()));
        }
        n_orelse = self().read_int64();
        Vec<stmt_t*> v_orelse;
        v_orelse.reserve(al, n_orelse);
        for (size_t i=0; i<n_orelse; i++) {
            v_orelse.push_back(al, ASR::down_cast<ASR::stmt_t>(self().deserialize_stmt()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_If_t(al, loc, m_test, v_body.p, v_body.n, v_orelse.p, v_orelse.n);
    }
    asr_t* deserialize_IfArithmetic() {
        ASR::expr_t *m_test;
        m_test = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        int64_t m_lt_label = self().read_int64();
        int64_t m_eq_label = self().read_int64();
        int64_t m_gt_label = self().read_int64();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_IfArithmetic_t(al, loc, m_test, m_lt_label, m_eq_label, m_gt_label);
    }
    asr_t* deserialize_Print() {
        size_t n_values; // Sequence
        ASR::expr_t *m_fmt;
        if (self().read_bool()) {
        m_fmt = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_fmt = nullptr;
        }
        n_values = self().read_int64();
        Vec<expr_t*> v_values;
        v_values.reserve(al, n_values);
        for (size_t i=0; i<n_values; i++) {
            v_values.push_back(al, ASR::down_cast<ASR::expr_t>(self().deserialize_expr()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Print_t(al, loc, m_fmt, v_values.p, v_values.n);
    }
    asr_t* deserialize_Open() {
        int64_t m_label = self().read_int64();
        ASR::expr_t *m_newunit;
        if (self().read_bool()) {
        m_newunit = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_newunit = nullptr;
        }
        ASR::expr_t *m_filename;
        if (self().read_bool()) {
        m_filename = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_filename = nullptr;
        }
        ASR::expr_t *m_status;
        if (self().read_bool()) {
        m_status = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_status = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Open_t(al, loc, m_label, m_newunit, m_filename, m_status);
    }
    asr_t* deserialize_Close() {
        int64_t m_label = self().read_int64();
        ASR::expr_t *m_unit;
        if (self().read_bool()) {
        m_unit = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_unit = nullptr;
        }
        ASR::expr_t *m_iostat;
        if (self().read_bool()) {
        m_iostat = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_iostat = nullptr;
        }
        ASR::expr_t *m_iomsg;
        if (self().read_bool()) {
        m_iomsg = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_iomsg = nullptr;
        }
        ASR::expr_t *m_err;
        if (self().read_bool()) {
        m_err = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_err = nullptr;
        }
        ASR::expr_t *m_status;
        if (self().read_bool()) {
        m_status = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_status = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Close_t(al, loc, m_label, m_unit, m_iostat, m_iomsg, m_err, m_status);
    }
    asr_t* deserialize_Read() {
        size_t n_values; // Sequence
        int64_t m_label = self().read_int64();
        ASR::expr_t *m_unit;
        if (self().read_bool()) {
        m_unit = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_unit = nullptr;
        }
        ASR::expr_t *m_fmt;
        if (self().read_bool()) {
        m_fmt = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_fmt = nullptr;
        }
        ASR::expr_t *m_iomsg;
        if (self().read_bool()) {
        m_iomsg = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_iomsg = nullptr;
        }
        ASR::expr_t *m_iostat;
        if (self().read_bool()) {
        m_iostat = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_iostat = nullptr;
        }
        ASR::expr_t *m_id;
        if (self().read_bool()) {
        m_id = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_id = nullptr;
        }
        n_values = self().read_int64();
        Vec<expr_t*> v_values;
        v_values.reserve(al, n_values);
        for (size_t i=0; i<n_values; i++) {
            v_values.push_back(al, ASR::down_cast<ASR::expr_t>(self().deserialize_expr()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Read_t(al, loc, m_label, m_unit, m_fmt, m_iomsg, m_iostat, m_id, v_values.p, v_values.n);
    }
    asr_t* deserialize_Write() {
        size_t n_values; // Sequence
        int64_t m_label = self().read_int64();
        ASR::expr_t *m_unit;
        if (self().read_bool()) {
        m_unit = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_unit = nullptr;
        }
        ASR::expr_t *m_fmt;
        if (self().read_bool()) {
        m_fmt = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_fmt = nullptr;
        }
        ASR::expr_t *m_iomsg;
        if (self().read_bool()) {
        m_iomsg = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_iomsg = nullptr;
        }
        ASR::expr_t *m_iostat;
        if (self().read_bool()) {
        m_iostat = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_iostat = nullptr;
        }
        ASR::expr_t *m_id;
        if (self().read_bool()) {
        m_id = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_id = nullptr;
        }
        n_values = self().read_int64();
        Vec<expr_t*> v_values;
        v_values.reserve(al, n_values);
        for (size_t i=0; i<n_values; i++) {
            v_values.push_back(al, ASR::down_cast<ASR::expr_t>(self().deserialize_expr()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Write_t(al, loc, m_label, m_unit, m_fmt, m_iomsg, m_iostat, m_id, v_values.p, v_values.n);
    }
    asr_t* deserialize_Return() {
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Return_t(al, loc);
    }
    asr_t* deserialize_Select() {
        size_t n_body; // Sequence
        size_t n_default; // Sequence
        ASR::expr_t *m_test;
        m_test = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        n_body = self().read_int64();
        Vec<case_stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, ASR::down_cast<ASR::case_stmt_t>(self().deserialize_case_stmt()));
        }
        n_default = self().read_int64();
        Vec<stmt_t*> v_default;
        v_default.reserve(al, n_default);
        for (size_t i=0; i<n_default; i++) {
            v_default.push_back(al, ASR::down_cast<ASR::stmt_t>(self().deserialize_stmt()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Select_t(al, loc, m_test, v_body.p, v_body.n, v_default.p, v_default.n);
    }
    asr_t* deserialize_Stop() {
        ASR::expr_t *m_code;
        if (self().read_bool()) {
        m_code = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_code = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Stop_t(al, loc, m_code);
    }
    asr_t* deserialize_SubroutineCall() {
        size_t n_args; // Sequence
        ASR::symbol_t *m_name;
        m_name = self().read_symbol();
        ASR::symbol_t *m_original_name;
        if (self().read_bool()) {
        m_original_name = self().read_symbol();
        } else {
        m_original_name = nullptr;
        }
        n_args = self().read_int64();
        Vec<expr_t*> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, ASR::down_cast<ASR::expr_t>(self().deserialize_expr()));
        }
        ASR::expr_t *m_dt;
        if (self().read_bool()) {
        m_dt = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_dt = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_SubroutineCall_t(al, loc, m_name, m_original_name, v_args.p, v_args.n, m_dt);
    }
    asr_t* deserialize_Where() {
        size_t n_body; // Sequence
        size_t n_orelse; // Sequence
        ASR::expr_t *m_test;
        m_test = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, ASR::down_cast<ASR::stmt_t>(self().deserialize_stmt()));
        }
        n_orelse = self().read_int64();
        Vec<stmt_t*> v_orelse;
        v_orelse.reserve(al, n_orelse);
        for (size_t i=0; i<n_orelse; i++) {
            v_orelse.push_back(al, ASR::down_cast<ASR::stmt_t>(self().deserialize_stmt()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Where_t(al, loc, m_test, v_body.p, v_body.n, v_orelse.p, v_orelse.n);
    }
    asr_t* deserialize_WhileLoop() {
        size_t n_body; // Sequence
        ASR::expr_t *m_test;
        m_test = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, ASR::down_cast<ASR::stmt_t>(self().deserialize_stmt()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_WhileLoop_t(al, loc, m_test, v_body.p, v_body.n);
    }
    asr_t* deserialize_stmt() {
        uint8_t t = self().read_int8();
        ASR::stmtType ty = static_cast<ASR::stmtType>(t);
        switch (ty) {
            case (ASR::stmtType::Allocate) : return self().deserialize_Allocate();
            case (ASR::stmtType::Assign) : return self().deserialize_Assign();
            case (ASR::stmtType::Assignment) : return self().deserialize_Assignment();
            case (ASR::stmtType::Associate) : return self().deserialize_Associate();
            case (ASR::stmtType::Cycle) : return self().deserialize_Cycle();
            case (ASR::stmtType::ExplicitDeallocate) : return self().deserialize_ExplicitDeallocate();
            case (ASR::stmtType::ImplicitDeallocate) : return self().deserialize_ImplicitDeallocate();
            case (ASR::stmtType::DoConcurrentLoop) : return self().deserialize_DoConcurrentLoop();
            case (ASR::stmtType::DoLoop) : return self().deserialize_DoLoop();
            case (ASR::stmtType::ErrorStop) : return self().deserialize_ErrorStop();
            case (ASR::stmtType::Exit) : return self().deserialize_Exit();
            case (ASR::stmtType::ForAllSingle) : return self().deserialize_ForAllSingle();
            case (ASR::stmtType::GoTo) : return self().deserialize_GoTo();
            case (ASR::stmtType::GoToTarget) : return self().deserialize_GoToTarget();
            case (ASR::stmtType::If) : return self().deserialize_If();
            case (ASR::stmtType::IfArithmetic) : return self().deserialize_IfArithmetic();
            case (ASR::stmtType::Print) : return self().deserialize_Print();
            case (ASR::stmtType::Open) : return self().deserialize_Open();
            case (ASR::stmtType::Close) : return self().deserialize_Close();
            case (ASR::stmtType::Read) : return self().deserialize_Read();
            case (ASR::stmtType::Write) : return self().deserialize_Write();
            case (ASR::stmtType::Return) : return self().deserialize_Return();
            case (ASR::stmtType::Select) : return self().deserialize_Select();
            case (ASR::stmtType::Stop) : return self().deserialize_Stop();
            case (ASR::stmtType::SubroutineCall) : return self().deserialize_SubroutineCall();
            case (ASR::stmtType::Where) : return self().deserialize_Where();
            case (ASR::stmtType::WhileLoop) : return self().deserialize_WhileLoop();
            default : throw LFortranException("Unknown type in deserialize_stmt()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    asr_t* deserialize_BoolOp() {
        ASR::expr_t *m_left;
        m_left = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        ASR::boolopType m_op = self().deserialize_boolop();
        ASR::expr_t *m_right;
        m_right = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        ASR::ttype_t *m_type;
        m_type = ASR::down_cast<ASR::ttype_t>(self().deserialize_ttype());
        ASR::expr_t *m_value;
        if (self().read_bool()) {
        m_value = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_value = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_BoolOp_t(al, loc, m_left, m_op, m_right, m_type, m_value);
    }
    asr_t* deserialize_BinOp() {
        ASR::expr_t *m_left;
        m_left = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        ASR::binopType m_op = self().deserialize_binop();
        ASR::expr_t *m_right;
        m_right = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        ASR::ttype_t *m_type;
        m_type = ASR::down_cast<ASR::ttype_t>(self().deserialize_ttype());
        ASR::expr_t *m_value;
        if (self().read_bool()) {
        m_value = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_value = nullptr;
        }
        ASR::expr_t *m_overloaded;
        if (self().read_bool()) {
        m_overloaded = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_overloaded = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_BinOp_t(al, loc, m_left, m_op, m_right, m_type, m_value, m_overloaded);
    }
    asr_t* deserialize_StrOp() {
        ASR::expr_t *m_left;
        m_left = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        ASR::stropType m_op = self().deserialize_strop();
        ASR::expr_t *m_right;
        m_right = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        ASR::ttype_t *m_type;
        m_type = ASR::down_cast<ASR::ttype_t>(self().deserialize_ttype());
        ASR::expr_t *m_value;
        if (self().read_bool()) {
        m_value = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_value = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_StrOp_t(al, loc, m_left, m_op, m_right, m_type, m_value);
    }
    asr_t* deserialize_UnaryOp() {
        ASR::unaryopType m_op = self().deserialize_unaryop();
        ASR::expr_t *m_operand;
        m_operand = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        ASR::ttype_t *m_type;
        m_type = ASR::down_cast<ASR::ttype_t>(self().deserialize_ttype());
        ASR::expr_t *m_value;
        if (self().read_bool()) {
        m_value = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_value = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_UnaryOp_t(al, loc, m_op, m_operand, m_type, m_value);
    }
    asr_t* deserialize_ComplexConstructor() {
        ASR::expr_t *m_re;
        m_re = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        ASR::expr_t *m_im;
        m_im = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        ASR::ttype_t *m_type;
        m_type = ASR::down_cast<ASR::ttype_t>(self().deserialize_ttype());
        ASR::expr_t *m_value;
        if (self().read_bool()) {
        m_value = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_value = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_ComplexConstructor_t(al, loc, m_re, m_im, m_type, m_value);
    }
    asr_t* deserialize_Compare() {
        ASR::expr_t *m_left;
        m_left = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        ASR::cmpopType m_op = self().deserialize_cmpop();
        ASR::expr_t *m_right;
        m_right = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        ASR::ttype_t *m_type;
        m_type = ASR::down_cast<ASR::ttype_t>(self().deserialize_ttype());
        ASR::expr_t *m_value;
        if (self().read_bool()) {
        m_value = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_value = nullptr;
        }
        ASR::expr_t *m_overloaded;
        if (self().read_bool()) {
        m_overloaded = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_overloaded = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Compare_t(al, loc, m_left, m_op, m_right, m_type, m_value, m_overloaded);
    }
    asr_t* deserialize_FunctionCall() {
        size_t n_args; // Sequence
        size_t n_keywords; // Sequence
        ASR::symbol_t *m_name;
        m_name = self().read_symbol();
        ASR::symbol_t *m_original_name;
        if (self().read_bool()) {
        m_original_name = self().read_symbol();
        } else {
        m_original_name = nullptr;
        }
        n_args = self().read_int64();
        Vec<expr_t*> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, ASR::down_cast<ASR::expr_t>(self().deserialize_expr()));
        }
        n_keywords = self().read_int64();
        Vec<keyword_t> v_keywords;
        v_keywords.reserve(al, n_keywords);
        for (size_t i=0; i<n_keywords; i++) {
            v_keywords.push_back(al, self().deserialize_keyword());
        }
        ASR::ttype_t *m_type;
        m_type = ASR::down_cast<ASR::ttype_t>(self().deserialize_ttype());
        ASR::expr_t *m_value;
        if (self().read_bool()) {
        m_value = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_value = nullptr;
        }
        ASR::expr_t *m_dt;
        if (self().read_bool()) {
        m_dt = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_dt = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_FunctionCall_t(al, loc, m_name, m_original_name, v_args.p, v_args.n, v_keywords.p, v_keywords.n, m_type, m_value, m_dt);
    }
    asr_t* deserialize_DerivedTypeConstructor() {
        size_t n_args; // Sequence
        ASR::symbol_t *m_dt_sym;
        m_dt_sym = self().read_symbol();
        n_args = self().read_int64();
        Vec<expr_t*> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, ASR::down_cast<ASR::expr_t>(self().deserialize_expr()));
        }
        ASR::ttype_t *m_type;
        m_type = ASR::down_cast<ASR::ttype_t>(self().deserialize_ttype());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_DerivedTypeConstructor_t(al, loc, m_dt_sym, v_args.p, v_args.n, m_type);
    }
    asr_t* deserialize_ConstantArray() {
        size_t n_args; // Sequence
        n_args = self().read_int64();
        Vec<expr_t*> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, ASR::down_cast<ASR::expr_t>(self().deserialize_expr()));
        }
        ASR::ttype_t *m_type;
        m_type = ASR::down_cast<ASR::ttype_t>(self().deserialize_ttype());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_ConstantArray_t(al, loc, v_args.p, v_args.n, m_type);
    }
    asr_t* deserialize_ImpliedDoLoop() {
        size_t n_values; // Sequence
        n_values = self().read_int64();
        Vec<expr_t*> v_values;
        v_values.reserve(al, n_values);
        for (size_t i=0; i<n_values; i++) {
            v_values.push_back(al, ASR::down_cast<ASR::expr_t>(self().deserialize_expr()));
        }
        ASR::expr_t *m_var;
        m_var = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        ASR::expr_t *m_start;
        m_start = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        ASR::expr_t *m_end;
        m_end = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        ASR::expr_t *m_increment;
        if (self().read_bool()) {
        m_increment = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_increment = nullptr;
        }
        ASR::ttype_t *m_type;
        m_type = ASR::down_cast<ASR::ttype_t>(self().deserialize_ttype());
        ASR::expr_t *m_value;
        if (self().read_bool()) {
        m_value = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_value = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_ImpliedDoLoop_t(al, loc, v_values.p, v_values.n, m_var, m_start, m_end, m_increment, m_type, m_value);
    }
    asr_t* deserialize_ConstantInteger() {
        int64_t m_n = self().read_int64();
        ASR::ttype_t *m_type;
        m_type = ASR::down_cast<ASR::ttype_t>(self().deserialize_ttype());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_ConstantInteger_t(al, loc, m_n, m_type);
    }
    asr_t* deserialize_ConstantReal() {
        double m_r = self().read_float64();
        ASR::ttype_t *m_type;
        m_type = ASR::down_cast<ASR::ttype_t>(self().deserialize_ttype());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_ConstantReal_t(al, loc, m_r, m_type);
    }
    asr_t* deserialize_ConstantComplex() {
        double m_re = self().read_float64();
        double m_im = self().read_float64();
        ASR::ttype_t *m_type;
        m_type = ASR::down_cast<ASR::ttype_t>(self().deserialize_ttype());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_ConstantComplex_t(al, loc, m_re, m_im, m_type);
    }
    asr_t* deserialize_ConstantLogical() {
        bool m_value = self().read_bool();
        ASR::ttype_t *m_type;
        m_type = ASR::down_cast<ASR::ttype_t>(self().deserialize_ttype());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_ConstantLogical_t(al, loc, m_value, m_type);
    }
    asr_t* deserialize_ConstantString() {
        char *m_s;
        m_s = self().read_cstring();
        ASR::ttype_t *m_type;
        m_type = ASR::down_cast<ASR::ttype_t>(self().deserialize_ttype());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_ConstantString_t(al, loc, m_s, m_type);
    }
    asr_t* deserialize_BOZ() {
        int64_t m_v = self().read_int64();
        ASR::bozType m_boz_type = self().deserialize_boz();
        ASR::ttype_t *m_type;
        if (self().read_bool()) {
        m_type = ASR::down_cast<ASR::ttype_t>(self().deserialize_ttype());
        } else {
        m_type = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_BOZ_t(al, loc, m_v, m_boz_type, m_type);
    }
    asr_t* deserialize_Var() {
        ASR::symbol_t *m_v;
        m_v = self().read_symbol();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Var_t(al, loc, m_v);
    }
    asr_t* deserialize_ArrayRef() {
        size_t n_args; // Sequence
        ASR::symbol_t *m_v;
        m_v = self().read_symbol();
        n_args = self().read_int64();
        Vec<array_index_t> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, self().deserialize_array_index());
        }
        ASR::ttype_t *m_type;
        m_type = ASR::down_cast<ASR::ttype_t>(self().deserialize_ttype());
        ASR::expr_t *m_value;
        if (self().read_bool()) {
        m_value = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_value = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_ArrayRef_t(al, loc, m_v, v_args.p, v_args.n, m_type, m_value);
    }
    asr_t* deserialize_DerivedRef() {
        ASR::expr_t *m_v;
        m_v = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        ASR::symbol_t *m_m;
        m_m = self().read_symbol();
        ASR::ttype_t *m_type;
        m_type = ASR::down_cast<ASR::ttype_t>(self().deserialize_ttype());
        ASR::expr_t *m_value;
        if (self().read_bool()) {
        m_value = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_value = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_DerivedRef_t(al, loc, m_v, m_m, m_type, m_value);
    }
    asr_t* deserialize_ImplicitCast() {
        ASR::expr_t *m_arg;
        m_arg = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        ASR::cast_kindType m_kind = self().deserialize_cast_kind();
        ASR::ttype_t *m_type;
        m_type = ASR::down_cast<ASR::ttype_t>(self().deserialize_ttype());
        ASR::expr_t *m_value;
        if (self().read_bool()) {
        m_value = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_value = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_ImplicitCast_t(al, loc, m_arg, m_kind, m_type, m_value);
    }
    asr_t* deserialize_ExplicitCast() {
        ASR::expr_t *m_arg;
        m_arg = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        ASR::cast_kindType m_kind = self().deserialize_cast_kind();
        ASR::ttype_t *m_type;
        m_type = ASR::down_cast<ASR::ttype_t>(self().deserialize_ttype());
        ASR::expr_t *m_value;
        if (self().read_bool()) {
        m_value = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_value = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_ExplicitCast_t(al, loc, m_arg, m_kind, m_type, m_value);
    }
    asr_t* deserialize_expr() {
        uint8_t t = self().read_int8();
        ASR::exprType ty = static_cast<ASR::exprType>(t);
        switch (ty) {
            case (ASR::exprType::BoolOp) : return self().deserialize_BoolOp();
            case (ASR::exprType::BinOp) : return self().deserialize_BinOp();
            case (ASR::exprType::StrOp) : return self().deserialize_StrOp();
            case (ASR::exprType::UnaryOp) : return self().deserialize_UnaryOp();
            case (ASR::exprType::ComplexConstructor) : return self().deserialize_ComplexConstructor();
            case (ASR::exprType::Compare) : return self().deserialize_Compare();
            case (ASR::exprType::FunctionCall) : return self().deserialize_FunctionCall();
            case (ASR::exprType::DerivedTypeConstructor) : return self().deserialize_DerivedTypeConstructor();
            case (ASR::exprType::ConstantArray) : return self().deserialize_ConstantArray();
            case (ASR::exprType::ImpliedDoLoop) : return self().deserialize_ImpliedDoLoop();
            case (ASR::exprType::ConstantInteger) : return self().deserialize_ConstantInteger();
            case (ASR::exprType::ConstantReal) : return self().deserialize_ConstantReal();
            case (ASR::exprType::ConstantComplex) : return self().deserialize_ConstantComplex();
            case (ASR::exprType::ConstantLogical) : return self().deserialize_ConstantLogical();
            case (ASR::exprType::ConstantString) : return self().deserialize_ConstantString();
            case (ASR::exprType::BOZ) : return self().deserialize_BOZ();
            case (ASR::exprType::Var) : return self().deserialize_Var();
            case (ASR::exprType::ArrayRef) : return self().deserialize_ArrayRef();
            case (ASR::exprType::DerivedRef) : return self().deserialize_DerivedRef();
            case (ASR::exprType::ImplicitCast) : return self().deserialize_ImplicitCast();
            case (ASR::exprType::ExplicitCast) : return self().deserialize_ExplicitCast();
            default : throw LFortranException("Unknown type in deserialize_expr()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    asr_t* deserialize_Integer() {
        size_t n_dims; // Sequence
        int64_t m_kind = self().read_int64();
        n_dims = self().read_int64();
        Vec<dimension_t> v_dims;
        v_dims.reserve(al, n_dims);
        for (size_t i=0; i<n_dims; i++) {
            v_dims.push_back(al, self().deserialize_dimension());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Integer_t(al, loc, m_kind, v_dims.p, v_dims.n);
    }
    asr_t* deserialize_Real() {
        size_t n_dims; // Sequence
        int64_t m_kind = self().read_int64();
        n_dims = self().read_int64();
        Vec<dimension_t> v_dims;
        v_dims.reserve(al, n_dims);
        for (size_t i=0; i<n_dims; i++) {
            v_dims.push_back(al, self().deserialize_dimension());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Real_t(al, loc, m_kind, v_dims.p, v_dims.n);
    }
    asr_t* deserialize_Complex() {
        size_t n_dims; // Sequence
        int64_t m_kind = self().read_int64();
        n_dims = self().read_int64();
        Vec<dimension_t> v_dims;
        v_dims.reserve(al, n_dims);
        for (size_t i=0; i<n_dims; i++) {
            v_dims.push_back(al, self().deserialize_dimension());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Complex_t(al, loc, m_kind, v_dims.p, v_dims.n);
    }
    asr_t* deserialize_Character() {
        size_t n_dims; // Sequence
        int64_t m_kind = self().read_int64();
        int64_t m_len = self().read_int64();
        ASR::expr_t *m_len_expr;
        if (self().read_bool()) {
        m_len_expr = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_len_expr = nullptr;
        }
        n_dims = self().read_int64();
        Vec<dimension_t> v_dims;
        v_dims.reserve(al, n_dims);
        for (size_t i=0; i<n_dims; i++) {
            v_dims.push_back(al, self().deserialize_dimension());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Character_t(al, loc, m_kind, m_len, m_len_expr, v_dims.p, v_dims.n);
    }
    asr_t* deserialize_Logical() {
        size_t n_dims; // Sequence
        int64_t m_kind = self().read_int64();
        n_dims = self().read_int64();
        Vec<dimension_t> v_dims;
        v_dims.reserve(al, n_dims);
        for (size_t i=0; i<n_dims; i++) {
            v_dims.push_back(al, self().deserialize_dimension());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Logical_t(al, loc, m_kind, v_dims.p, v_dims.n);
    }
    asr_t* deserialize_Derived() {
        size_t n_dims; // Sequence
        ASR::symbol_t *m_derived_type;
        m_derived_type = self().read_symbol();
        n_dims = self().read_int64();
        Vec<dimension_t> v_dims;
        v_dims.reserve(al, n_dims);
        for (size_t i=0; i<n_dims; i++) {
            v_dims.push_back(al, self().deserialize_dimension());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Derived_t(al, loc, m_derived_type, v_dims.p, v_dims.n);
    }
    asr_t* deserialize_Class() {
        size_t n_dims; // Sequence
        ASR::symbol_t *m_class_type;
        m_class_type = self().read_symbol();
        n_dims = self().read_int64();
        Vec<dimension_t> v_dims;
        v_dims.reserve(al, n_dims);
        for (size_t i=0; i<n_dims; i++) {
            v_dims.push_back(al, self().deserialize_dimension());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Class_t(al, loc, m_class_type, v_dims.p, v_dims.n);
    }
    asr_t* deserialize_Pointer() {
        ASR::ttype_t *m_type;
        m_type = ASR::down_cast<ASR::ttype_t>(self().deserialize_ttype());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Pointer_t(al, loc, m_type);
    }
    asr_t* deserialize_ttype() {
        uint8_t t = self().read_int8();
        ASR::ttypeType ty = static_cast<ASR::ttypeType>(t);
        switch (ty) {
            case (ASR::ttypeType::Integer) : return self().deserialize_Integer();
            case (ASR::ttypeType::Real) : return self().deserialize_Real();
            case (ASR::ttypeType::Complex) : return self().deserialize_Complex();
            case (ASR::ttypeType::Character) : return self().deserialize_Character();
            case (ASR::ttypeType::Logical) : return self().deserialize_Logical();
            case (ASR::ttypeType::Derived) : return self().deserialize_Derived();
            case (ASR::ttypeType::Class) : return self().deserialize_Class();
            case (ASR::ttypeType::Pointer) : return self().deserialize_Pointer();
            default : throw LFortranException("Unknown type in deserialize_ttype()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    boolopType deserialize_boolop() {
        uint8_t t = self().read_int8();
        boolopType ty = static_cast<boolopType>(t);
        return ty;
    }
    binopType deserialize_binop() {
        uint8_t t = self().read_int8();
        binopType ty = static_cast<binopType>(t);
        return ty;
    }
    unaryopType deserialize_unaryop() {
        uint8_t t = self().read_int8();
        unaryopType ty = static_cast<unaryopType>(t);
        return ty;
    }
    stropType deserialize_strop() {
        uint8_t t = self().read_int8();
        stropType ty = static_cast<stropType>(t);
        return ty;
    }
    cmpopType deserialize_cmpop() {
        uint8_t t = self().read_int8();
        cmpopType ty = static_cast<cmpopType>(t);
        return ty;
    }
    bozType deserialize_boz() {
        uint8_t t = self().read_int8();
        bozType ty = static_cast<bozType>(t);
        return ty;
    }
    cast_kindType deserialize_cast_kind() {
        uint8_t t = self().read_int8();
        cast_kindType ty = static_cast<cast_kindType>(t);
        return ty;
    }
    dimension_t deserialize_dimension() {
        dimension_t x;
        {
            bool present=self().read_bool();
            if (present) {
                x.m_start = down_cast<expr_t>(deserialize_expr());
            } else {
                x.m_start = nullptr;
            }
        }
        {
            bool present=self().read_bool();
            if (present) {
                x.m_end = down_cast<expr_t>(deserialize_expr());
            } else {
                x.m_end = nullptr;
            }
        }
        return x;
    }
    alloc_arg_t deserialize_alloc_arg() {
        alloc_arg_t x;
        {
                x.m_a = self().read_symbol();
        }
        {
            uint64_t n = self().read_int64();
            Vec<dimension_t> v;
            v.reserve(al, n);
            for (uint64_t i=0; i<n; i++) {
                v.push_back(al, self().deserialize_dimension());
            }
            x.m_dims = v.p;
            x.n_dims = v.n;
        }
        return x;
    }
    asr_t* deserialize_Attribute() {
        size_t n_args; // Sequence
        char *m_name;
        m_name = self().read_cstring();
        n_args = self().read_int64();
        Vec<attribute_arg_t> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, self().deserialize_attribute_arg());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Attribute_t(al, loc, m_name, v_args.p, v_args.n);
    }
    asr_t* deserialize_attribute() {
        uint8_t t = self().read_int8();
        ASR::attributeType ty = static_cast<ASR::attributeType>(t);
        switch (ty) {
            case (ASR::attributeType::Attribute) : return self().deserialize_Attribute();
            default : throw LFortranException("Unknown type in deserialize_attribute()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    attribute_arg_t deserialize_attribute_arg() {
        attribute_arg_t x;
        {
                x.m_arg = self().read_cstring();
        }
        return x;
    }
    arg_t deserialize_arg() {
        arg_t x;
        {
                x.m_arg = self().read_cstring();
        }
        return x;
    }
    keyword_t deserialize_keyword() {
        keyword_t x;
        {
            bool present=self().read_bool();
            if (present) {
                x.m_arg = self().read_cstring();
            } else {
                x.m_arg = nullptr;
            }
        }
        {
                x.m_value = down_cast<expr_t>(deserialize_expr());
        }
        return x;
    }
    asr_t* deserialize_Bind() {
        char *m_lang;
        m_lang = self().read_cstring();
        char *m_name;
        m_name = self().read_cstring();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_Bind_t(al, loc, m_lang, m_name);
    }
    asr_t* deserialize_tbind() {
        uint8_t t = self().read_int8();
        ASR::tbindType ty = static_cast<ASR::tbindType>(t);
        switch (ty) {
            case (ASR::tbindType::Bind) : return self().deserialize_Bind();
            default : throw LFortranException("Unknown type in deserialize_tbind()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    array_index_t deserialize_array_index() {
        array_index_t x;
        {
            bool present=self().read_bool();
            if (present) {
                x.m_left = down_cast<expr_t>(deserialize_expr());
            } else {
                x.m_left = nullptr;
            }
        }
        {
            bool present=self().read_bool();
            if (present) {
                x.m_right = down_cast<expr_t>(deserialize_expr());
            } else {
                x.m_right = nullptr;
            }
        }
        {
            bool present=self().read_bool();
            if (present) {
                x.m_step = down_cast<expr_t>(deserialize_expr());
            } else {
                x.m_step = nullptr;
            }
        }
        return x;
    }
    do_loop_head_t deserialize_do_loop_head() {
        do_loop_head_t x;
        {
                x.m_v = down_cast<expr_t>(deserialize_expr());
        }
        {
                x.m_start = down_cast<expr_t>(deserialize_expr());
        }
        {
                x.m_end = down_cast<expr_t>(deserialize_expr());
        }
        {
            bool present=self().read_bool();
            if (present) {
                x.m_increment = down_cast<expr_t>(deserialize_expr());
            } else {
                x.m_increment = nullptr;
            }
        }
        return x;
    }
    asr_t* deserialize_CaseStmt() {
        size_t n_test; // Sequence
        size_t n_body; // Sequence
        n_test = self().read_int64();
        Vec<expr_t*> v_test;
        v_test.reserve(al, n_test);
        for (size_t i=0; i<n_test; i++) {
            v_test.push_back(al, ASR::down_cast<ASR::expr_t>(self().deserialize_expr()));
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, ASR::down_cast<ASR::stmt_t>(self().deserialize_stmt()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_CaseStmt_t(al, loc, v_test.p, v_test.n, v_body.p, v_body.n);
    }
    asr_t* deserialize_CaseStmt_Range() {
        size_t n_body; // Sequence
        ASR::expr_t *m_start;
        if (self().read_bool()) {
        m_start = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_start = nullptr;
        }
        ASR::expr_t *m_end;
        if (self().read_bool()) {
        m_end = ASR::down_cast<ASR::expr_t>(self().deserialize_expr());
        } else {
        m_end = nullptr;
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, ASR::down_cast<ASR::stmt_t>(self().deserialize_stmt()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return ASR::make_CaseStmt_Range_t(al, loc, m_start, m_end, v_body.p, v_body.n);
    }
    asr_t* deserialize_case_stmt() {
        uint8_t t = self().read_int8();
        ASR::case_stmtType ty = static_cast<ASR::case_stmtType>(t);
        switch (ty) {
            case (ASR::case_stmtType::CaseStmt) : return self().deserialize_CaseStmt();
            case (ASR::case_stmtType::CaseStmt_Range) : return self().deserialize_CaseStmt_Range();
            default : throw LFortranException("Unknown type in deserialize_case_stmt()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
};


} // namespace LFortran::ASR

#endif // LFORTRAN_ASR_H
