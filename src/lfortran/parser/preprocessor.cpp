/* Generated by re2c 2.2 on Mon Dec 27 15:02:02 2021 */
#line 1 "preprocessor.re"
#include <iostream>
#include <map>

#include <lfortran/parser/preprocessor.h>
#include <lfortran/assert.h>
#include <lfortran/utils.h>
#include <lfortran/string_utils.h>

namespace LFortran
{

CPreprocessor::CPreprocessor(CompilerOptions &compiler_options)
    : compiler_options{compiler_options} {
    CPPMacro md;
    md.expansion = "1";
    macro_definitions["__LFORTRAN__"] = md;
    md.expansion = "\"" + std::string(LFORTRAN_VERSION) + "\"";
    macro_definitions["__VERSION__"] = md;
    if (compiler_options.platform == Platform::Windows) {
        md.expansion = "1";
        macro_definitions["_WIN32"] = md;
    }
    for (auto &d : compiler_options.c_preprocessor_defines) {
        std::size_t idx = d.find("=");
        if (idx != std::string::npos) {
            md.expansion = d.substr(idx+1);
            d = d.substr(0, idx);
        } else {
            md.expansion = "1";
        }
        macro_definitions[d] = md;
    }

    md.expansion = "\"\"";
    macro_definitions["__FILE__"] = md;
    md.expansion = "0";
    macro_definitions["__LINE__"] = md;
}
std::string CPreprocessor::token(unsigned char *tok, unsigned char* cur) const
{
    return std::string((char *)tok, cur - tok);
}

void handle_continuation_lines(std::string &s, unsigned char *&cur);

std::string parse_continuation_lines(unsigned char *&cur) {
    std::string output;
    while (*cur != '\n') {
        output += *cur;
        cur++;
    }
    cur++;
    handle_continuation_lines(output, cur);
    return output;
}

void handle_continuation_lines(std::string &s, unsigned char *&cur) {
    if (s.size() > 0 && s[s.size()-1] == '\\') {
        s = s.substr(0, s.size()-1);
        s += parse_continuation_lines(cur);
    }
}

// Parse a macro declaration argument, e.g. in:
// f(a,b, c,  d  )
std::string parse_argument(unsigned char *&cur) {
    std::string arg;
    while (*cur == ' ' && *cur != '\0') cur++;
    while (*cur != ')' && *cur != ',' && *cur != ' ') {
        if (*cur == '\0') {
            throw LFortranException("C preprocessor: runaway argument");
        }
        arg += *cur;
        cur++;
    }
    while (*cur == ' ' && *cur != '\0') cur++;
    if (*cur == '\0') {
        throw LFortranException("C preprocessor: runaway argument");
    }
    return arg;
}

std::string match_parentheses(unsigned char *&cur) {
    LFORTRAN_ASSERT(*cur == '(')
    std::string arg;
    arg += *cur;
    cur++;
    while (*cur != ')') {
        if (*cur == '\0') {
            throw LFortranException("C preprocessor: unmatched parentheses");
        }
        if (*cur == '(') {
            arg += match_parentheses(cur);
            LFORTRAN_ASSERT(*cur == ')')
        } else {
            arg += *cur;
        }
        cur++;
    }
    arg += *cur;
    return arg;
}

// Parse a macro call argument, e.g. in:
// ASSERT(fn(3, 5))
std::string parse_argument2(unsigned char *&cur) {
    std::string arg;
    while (*cur != ')' && *cur != ',') {
        if (*cur == '\0') {
            throw LFortranException("C preprocessor: runaway argument");
        }
        if (*cur == '(') {
            arg += match_parentheses(cur);
            LFORTRAN_ASSERT(*cur == ')')
        } else {
            arg += *cur;
        }
        cur++;
    }
    return arg;
}

std::vector<std::string> parse_arguments(unsigned char *&cur, bool skip_spaces) {
    std::vector<std::string> args;
    LFORTRAN_ASSERT(*cur == '(');
    cur++;
    while (*cur != ')') {
        if (skip_spaces) {
            args.push_back(parse_argument(cur));
        } else {
            args.push_back(parse_argument2(cur));
        }
        if (*cur == ',') cur++;
    }
    return args;
}

void get_newlines(const std::string &s, std::vector<uint32_t> &newlines) {
    for (uint32_t pos=0; pos < s.size(); pos++) {
        if (s[pos] == '\n') newlines.push_back(pos);
    }
}

void interval_end(LocationManager &lm, size_t output_len,
                size_t input_len, size_t input_interval_len,
                uint32_t interval_type) {
    lm.out_start0.push_back(output_len);
    lm.in_start0.push_back(input_len);
    lm.in_size0.push_back(input_interval_len);
    lm.interval_type0.push_back(interval_type);
}

void interval_end_type_0(LocationManager &lm, size_t output_len,
                size_t input_len) {
    size_t input_interval_len = output_len-lm.out_start0[lm.out_start0.size()-1];
    interval_end(lm, output_len, input_len, input_interval_len, 0);
}

struct IfDef {
    bool active=true;
    bool branch_enabled=true;
};

namespace {

int parse_bexpr(unsigned char *&cur, const cpp_symtab &macro_definitions);

}

std::string CPreprocessor::run(const std::string &input, LocationManager &lm,
        cpp_symtab &macro_definitions) const {
    LFORTRAN_ASSERT(input[input.size()] == '\0');
    unsigned char *string_start=(unsigned char*)(&input[0]);
    unsigned char *cur = string_start;
    std::string output;
    lm.preprocessor = true;
    get_newlines(input, lm.in_newlines0);
    lm.out_start0.push_back(0);
    lm.in_start0.push_back(0);
    std::vector<IfDef> ifdef_stack;
    bool branch_enabled = true;
    macro_definitions["__FILE__"].expansion = "\"" + lm.in_filename + "\"";
    for (;;) {
        unsigned char *tok = cur;
        unsigned char *mar;
        unsigned char *t1, *t2, *t3, *t4;
        
#line 191 "preprocessor.cpp"
unsigned char *yyt1;
unsigned char *yyt2;
unsigned char *yyt3;
unsigned char *yyt4;
#line 187 "preprocessor.re"

        
#line 199 "preprocessor.cpp"
{
	unsigned char yych;
	unsigned int yyaccept = 0;
	static const unsigned char yybm[] = {
		  0, 176, 176, 176, 176, 176, 176, 176, 
		176, 240, 160, 240, 176, 240, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		240, 176, 144, 176, 176, 176, 176,  48, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		184, 184, 184, 184, 184, 184, 184, 184, 
		184, 184, 176, 176, 176, 176, 176, 176, 
		176, 184, 184, 184, 184, 184, 184, 184, 
		184, 184, 184, 184, 184, 184, 184, 184, 
		184, 184, 184, 184, 184, 184, 184, 184, 
		184, 184, 184, 176, 176, 176, 176, 184, 
		176, 184, 184, 184, 184, 184, 184, 184, 
		184, 184, 184, 184, 184, 184, 184, 184, 
		184, 184, 184, 184, 184, 184, 184, 184, 
		184, 184, 184, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
	};
	yych = *cur;
	if (yych <= '\'') {
		if (yych <= '!') {
			if (yych <= 0x00) goto yy2;
			if (yych <= ' ') goto yy4;
			goto yy6;
		} else {
			if (yych <= '"') goto yy7;
			if (yych <= '#') goto yy8;
			if (yych <= '&') goto yy4;
			goto yy9;
		}
	} else {
		if (yych <= '^') {
			if (yych <= '@') goto yy4;
			if (yych <= 'Z') goto yy10;
			goto yy4;
		} else {
			if (yych == '`') goto yy4;
			if (yych <= 'z') goto yy10;
			goto yy4;
		}
	}
yy2:
	++cur;
#line 209 "preprocessor.re"
	{
                break;
            }
#line 266 "preprocessor.cpp"
yy4:
	++cur;
yy5:
#line 204 "preprocessor.re"
	{
                if (!branch_enabled) continue;
                output.append(token(tok, cur));
                continue;
            }
#line 276 "preprocessor.cpp"
yy6:
	yyaccept = 0;
	yych = *(mar = ++cur);
	if (yych <= 0x00) goto yy5;
	goto yy14;
yy7:
	yyaccept = 0;
	yych = *(mar = ++cur);
	if (yych <= 0x00) goto yy5;
	goto yy19;
yy8:
	yyaccept = 0;
	yych = *(mar = ++cur);
	if (yych <= 0x1F) {
		if (yych <= '\n') {
			if (yych == '\t') goto yy23;
			goto yy5;
		} else {
			if (yych == '\f') goto yy5;
			if (yych <= '\r') goto yy23;
			goto yy5;
		}
	} else {
		if (yych <= 'h') {
			if (yych <= ' ') goto yy23;
			if (yych <= 'c') goto yy5;
			if (yych <= 'e') goto yy23;
			goto yy5;
		} else {
			if (yych <= 'i') goto yy23;
			if (yych == 'u') goto yy23;
			goto yy5;
		}
	}
yy9:
	yyaccept = 0;
	yych = *(mar = ++cur);
	if (yych <= 0x00) goto yy5;
	goto yy29;
yy10:
	yych = *++cur;
	if (yybm[0+yych] & 8) {
		goto yy10;
	}
#line 379 "preprocessor.re"
	{
                if (!branch_enabled) continue;
                std::string t = token(tok, cur);
                if (macro_definitions.find(t) != macro_definitions.end()) {
                    // Prepare the start of the interval
                    interval_end_type_0(lm, output.size(), tok-string_start);

                    // Expand the macro once
                    std::string expansion;
                    if (macro_definitions[t].function_like) {
                        if (*cur != '(') {
                            throw LFortranException("C preprocessor: function-like macro invocation must have argument list");
                        }
                        std::vector<std::string> args;
                        args = parse_arguments(cur, false);
                        if (*cur != ')') {
                            throw LFortranException("C preprocessor: expected )");
                        }
                        cur++;
                        expansion = function_like_macro_expansion(
                            macro_definitions[t].args,
                            macro_definitions[t].expansion,
                            args);
                    } else {
                        if (t == "__LINE__") {
                            uint32_t line;
                            if (lm.current_line == 0) {
                                uint32_t pos = cur-string_start;
                                uint32_t col;
                                lm.pos_to_linecol(pos, line, col);
                            } else {
                                line = lm.current_line;
                            }
                            expansion = std::to_string(line);
                        } else {
                            expansion = macro_definitions[t].expansion;
                        }
                    }

                    // Recursively expand the expansion
                    std::string expansion2;
                    int i = 0;
                    while (expansion2 != expansion) {
                        expansion2 = expansion;
                        LocationManager lm_tmp = lm; // Make a copy

                        uint32_t pos = cur-string_start;
                        uint32_t line, col;
                        lm.pos_to_linecol(pos, line, col);
                        lm_tmp.current_line = line;

                        expansion = run(expansion2, lm_tmp, macro_definitions);
                        i++;
                        if (i == 40) {
                            throw LFortranException("C preprocessor: maximum recursion limit reached");
                        }
                    }

                    // Output the final recursively expanded macro
                    output.append(expansion);

                    // Prepare the end of the interval
                    interval_end(lm, output.size(), cur-string_start,
                        t.size(), 1);
                } else {
                    output.append(t);
                }
                continue;
            }
#line 391 "preprocessor.cpp"
yy13:
	yych = *++cur;
yy14:
	if (yybm[0+yych] & 16) {
		goto yy13;
	}
	if (yych >= 0x01) goto yy16;
yy15:
	cur = mar;
	if (yyaccept <= 1) {
		if (yyaccept == 0) {
			goto yy5;
		} else {
			goto yy21;
		}
	} else {
		goto yy31;
	}
yy16:
	++cur;
#line 212 "preprocessor.re"
	{
                if (!branch_enabled) continue;
                output.append(token(tok, cur));
                continue;
            }
#line 418 "preprocessor.cpp"
yy18:
	yych = *++cur;
yy19:
	if (yybm[0+yych] & 32) {
		goto yy18;
	}
	if (yych <= 0x00) goto yy15;
	yyaccept = 1;
	yych = *(mar = ++cur);
	if (yych == '"') goto yy18;
yy21:
#line 448 "preprocessor.re"
	{
                if (!branch_enabled) continue;
                output.append(token(tok, cur));
                continue;
            }
#line 436 "preprocessor.cpp"
yy22:
	yych = *++cur;
yy23:
	if (yybm[0+yych] & 64) {
		goto yy22;
	}
	if (yych <= 'h') {
		if (yych <= 'c') goto yy15;
		if (yych <= 'd') goto yy24;
		if (yych <= 'e') goto yy25;
		goto yy15;
	} else {
		if (yych <= 'i') goto yy26;
		if (yych == 'u') goto yy27;
		goto yy15;
	}
yy24:
	yych = *++cur;
	if (yych == 'e') goto yy32;
	goto yy15;
yy25:
	yych = *++cur;
	if (yych == 'l') goto yy33;
	if (yych == 'n') goto yy34;
	goto yy15;
yy26:
	yych = *++cur;
	if (yych == 'f') goto yy35;
	if (yych == 'n') goto yy36;
	goto yy15;
yy27:
	yych = *++cur;
	if (yych == 'n') goto yy37;
	goto yy15;
yy28:
	yych = *++cur;
yy29:
	if (yybm[0+yych] & 128) {
		goto yy28;
	}
	if (yych <= 0x00) goto yy15;
	yyaccept = 2;
	yych = *(mar = ++cur);
	if (yych == '\'') goto yy28;
yy31:
#line 453 "preprocessor.re"
	{
                if (!branch_enabled) continue;
                output.append(token(tok, cur));
                continue;
            }
#line 488 "preprocessor.cpp"
yy32:
	yych = *++cur;
	if (yych == 'f') goto yy38;
	goto yy15;
yy33:
	yych = *++cur;
	if (yych == 's') goto yy39;
	goto yy15;
yy34:
	yych = *++cur;
	if (yych == 'd') goto yy40;
	goto yy15;
yy35:
	yych = *++cur;
	if (yych <= '\r') {
		if (yych <= '\n') {
			if (yych == '\t') goto yy41;
			goto yy15;
		} else {
			if (yych == '\f') goto yy15;
			goto yy41;
		}
	} else {
		if (yych <= 'c') {
			if (yych == ' ') goto yy41;
			goto yy15;
		} else {
			if (yych <= 'd') goto yy43;
			if (yych == 'n') goto yy44;
			goto yy15;
		}
	}
yy36:
	yych = *++cur;
	if (yych == 'c') goto yy45;
	goto yy15;
yy37:
	yych = *++cur;
	if (yych == 'd') goto yy46;
	goto yy15;
yy38:
	yych = *++cur;
	if (yych == 'i') goto yy47;
	goto yy15;
yy39:
	yych = *++cur;
	if (yych == 'e') goto yy48;
	goto yy15;
yy40:
	yych = *++cur;
	if (yych == 'i') goto yy50;
	goto yy15;
yy41:
	yych = *++cur;
	if (yych <= '\v') {
		if (yych <= 0x08) {
			if (yych <= 0x00) goto yy15;
			yyt1 = cur;
			goto yy51;
		} else {
			if (yych == '\n') {
				yyt1 = cur;
				goto yy53;
			}
			goto yy41;
		}
	} else {
		if (yych <= '\r') {
			if (yych <= '\f') {
				yyt1 = cur;
				goto yy51;
			}
			goto yy41;
		} else {
			if (yych == ' ') goto yy41;
			yyt1 = cur;
			goto yy51;
		}
	}
yy43:
	yych = *++cur;
	if (yych == 'e') goto yy55;
	goto yy15;
yy44:
	yych = *++cur;
	if (yych == 'd') goto yy56;
	goto yy15;
yy45:
	yych = *++cur;
	if (yych == 'l') goto yy57;
	goto yy15;
yy46:
	yych = *++cur;
	if (yych == 'e') goto yy58;
	goto yy15;
yy47:
	yych = *++cur;
	if (yych == 'n') goto yy59;
	goto yy15;
yy48:
	yych = *++cur;
	if (yych <= '\v') {
		if (yych <= 0x08) goto yy15;
		if (yych == '\n') goto yy60;
		goto yy48;
	} else {
		if (yych <= '\r') {
			if (yych <= '\f') goto yy15;
			goto yy48;
		} else {
			if (yych == ' ') goto yy48;
			goto yy15;
		}
	}
yy50:
	yych = *++cur;
	if (yych == 'f') goto yy62;
	goto yy15;
yy51:
	yych = *++cur;
	if (yych <= 0x00) goto yy15;
	if (yych != '\n') goto yy51;
yy53:
	++cur;
	t1 = yyt1;
	t2 = cur - 1;
#line 298 "preprocessor.re"
	{
                IfDef ifdef;
                ifdef.active = branch_enabled;
                if (ifdef.active) {
                    bool test_true = parse_bexpr(t1, macro_definitions) > 0;
                    cur = t1;
                    if (test_true) {
                        ifdef.branch_enabled = true;
                    } else {
                        ifdef.branch_enabled = false;
                    }
                    branch_enabled = ifdef.branch_enabled;
                } else {
                    ifdef.branch_enabled = false;
                }
                ifdef_stack.push_back(ifdef);
                if (!ifdef.active) continue;

                interval_end_type_0(lm, output.size(), cur-string_start);
                continue;
            }
#line 637 "preprocessor.cpp"
yy55:
	yych = *++cur;
	if (yych == 'f') goto yy64;
	goto yy15;
yy56:
	yych = *++cur;
	if (yych == 'e') goto yy65;
	goto yy15;
yy57:
	yych = *++cur;
	if (yych == 'u') goto yy66;
	goto yy15;
yy58:
	yych = *++cur;
	if (yych == 'f') goto yy67;
	goto yy15;
yy59:
	yych = *++cur;
	if (yych == 'e') goto yy68;
	goto yy15;
yy60:
	++cur;
#line 319 "preprocessor.re"
	{
                if (ifdef_stack.size() == 0) {
                    throw LFortranException("C preprocessor: #else encountered outside of #ifdef or #ifndef");
                }
                IfDef ifdef = ifdef_stack[ifdef_stack.size()-1];
                if (ifdef.active) {
                    ifdef.branch_enabled = !ifdef.branch_enabled;
                    branch_enabled = ifdef.branch_enabled;
                } else {
                    continue;
                }

                interval_end_type_0(lm, output.size(), cur-string_start);
                continue;
            }
#line 676 "preprocessor.cpp"
yy62:
	yych = *++cur;
	if (yych <= '\v') {
		if (yych <= 0x08) goto yy15;
		if (yych == '\n') goto yy69;
		goto yy62;
	} else {
		if (yych <= '\r') {
			if (yych <= '\f') goto yy15;
			goto yy62;
		} else {
			if (yych == ' ') goto yy62;
			goto yy15;
		}
	}
yy64:
	yych = *++cur;
	if (yych <= '^') {
		if (yych <= '@') goto yy72;
		if (yych <= 'Z') goto yy15;
		goto yy72;
	} else {
		if (yych == '`') goto yy72;
		if (yych <= 'z') goto yy15;
		goto yy72;
	}
yy65:
	yych = *++cur;
	if (yych == 'f') goto yy73;
	goto yy15;
yy66:
	yych = *++cur;
	if (yych == 'd') goto yy74;
	goto yy15;
yy67:
	yych = *++cur;
	if (yych <= '^') {
		if (yych <= '@') goto yy76;
		if (yych <= 'Z') goto yy15;
		goto yy76;
	} else {
		if (yych == '`') goto yy76;
		if (yych <= 'z') goto yy15;
		goto yy76;
	}
yy68:
	yych = *++cur;
	if (yych <= '^') {
		if (yych <= '@') goto yy78;
		if (yych <= 'Z') goto yy15;
		goto yy78;
	} else {
		if (yych == '`') goto yy78;
		if (yych <= 'z') goto yy15;
		goto yy78;
	}
yy69:
	++cur;
#line 334 "preprocessor.re"
	{
                if (ifdef_stack.size() == 0) {
                    throw LFortranException("C preprocessor: #endif encountered outside of #ifdef or #ifndef");
                }
                IfDef ifdef = ifdef_stack[ifdef_stack.size()-1];
                ifdef_stack.pop_back();
                if (ifdef.active) {
                    branch_enabled = true;
                } else {
                    continue;
                }

                interval_end_type_0(lm, output.size(), cur-string_start);
                continue;
            }
#line 751 "preprocessor.cpp"
yy71:
	yych = *++cur;
yy72:
	if (yych <= 0x1F) {
		if (yych <= '\n') {
			if (yych == '\t') goto yy71;
			goto yy15;
		} else {
			if (yych == '\f') goto yy15;
			if (yych <= '\r') goto yy71;
			goto yy15;
		}
	} else {
		if (yych <= '^') {
			if (yych <= ' ') goto yy71;
			if (yych <= '@') goto yy15;
			if (yych <= 'Z') {
				yyt1 = cur;
				goto yy79;
			}
			goto yy15;
		} else {
			if (yych == '`') goto yy15;
			if (yych <= 'z') {
				yyt1 = cur;
				goto yy79;
			}
			goto yy15;
		}
	}
yy73:
	yych = *++cur;
	if (yych <= '^') {
		if (yych <= '@') goto yy82;
		if (yych <= 'Z') goto yy15;
		goto yy82;
	} else {
		if (yych == '`') goto yy82;
		if (yych <= 'z') goto yy15;
		goto yy82;
	}
yy74:
	yych = *++cur;
	if (yych == 'e') goto yy83;
	goto yy15;
yy75:
	yych = *++cur;
yy76:
	if (yych <= 0x1F) {
		if (yych <= '\n') {
			if (yych == '\t') goto yy75;
			goto yy15;
		} else {
			if (yych == '\f') goto yy15;
			if (yych <= '\r') goto yy75;
			goto yy15;
		}
	} else {
		if (yych <= '^') {
			if (yych <= ' ') goto yy75;
			if (yych <= '@') goto yy15;
			if (yych <= 'Z') {
				yyt1 = cur;
				goto yy84;
			}
			goto yy15;
		} else {
			if (yych == '`') goto yy15;
			if (yych <= 'z') {
				yyt1 = cur;
				goto yy84;
			}
			goto yy15;
		}
	}
yy77:
	yych = *++cur;
yy78:
	if (yych <= 0x1F) {
		if (yych <= '\n') {
			if (yych == '\t') goto yy77;
			goto yy15;
		} else {
			if (yych == '\f') goto yy15;
			if (yych <= '\r') goto yy77;
			goto yy15;
		}
	} else {
		if (yych <= '^') {
			if (yych <= ' ') goto yy77;
			if (yych <= '@') goto yy15;
			if (yych <= 'Z') {
				yyt1 = cur;
				goto yy86;
			}
			goto yy15;
		} else {
			if (yych == '`') goto yy15;
			if (yych <= 'z') {
				yyt1 = cur;
				goto yy86;
			}
			goto yy15;
		}
	}
yy79:
	yych = *++cur;
	if (yych <= ' ') {
		if (yych <= '\v') {
			if (yych <= 0x08) goto yy15;
			if (yych == '\n') {
				yyt2 = cur;
				goto yy90;
			}
			yyt2 = cur;
			goto yy88;
		} else {
			if (yych == '\r') {
				yyt2 = cur;
				goto yy88;
			}
			if (yych <= 0x1F) goto yy15;
			yyt2 = cur;
			goto yy88;
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '/') goto yy15;
			if (yych <= '9') goto yy79;
			if (yych <= '@') goto yy15;
			goto yy79;
		} else {
			if (yych <= '_') {
				if (yych <= '^') goto yy15;
				goto yy79;
			} else {
				if (yych <= '`') goto yy15;
				if (yych <= 'z') goto yy79;
				goto yy15;
			}
		}
	}
yy81:
	yych = *++cur;
yy82:
	if (yych <= 0x1F) {
		if (yych <= '\n') {
			if (yych == '\t') goto yy81;
			goto yy15;
		} else {
			if (yych == '\f') goto yy15;
			if (yych <= '\r') goto yy81;
			goto yy15;
		}
	} else {
		if (yych <= '^') {
			if (yych <= ' ') goto yy81;
			if (yych <= '@') goto yy15;
			if (yych <= 'Z') {
				yyt1 = cur;
				goto yy92;
			}
			goto yy15;
		} else {
			if (yych == '`') goto yy15;
			if (yych <= 'z') {
				yyt1 = cur;
				goto yy92;
			}
			goto yy15;
		}
	}
yy83:
	yych = *++cur;
	if (yych == '"') goto yy15;
	goto yy95;
yy84:
	yych = *++cur;
	if (yych <= ' ') {
		if (yych <= '\v') {
			if (yych <= 0x08) goto yy15;
			if (yych == '\n') {
				yyt2 = cur;
				goto yy98;
			}
			yyt2 = cur;
			goto yy96;
		} else {
			if (yych == '\r') {
				yyt2 = cur;
				goto yy96;
			}
			if (yych <= 0x1F) goto yy15;
			yyt2 = cur;
			goto yy96;
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '/') goto yy15;
			if (yych <= '9') goto yy84;
			if (yych <= '@') goto yy15;
			goto yy84;
		} else {
			if (yych <= '_') {
				if (yych <= '^') goto yy15;
				goto yy84;
			} else {
				if (yych <= '`') goto yy15;
				if (yych <= 'z') goto yy84;
				goto yy15;
			}
		}
	}
yy86:
	yych = *++cur;
	if (yych <= '\'') {
		if (yych <= '\v') {
			if (yych <= 0x08) goto yy15;
			if (yych == '\n') {
				yyt3 = yyt4 = NULL;
				yyt2 = cur;
				goto yy102;
			}
			yyt2 = cur;
			goto yy100;
		} else {
			if (yych <= '\r') {
				if (yych <= '\f') goto yy15;
				yyt2 = cur;
				goto yy100;
			} else {
				if (yych == ' ') {
					yyt2 = cur;
					goto yy100;
				}
				goto yy15;
			}
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '/') {
				if (yych <= '(') {
					yyt2 = cur;
					goto yy104;
				}
				goto yy15;
			} else {
				if (yych <= '9') goto yy86;
				if (yych <= '@') goto yy15;
				goto yy86;
			}
		} else {
			if (yych <= '_') {
				if (yych <= '^') goto yy15;
				goto yy86;
			} else {
				if (yych <= '`') goto yy15;
				if (yych <= 'z') goto yy86;
				goto yy15;
			}
		}
	}
yy88:
	yych = *++cur;
	if (yych <= '\v') {
		if (yych <= 0x08) goto yy15;
		if (yych != '\n') goto yy88;
	} else {
		if (yych <= '\r') {
			if (yych <= '\f') goto yy15;
			goto yy88;
		} else {
			if (yych == ' ') goto yy88;
			goto yy15;
		}
	}
yy90:
	++cur;
	t1 = yyt1;
	t2 = yyt2;
#line 258 "preprocessor.re"
	{
                IfDef ifdef;
                ifdef.active = branch_enabled;
                if (ifdef.active) {
                    std::string macro_name = token(t1, t2);
                    if (macro_definitions.find(macro_name) != macro_definitions.end()) {
                        ifdef.branch_enabled = true;
                    } else {
                        ifdef.branch_enabled = false;
                    }
                    branch_enabled = ifdef.branch_enabled;
                } else {
                    ifdef.branch_enabled = false;
                }
                ifdef_stack.push_back(ifdef);
                if (!ifdef.active) continue;

                interval_end_type_0(lm, output.size(), cur-string_start);
                continue;
            }
#line 1053 "preprocessor.cpp"
yy92:
	yych = *++cur;
	if (yych <= ' ') {
		if (yych <= '\v') {
			if (yych <= 0x08) goto yy15;
			if (yych == '\n') {
				yyt2 = cur;
				goto yy108;
			}
			yyt2 = cur;
			goto yy106;
		} else {
			if (yych == '\r') {
				yyt2 = cur;
				goto yy106;
			}
			if (yych <= 0x1F) goto yy15;
			yyt2 = cur;
			goto yy106;
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '/') goto yy15;
			if (yych <= '9') goto yy92;
			if (yych <= '@') goto yy15;
			goto yy92;
		} else {
			if (yych <= '_') {
				if (yych <= '^') goto yy15;
				goto yy92;
			} else {
				if (yych <= '`') goto yy15;
				if (yych <= 'z') goto yy92;
				goto yy15;
			}
		}
	}
yy94:
	yych = *++cur;
yy95:
	switch (yych) {
	case '\t':
	case '\v':
	case '\r':
	case ' ':	goto yy94;
	case '"':	goto yy110;
	default:	goto yy15;
	}
yy96:
	yych = *++cur;
	if (yych <= '\v') {
		if (yych <= 0x08) goto yy15;
		if (yych != '\n') goto yy96;
	} else {
		if (yych <= '\r') {
			if (yych <= '\f') goto yy15;
			goto yy96;
		} else {
			if (yych == ' ') goto yy96;
			goto yy15;
		}
	}
yy98:
	++cur;
	t1 = yyt1;
	t2 = yyt2;
#line 247 "preprocessor.re"
	{
                if (!branch_enabled) continue;
                std::string macro_name = token(t1, t2);
                auto search = macro_definitions.find(macro_name);
                if (search != macro_definitions.end()) {
                    macro_definitions.erase(search);
                }

                interval_end_type_0(lm, output.size(), cur-string_start);
                continue;
            }
#line 1132 "preprocessor.cpp"
yy100:
	yych = *++cur;
	if (yych <= '\v') {
		if (yych <= 0x08) {
			if (yych <= 0x00) goto yy15;
			yyt4 = cur;
			goto yy111;
		} else {
			if (yych != '\n') goto yy100;
			yyt3 = yyt4 = NULL;
		}
	} else {
		if (yych <= '\r') {
			if (yych <= '\f') {
				yyt4 = cur;
				goto yy111;
			}
			goto yy100;
		} else {
			if (yych == ' ') goto yy100;
			yyt4 = cur;
			goto yy111;
		}
	}
yy102:
	++cur;
	t1 = yyt1;
	t2 = yyt2;
	t3 = yyt4;
	t4 = yyt3;
#line 217 "preprocessor.re"
	{
                if (!branch_enabled) continue;
                std::string macro_name = token(t1, t2), macro_subs;
                if (t3 != nullptr) {
                    LFORTRAN_ASSERT(t4 != nullptr);
                    macro_subs = token(t3, t4);
                    handle_continuation_lines(macro_subs, cur);
                }
                CPPMacro fn;
                fn.expansion = macro_subs;
                macro_definitions[macro_name] = fn;

                interval_end_type_0(lm, output.size(), cur-string_start);
                continue;
            }
#line 1179 "preprocessor.cpp"
yy104:
	yych = *++cur;
	if (yych <= 0x1F) {
		if (yych <= '\n') {
			if (yych == '\t') goto yy104;
			goto yy15;
		} else {
			if (yych == '\f') goto yy15;
			if (yych <= '\r') goto yy104;
			goto yy15;
		}
	} else {
		if (yych <= '^') {
			if (yych <= ' ') goto yy104;
			if (yych <= '@') goto yy15;
			if (yych <= 'Z') goto yy113;
			goto yy15;
		} else {
			if (yych == '`') goto yy15;
			if (yych <= 'z') goto yy113;
			goto yy15;
		}
	}
yy106:
	yych = *++cur;
	if (yych <= '\v') {
		if (yych <= 0x08) goto yy15;
		if (yych != '\n') goto yy106;
	} else {
		if (yych <= '\r') {
			if (yych <= '\f') goto yy15;
			goto yy106;
		} else {
			if (yych == ' ') goto yy106;
			goto yy15;
		}
	}
yy108:
	++cur;
	t1 = yyt1;
	t2 = yyt2;
#line 278 "preprocessor.re"
	{
                IfDef ifdef;
                ifdef.active = branch_enabled;
                if (ifdef.active) {
                    std::string macro_name = token(t1, t2);
                    if (macro_definitions.find(macro_name) != macro_definitions.end()) {
                        ifdef.branch_enabled = false;
                    } else {
                        ifdef.branch_enabled = true;
                    }
                    branch_enabled = ifdef.branch_enabled;
                } else {
                    ifdef.branch_enabled = false;
                }
                ifdef_stack.push_back(ifdef);
                if (!ifdef.active) continue;

                interval_end_type_0(lm, output.size(), cur-string_start);
                continue;
            }
#line 1242 "preprocessor.cpp"
yy110:
	yych = *++cur;
	if (yych <= 0x00) goto yy15;
	if (yych == '"') {
		yyt1 = yyt2 = cur;
		goto yy117;
	}
	yyt1 = cur;
	goto yy115;
yy111:
	yych = *++cur;
	if (yych <= 0x00) goto yy15;
	if (yych == '\n') {
		yyt3 = cur;
		goto yy102;
	}
	goto yy111;
yy113:
	yych = *++cur;
	if (yych <= ')') {
		if (yych <= '\f') {
			if (yych <= '\t') {
				if (yych <= 0x08) goto yy15;
				goto yy119;
			} else {
				if (yych == '\v') goto yy119;
				goto yy15;
			}
		} else {
			if (yych <= 0x1F) {
				if (yych <= '\r') goto yy119;
				goto yy15;
			} else {
				if (yych <= ' ') goto yy119;
				if (yych <= '(') goto yy15;
				goto yy121;
			}
		}
	} else {
		if (yych <= '@') {
			if (yych <= ',') {
				if (yych <= '+') goto yy15;
				goto yy104;
			} else {
				if (yych <= '/') goto yy15;
				if (yych <= '9') goto yy113;
				goto yy15;
			}
		} else {
			if (yych <= '_') {
				if (yych <= 'Z') goto yy113;
				if (yych <= '^') goto yy15;
				goto yy113;
			} else {
				if (yych <= '`') goto yy15;
				if (yych <= 'z') goto yy113;
				goto yy15;
			}
		}
	}
yy115:
	yych = *++cur;
	if (yych <= 0x00) goto yy15;
	if (yych != '"') goto yy115;
	yyt2 = cur;
yy117:
	yych = *++cur;
	if (yych <= 0x00) goto yy15;
	if (yych == '\n') goto yy122;
	goto yy117;
yy119:
	yych = *++cur;
	if (yych <= '\r') {
		if (yych <= '\n') {
			if (yych == '\t') goto yy119;
			goto yy15;
		} else {
			if (yych == '\f') goto yy15;
			goto yy119;
		}
	} else {
		if (yych <= '(') {
			if (yych == ' ') goto yy119;
			goto yy15;
		} else {
			if (yych <= ')') goto yy121;
			if (yych == ',') goto yy104;
			goto yy15;
		}
	}
yy121:
	yych = *++cur;
	if (yych <= '\v') {
		if (yych == '\t') goto yy124;
		if (yych <= '\n') goto yy15;
		goto yy124;
	} else {
		if (yych <= '\r') {
			if (yych <= '\f') goto yy15;
			goto yy124;
		} else {
			if (yych == ' ') goto yy124;
			goto yy15;
		}
	}
yy122:
	++cur;
	t1 = yyt1;
	t2 = yyt2;
#line 349 "preprocessor.re"
	{
                if (!branch_enabled) continue;
                std::string filename = token(t1, t2);
                // Construct a filename relative to the current file
                // TODO: make this multiplatform
                std::string base_dir = lm.in_filename;
                std::string::size_type n = base_dir.rfind("/");
                if (n != std::string::npos) {
                    base_dir = base_dir.substr(0, n);
                    filename = base_dir + "/" + filename;
                }
                std::string include;
                if (!read_file(filename, include)) {
                    throw LFortranException("C preprocessor: include file '" + filename + "' cannot be opened");
                }

                LocationManager lm_tmp = lm; // Make a copy
                include = run(include, lm_tmp, macro_definitions);

                // Prepare the start of the interval
                interval_end_type_0(lm, output.size(), tok-string_start);

                // Include
                output.append(include);

                // Prepare the end of the interval
                interval_end(lm, output.size(), cur-string_start,
                    token(tok, cur).size()-1, 1);
                continue;
            }
#line 1383 "preprocessor.cpp"
yy124:
	yych = *++cur;
	if (yych <= '\v') {
		if (yych <= 0x08) {
			if (yych <= 0x00) goto yy15;
			yyt3 = cur;
		} else {
			if (yych == '\n') {
				yyt3 = cur;
				goto yy128;
			}
			goto yy124;
		}
	} else {
		if (yych <= '\r') {
			if (yych >= '\r') goto yy124;
			yyt3 = cur;
		} else {
			if (yych == ' ') goto yy124;
			yyt3 = cur;
		}
	}
yy126:
	yych = *++cur;
	if (yych <= 0x00) goto yy15;
	if (yych != '\n') goto yy126;
yy128:
	++cur;
	t1 = yyt1;
	t2 = yyt2;
	t3 = yyt3;
	t4 = cur - 1;
#line 232 "preprocessor.re"
	{
                if (!branch_enabled) continue;
                std::string macro_name = token(t1, t2),
                        macro_subs = token(t3, t4);
                handle_continuation_lines(macro_subs, cur);
                std::vector<std::string> args = parse_arguments(t2, true);
                CPPMacro fn;
                fn.function_like = true;
                fn.args = args;
                fn.expansion = macro_subs;
                macro_definitions[macro_name] = fn;

                interval_end_type_0(lm, output.size(), cur-string_start);
                continue;
            }
#line 1432 "preprocessor.cpp"
}
#line 458 "preprocessor.re"

    }
    lm.out_start0.push_back(output.size());
    lm.in_start0.push_back(input.size());
    // The just created interval ID:
    size_t N = lm.out_start0.size()-2;
    lm.in_size0.push_back(lm.out_start0[N+1]-lm.out_start0[N]);
    lm.interval_type0.push_back(0);

    // Uncomment for debugging
    /*
    std::cout << "in_start0: ";
    for (auto A : lm.in_start0) { std::cout << A << " "; }
    std::cout << std::endl;
    std::cout << "in_size0: ";
    for (auto A : lm.in_size0) { std::cout << A << " "; }
    std::cout << std::endl;
    std::cout << "interval_type0: ";
    for (auto A : lm.interval_type0) { std::cout << A << " "; }
    std::cout << std::endl;
    std::cout << "out_start0: ";
    for (auto A : lm.out_start0) { std::cout << A << " "; }
    std::cout << std::endl;
    */

    return output;
}

std::string CPreprocessor::function_like_macro_expansion(
            std::vector<std::string> &def_args,
            std::string &expansion,
            std::vector<std::string> &call_args) const {
    LFORTRAN_ASSERT(expansion[expansion.size()] == '\0');
    unsigned char *string_start=(unsigned char*)(&expansion[0]);
    unsigned char *cur = string_start;
    std::string output;
    for (;;) {
        unsigned char *tok = cur;
        unsigned char *mar;
        
#line 1475 "preprocessor.cpp"
{
	unsigned char yych;
	unsigned int yyaccept = 0;
	static const unsigned char yybm[] = {
		  0, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 128, 192, 192, 192, 192,  64, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		224, 224, 224, 224, 224, 224, 224, 224, 
		224, 224, 192, 192, 192, 192, 192, 192, 
		192, 224, 224, 224, 224, 224, 224, 224, 
		224, 224, 224, 224, 224, 224, 224, 224, 
		224, 224, 224, 224, 224, 224, 224, 224, 
		224, 224, 224, 192, 192, 192, 192, 224, 
		192, 224, 224, 224, 224, 224, 224, 224, 
		224, 224, 224, 224, 224, 224, 224, 224, 
		224, 224, 224, 224, 224, 224, 224, 224, 
		224, 224, 224, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
	};
	yych = *cur;
	if (yych <= '@') {
		if (yych <= '"') {
			if (yych <= 0x00) goto yy132;
			if (yych <= '!') goto yy134;
			goto yy136;
		} else {
			if (yych == '\'') goto yy137;
			goto yy134;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'Z') goto yy138;
			if (yych <= '^') goto yy134;
			goto yy138;
		} else {
			if (yych <= '`') goto yy134;
			if (yych <= 'z') goto yy138;
			goto yy134;
		}
	}
yy132:
	++cur;
#line 507 "preprocessor.re"
	{
                break;
            }
#line 1540 "preprocessor.cpp"
yy134:
	++cur;
yy135:
#line 503 "preprocessor.re"
	{
                output.append(token(tok, cur));
                continue;
            }
#line 1549 "preprocessor.cpp"
yy136:
	yyaccept = 0;
	yych = *(mar = ++cur);
	if (yych <= 0x00) goto yy135;
	goto yy142;
yy137:
	yyaccept = 0;
	yych = *(mar = ++cur);
	if (yych <= 0x00) goto yy135;
	goto yy147;
yy138:
	yych = *++cur;
	if (yybm[0+yych] & 32) {
		goto yy138;
	}
#line 510 "preprocessor.re"
	{
                std::string t = token(tok, cur);
                auto search = std::find(def_args.begin(), def_args.end(), t);
                if (search != def_args.end()) {
                    size_t i = std::distance(def_args.begin(), search);
                    output.append(call_args[i]);
                } else {
                    output.append(t);
                }
                continue;
            }
#line 1577 "preprocessor.cpp"
yy141:
	yych = *++cur;
yy142:
	if (yybm[0+yych] & 64) {
		goto yy141;
	}
	if (yych >= 0x01) goto yy144;
yy143:
	cur = mar;
	if (yyaccept <= 1) {
		if (yyaccept == 0) {
			goto yy135;
		} else {
			goto yy145;
		}
	} else {
		goto yy149;
	}
yy144:
	yyaccept = 1;
	yych = *(mar = ++cur);
	if (yych == '"') goto yy141;
yy145:
#line 521 "preprocessor.re"
	{
                output.append(token(tok, cur));
                continue;
            }
#line 1606 "preprocessor.cpp"
yy146:
	yych = *++cur;
yy147:
	if (yybm[0+yych] & 128) {
		goto yy146;
	}
	if (yych <= 0x00) goto yy143;
	yyaccept = 2;
	yych = *(mar = ++cur);
	if (yych == '\'') goto yy146;
yy149:
#line 525 "preprocessor.re"
	{
                output.append(token(tok, cur));
                continue;
            }
#line 1623 "preprocessor.cpp"
}
#line 529 "preprocessor.re"

    }
    return output;
}

enum CPPTokenType {
    TK_EOF, TK_NAME, TK_INTEGER, TK_STRING, TK_AND, TK_OR, TK_NEG,
    TK_LPAREN, TK_RPAREN, TK_LT, TK_GT, TK_LTE, TK_GTE, TK_NE, TK_EQ,
    TK_PLUS, TK_MINUS, TK_MUL, TK_DIV
};

namespace {

std::string token(unsigned char *tok, unsigned char* cur)
{
    return std::string((char *)tok, cur - tok);
}

}

void get_next_token(unsigned char *&cur, CPPTokenType &type, std::string &str) {
    std::string output;
    for (;;) {
        unsigned char *tok = cur;
        unsigned char *mar;
        
#line 1652 "preprocessor.cpp"
{
	unsigned char yych;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,  32,   0,  32,   0,  32,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		 32,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192,   0,   0,   0,   0,   0,   0, 
		  0, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128,   0,   0,   0,   0, 128, 
		  0, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
	};
	yych = *cur;
	if (yybm[0+yych] & 32) {
		goto yy156;
	}
	if (yych <= '/') {
		if (yych <= '\'') {
			if (yych <= 0x1F) {
				if (yych <= 0x00) goto yy152;
				if (yych <= 0x08) goto yy154;
				if (yych <= '\n') goto yy159;
				goto yy154;
			} else {
				if (yych <= '!') goto yy161;
				if (yych == '&') goto yy163;
				goto yy154;
			}
		} else {
			if (yych <= '+') {
				if (yych <= '(') goto yy164;
				if (yych <= ')') goto yy166;
				if (yych <= '*') goto yy168;
				goto yy170;
			} else {
				if (yych == '-') goto yy172;
				if (yych <= '.') goto yy154;
				goto yy174;
			}
		}
	} else {
		if (yych <= '[') {
			if (yych <= '=') {
				if (yych <= '9') goto yy176;
				if (yych <= ';') goto yy154;
				if (yych <= '<') goto yy179;
				goto yy181;
			} else {
				if (yych <= '>') goto yy182;
				if (yych <= '@') goto yy154;
				if (yych <= 'Z') goto yy184;
				goto yy154;
			}
		} else {
			if (yych <= '`') {
				if (yych <= '\\') goto yy187;
				if (yych == '_') goto yy184;
				goto yy154;
			} else {
				if (yych <= 'z') goto yy184;
				if (yych == '|') goto yy188;
				goto yy154;
			}
		}
	}
yy152:
	++cur;
#line 564 "preprocessor.re"
	{ type = CPPTokenType::TK_EOF; return; }
#line 1746 "preprocessor.cpp"
yy154:
	++cur;
yy155:
#line 560 "preprocessor.re"
	{
                std::string t = token(tok, cur);
                throw LFortranException("Unknown token: " + t);
            }
#line 1755 "preprocessor.cpp"
yy156:
	yych = *++cur;
	if (yybm[0+yych] & 32) {
		goto yy156;
	}
#line 566 "preprocessor.re"
	{ continue; }
#line 1763 "preprocessor.cpp"
yy159:
	++cur;
#line 565 "preprocessor.re"
	{ type = CPPTokenType::TK_EOF; return; }
#line 1768 "preprocessor.cpp"
yy161:
	yych = *++cur;
	if (yych == '=') goto yy189;
#line 574 "preprocessor.re"
	{ type = CPPTokenType::TK_NEG; return; }
#line 1774 "preprocessor.cpp"
yy163:
	yych = *++cur;
	if (yych == '&') goto yy191;
	goto yy155;
yy164:
	++cur;
#line 575 "preprocessor.re"
	{ type = CPPTokenType::TK_LPAREN; return; }
#line 1783 "preprocessor.cpp"
yy166:
	++cur;
#line 576 "preprocessor.re"
	{ type = CPPTokenType::TK_RPAREN; return; }
#line 1788 "preprocessor.cpp"
yy168:
	++cur;
#line 570 "preprocessor.re"
	{ type = CPPTokenType::TK_MUL; return; }
#line 1793 "preprocessor.cpp"
yy170:
	++cur;
#line 568 "preprocessor.re"
	{ type = CPPTokenType::TK_PLUS; return; }
#line 1798 "preprocessor.cpp"
yy172:
	++cur;
#line 569 "preprocessor.re"
	{ type = CPPTokenType::TK_MINUS; return; }
#line 1803 "preprocessor.cpp"
yy174:
	yych = *++cur;
	if (yych == '=') goto yy193;
#line 571 "preprocessor.re"
	{ type = CPPTokenType::TK_DIV; return; }
#line 1809 "preprocessor.cpp"
yy176:
	yych = *++cur;
	if (yybm[0+yych] & 64) {
		goto yy176;
	}
#line 584 "preprocessor.re"
	{
                str = token(tok, cur);
                type = CPPTokenType::TK_INTEGER;
                return;
            }
#line 1821 "preprocessor.cpp"
yy179:
	yych = *++cur;
	if (yych == '=') goto yy195;
#line 577 "preprocessor.re"
	{ type = CPPTokenType::TK_LT; return; }
#line 1827 "preprocessor.cpp"
yy181:
	yych = *++cur;
	if (yych == '=') goto yy197;
	goto yy155;
yy182:
	yych = *++cur;
	if (yych == '=') goto yy199;
#line 578 "preprocessor.re"
	{ type = CPPTokenType::TK_GT; return; }
#line 1837 "preprocessor.cpp"
yy184:
	yych = *++cur;
	if (yybm[0+yych] & 128) {
		goto yy184;
	}
#line 589 "preprocessor.re"
	{
                str = token(tok, cur);
                type = CPPTokenType::TK_NAME;
                return;
            }
#line 1849 "preprocessor.cpp"
yy187:
	yych = *(mar = ++cur);
	if (yych <= '\f') {
		if (yych <= 0x08) goto yy155;
		if (yych <= '\v') goto yy202;
		goto yy155;
	} else {
		if (yych <= '\r') goto yy202;
		if (yych == ' ') goto yy202;
		goto yy155;
	}
yy188:
	yych = *++cur;
	if (yych == '|') goto yy206;
	goto yy155;
yy189:
	++cur;
#line 582 "preprocessor.re"
	{ type = CPPTokenType::TK_NE; return; }
#line 1869 "preprocessor.cpp"
yy191:
	++cur;
#line 572 "preprocessor.re"
	{ type = CPPTokenType::TK_AND; return; }
#line 1874 "preprocessor.cpp"
yy193:
	++cur;
#line 581 "preprocessor.re"
	{ type = CPPTokenType::TK_NE; return; }
#line 1879 "preprocessor.cpp"
yy195:
	++cur;
#line 579 "preprocessor.re"
	{ type = CPPTokenType::TK_LTE; return; }
#line 1884 "preprocessor.cpp"
yy197:
	++cur;
#line 583 "preprocessor.re"
	{ type = CPPTokenType::TK_EQ; return; }
#line 1889 "preprocessor.cpp"
yy199:
	++cur;
#line 580 "preprocessor.re"
	{ type = CPPTokenType::TK_GTE; return; }
#line 1894 "preprocessor.cpp"
yy201:
	yych = *++cur;
yy202:
	if (yych <= '\v') {
		if (yych <= 0x08) goto yy203;
		if (yych == '\n') goto yy204;
		goto yy201;
	} else {
		if (yych <= '\r') {
			if (yych >= '\r') goto yy201;
		} else {
			if (yych == ' ') goto yy201;
		}
	}
yy203:
	cur = mar;
	goto yy155;
yy204:
	++cur;
#line 567 "preprocessor.re"
	{ continue; }
#line 1916 "preprocessor.cpp"
yy206:
	++cur;
#line 573 "preprocessor.re"
	{ type = CPPTokenType::TK_OR; return; }
#line 1921 "preprocessor.cpp"
}
#line 594 "preprocessor.re"

    }
}

namespace {

void accept(unsigned char *&cur, CPPTokenType type_expected) {
    CPPTokenType type;
    std::string str;
    get_next_token(cur, type, str);
    if (type != type_expected) {
        throw LFortranException("Unexpected token type "
            + std::to_string((int)type)
            + ", expected type "
            + std::to_string((int)type_expected) );
    }
}

std::string accept_name(unsigned char *&cur) {
    CPPTokenType type;
    std::string str;
    get_next_token(cur, type, str);
    if (type != CPPTokenType::TK_NAME) {
        throw LFortranException("Unexpected token type "
            + std::to_string((int)type)
            + ", expected TK_NAME");
    }
    return str;
}

int parse_term(unsigned char *&cur, const cpp_symtab &macro_definitions);
int parse_factor(unsigned char *&cur, const cpp_symtab &macro_definitions);
int parse_bfactor(unsigned char *&cur, const cpp_symtab &macro_definitions);

/*
b-expr
    = b-factor (("&&"|"||") b-factor)*
*/
int parse_bexpr(unsigned char *&cur, const cpp_symtab &macro_definitions) {
    int tmp = parse_bfactor(cur, macro_definitions);

    CPPTokenType type;
    std::string str;
    unsigned char *old_cur = cur;
    get_next_token(cur, type, str);
    while (type == CPPTokenType::TK_AND || type == CPPTokenType::TK_OR) {
        bool factor = parse_bfactor(cur, macro_definitions) > 0;
        if (type == CPPTokenType::TK_AND) {
            tmp = (int)( (tmp > 0) && (factor > 0) );
        } else {
            tmp = (int)( (tmp > 0) || (factor > 0) );
        }
        old_cur = cur;
        get_next_token(cur, type, str);
    }
    cur = old_cur; // Revert the last token, as we will not consume it
    return tmp;
}

/*
expr
    = term ((+,-) term)*
*/
int parse_expr(unsigned char *&cur, const cpp_symtab &macro_definitions) {
    int tmp;
    tmp = parse_term(cur, macro_definitions);

    CPPTokenType type;
    std::string str;
    unsigned char *old_cur = cur;
    get_next_token(cur, type, str);
    while (type == CPPTokenType::TK_PLUS || type == CPPTokenType::TK_MINUS) {
        int term = parse_term(cur, macro_definitions);
        if (type == CPPTokenType::TK_PLUS) {
            tmp = tmp + term;
        } else {
            tmp = tmp - term;
        }
        old_cur = cur;
        get_next_token(cur, type, str);
    }
    cur = old_cur; // Revert the last token, as we will not consume it
    return tmp;
}

/*
term
    = factor ((*,/) factor)*
*/
int parse_term(unsigned char *&cur, const cpp_symtab &macro_definitions) {
    int tmp;
    tmp = parse_factor(cur, macro_definitions);

    CPPTokenType type;
    std::string str;
    unsigned char *old_cur = cur;
    get_next_token(cur, type, str);
    while (type == CPPTokenType::TK_MUL || type == CPPTokenType::TK_DIV) {
        int term = parse_factor(cur, macro_definitions);
        if (type == CPPTokenType::TK_MUL) {
            tmp = tmp * term;
        } else {
            tmp = tmp / term;
        }
        old_cur = cur;
        get_next_token(cur, type, str);
    }
    cur = old_cur; // Revert the last token, as we will not consume it
    return tmp;
}

/*
factor
    = TK_INTEGER
    | TK_NAME
    | (-,+) factor
    | "(" b-expr ")"
*/
int parse_factor(unsigned char *&cur, const cpp_symtab &macro_definitions) {
    CPPTokenType type;
    std::string str;
    get_next_token(cur, type, str);
    if (type == CPPTokenType::TK_NAME) {
        if (macro_definitions.find(str) != macro_definitions.end()) {
            std::string v = macro_definitions.at(str).expansion;
            unsigned char *cur2 = (unsigned char*)(&v[0]);
            int i = parse_expr(cur2, macro_definitions);
            return i;
        } else {
            // If the variable/macro is not defined, we evaluate it as 0
            return 0;
        }
    } else if (type == CPPTokenType::TK_INTEGER) {
        int i = std::stoi(str);
        return i;
    } else if (type == CPPTokenType::TK_MINUS) {
        int result = parse_factor(cur, macro_definitions);
        return -result;
    } else if (type == CPPTokenType::TK_PLUS) {
        int result = parse_factor(cur, macro_definitions);
        return +result;
    } else if (type == CPPTokenType::TK_LPAREN) {
        int result = parse_bexpr(cur, macro_definitions);
        accept(cur, CPPTokenType::TK_RPAREN);
        return result;

    // This is the only place where we can get unexpected tokens. Let us
    // handle them here:
    } else if (type == CPPTokenType::TK_EOF) {
        // EOF means the expression
        throw LFortranException("factor(): The expression is not complete, expecting integer, name, +, - or (");
    } else {
        throw LFortranException("Unexpected token type " + std::to_string((int)type) + " in factor()");
    }
}

/*
relation
    = expr
    | expr (<,>,>=,<=,/=,!=,==) expr
*/
int parse_relation(unsigned char *&cur, const cpp_symtab &macro_definitions) {
    int lhs;
    lhs = parse_expr(cur, macro_definitions);
    unsigned char *old_cur = cur;

    CPPTokenType type;
    std::string str;
    get_next_token(cur, type, str);
    if (type >= CPPTokenType::TK_LT && type <= CPPTokenType::TK_EQ) {
        int rhs = parse_expr(cur, macro_definitions);
        if (type == CPPTokenType::TK_LT) {
            return lhs < rhs;
        } else if (type == CPPTokenType::TK_GT) {
            return lhs > rhs;
        } else if (type == CPPTokenType::TK_LTE) {
            return lhs <= rhs;
        } else if (type == CPPTokenType::TK_GTE) {
            return lhs >= rhs;
        } else if (type == CPPTokenType::TK_NE) {
            return lhs != rhs;
        } else if (type == CPPTokenType::TK_EQ) {
            return lhs == rhs;
        } else {
            throw LFortranException("Inconsistent ifs");
        }
    } else {
        cur = old_cur; // Revert the last token, as we will not consume it
        return lhs;
    }
}

/*
b-factor
    = "defined(" TK_NAME ")"
    | "!" b-factor
    | relation
*/
int parse_bfactor(unsigned char *&cur, const cpp_symtab &macro_definitions) {
    CPPTokenType type;
    std::string str;
    unsigned char *old_cur = cur;
    get_next_token(cur, type, str);
    if (type == CPPTokenType::TK_NAME && str == "defined") {
        accept(cur, CPPTokenType::TK_LPAREN);
        std::string macro_name = accept_name(cur);
        accept(cur, CPPTokenType::TK_RPAREN);
        if (macro_definitions.find(macro_name) != macro_definitions.end()) {
            return true;
        } else {
            return false;
        }
    } else if (type == CPPTokenType::TK_NEG) {
        bool bresult = parse_bfactor(cur, macro_definitions) > 0;
        bresult = !bresult; // Apply "!"
        return (int) bresult;
    } else {
        // For everything else we commit to relation and handle any potential errors there:
        cur = old_cur; // Restore the token
        int result = parse_relation(cur, macro_definitions);
        return result;
    }
}

}

} // namespace LFortran
