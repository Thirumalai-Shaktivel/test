#ifndef LFORTRAN_AST_H
#define LFORTRAN_AST_H

// Generated by grammar/asdl_cpp.py

#include <lfortran/parser/alloc.h>
#include <lfortran/parser/location.h>
#include <lfortran/colors.h>
#include <lfortran/containers.h>
#include <lfortran/exception.h>
#include <lfortran/semantics/asr_scopes.h>


namespace LFortran::AST {

enum astType
{
    unit, mod, program_unit, unit_decl1, unit_decl2, interface_header, interface_item, import_statement, implicit_statement, implicit_none_spec, letter_spec, stmt, expr, trivia, trivia_node, procedure_decl, decl_attribute, event_attribute, team_attribute, bind, array_index, case_stmt, case_cond, rank_stmt, type_stmt, use_symbol, concurrent_control, concurrent_locality
};

struct ast_t
{
    astType type;
    Location loc;
};


template <class T, class U>
inline bool is_a(const U &x)
{
    return T::class_type == x.type;
}

// Cast one level down

template <class T, class U>
static inline T* down_cast(const U *f)
{
    LFORTRAN_ASSERT(f != nullptr);
    LFORTRAN_ASSERT(is_a<T>(*f));
    return (T*)f;
}

// Cast two levels down

template <class T>
static inline T* down_cast2(const ast_t *f)
{
    typedef typename T::parent_type ptype;
    ptype *t = down_cast<ptype>(f);
    return down_cast<T>(t);
}


/******************************************************************************/
// Forward declarations

struct unit_t; // Sum
struct mod_t; // Sum
struct program_unit_t; // Sum
struct unit_decl1_t; // Sum
struct unit_decl2_t; // Sum
struct interface_header_t; // Sum
struct interface_item_t; // Sum
struct import_statement_t; // Sum
enum import_modifierType // Simple Sum
{ // Types
    ImportDefault, ImportOnly, ImportNone, ImportAll
};
struct implicit_statement_t; // Sum
struct implicit_none_spec_t; // Sum
struct letter_spec_t; // Sum
struct stmt_t; // Sum
struct expr_t; // Sum
struct trivia_t; // Sum
struct trivia_node_t; // Sum
enum boolopType // Simple Sum
{ // Types
    And, Or, Xor, Eqv, NEqv
};
enum operatorType // Simple Sum
{ // Types
    Add, Sub, Mul, Div, Pow
};
enum stroperatorType // Simple Sum
{ // Types
    Concat
};
enum unaryopType // Simple Sum
{ // Types
    Invert, Not, UAdd, USub
};
enum cmpopType // Simple Sum
{ // Types
    Eq, NotEq, Lt, LtE, Gt, GtE
};
enum intrinsicopType // Simple Sum
{ // Types
    AND, OR, XOR, EQV, NEQV, PLUS, MINUS, STAR, DIV, POW, NOT, EQ, NOTEQ, LT, LTE, GT, GTE, CONCAT
};
struct procedure_decl_t; // Sum
struct decl_attribute_t; // Sum
enum simple_attributeType // Simple Sum
{ // Types
    AttrAbstract, AttrAllocatable, AttrAsynchronous, AttrCommon, AttrContiguous, AttrDeferred, AttrElemental, AttrEnumerator, AttrExternal, AttrImpure, AttrIntrinsic, AttrKind, AttrLen, AttrModule, AttrNoPass, AttrNonDeferred, AttrNon_Intrinsic, AttrOptional, AttrParameter, AttrPointer, AttrPrivate, AttrProtected, AttrPublic, AttrPure, AttrRecursive, AttrSave, AttrSequence, AttrTarget, AttrValue, AttrVolatile
};
enum attr_intentType // Simple Sum
{ // Types
    In, Out, InOut
};
enum decl_typeType // Simple Sum
{ // Types
    TypeClass, TypeCharacter, TypeComplex, TypeDoublePrecision, TypeInteger, TypeLogical, TypeProcedure, TypeReal, TypeType
};
struct event_attribute_t; // Sum
struct team_attribute_t; // Sum
struct var_sym_t; // Product
struct kind_item_t; // Product
enum kind_item_typeType // Simple Sum
{ // Types
    Star, Colon, Value
};
struct dimension_t; // Product
enum dimension_typeType // Simple Sum
{ // Types
    DimensionExpr, DimensionStar, AssumedRank
};
struct codimension_t; // Product
enum codimension_typeType // Simple Sum
{ // Types
    CodimensionExpr, CodimensionStar
};
enum symbolType // Simple Sum
{ // Types
    None, Arrow, Equal, Asterisk, DoubleAsterisk, Slash
};
struct equi_t; // Product
struct kw_argstar_t; // Product
struct argstar_t; // Product
struct arg_t; // Product
struct fnarg_t; // Product
struct coarrayarg_t; // Product
struct keyword_t; // Product
struct struct_member_t; // Product
struct bind_t; // Sum
struct array_index_t; // Sum
struct case_stmt_t; // Sum
struct case_cond_t; // Sum
struct rank_stmt_t; // Sum
struct type_stmt_t; // Sum
struct use_symbol_t; // Sum
struct concurrent_control_t; // Sum
struct concurrent_locality_t; // Sum
enum reduce_opType // Simple Sum
{ // Types
    ReduceAdd, ReduceMul, ReduceMIN, ReduceMAX
};


/******************************************************************************/
// Products declarations

struct var_sym_t // Product
{
    Location loc;
    char* m_name;
    dimension_t* m_dim; size_t n_dim; // Sequence
    codimension_t* m_codim; size_t n_codim; // Sequence
    expr_t* m_initializer;
    symbolType m_sym;
    decl_attribute_t* m_spec;
};
struct kind_item_t // Product
{
    Location loc;
    char* m_id;
    expr_t* m_value;
    kind_item_typeType m_type;
};
struct dimension_t // Product
{
    Location loc;
    expr_t* m_start;
    expr_t* m_end;
    dimension_typeType m_end_star;
};
struct codimension_t // Product
{
    Location loc;
    expr_t* m_start;
    expr_t* m_end;
    codimension_typeType m_end_star;
};
struct equi_t // Product
{
    Location loc;
    expr_t** m_set_list; size_t n_set_list; // Sequence
};
struct kw_argstar_t // Product
{
    Location loc;
    char* m_arg;
    expr_t* m_value;
};
struct argstar_t // Product
{
    Location loc;
    expr_t* m_value;
};
struct arg_t // Product
{
    Location loc;
    char* m_arg;
};
struct fnarg_t // Product
{
    Location loc;
    expr_t* m_start;
    expr_t* m_end;
    expr_t* m_step;
};
struct coarrayarg_t // Product
{
    Location loc;
    expr_t* m_start;
    expr_t* m_end;
    expr_t* m_step;
    codimension_typeType m_star;
};
struct keyword_t // Product
{
    Location loc;
    char* m_arg;
    expr_t* m_value;
};
struct struct_member_t // Product
{
    Location loc;
    char* m_name;
    fnarg_t* m_args; size_t n_args; // Sequence
};


/******************************************************************************/
// Sums declarations

enum unitType // Types
{
    TranslationUnit
};

struct unit_t // Sum
{
    const static astType class_type = astType::unit;
    ast_t base;
    unitType type;
};

    struct TranslationUnit_t // Constructor
    {
        const static unitType class_type = unitType::TranslationUnit;
        typedef unit_t parent_type;
        unit_t base;
        ast_t** m_items; size_t n_items; // Sequence
    };
    static inline ast_t* make_TranslationUnit_t(Allocator &al, const Location &a_loc, ast_t** a_items, size_t n_items) {
        TranslationUnit_t *n;
        n = al.make_new<TranslationUnit_t>();
        n->base.type = unitType::TranslationUnit;
        n->base.base.type = astType::unit;
        n->base.base.loc = a_loc;
        n->m_items = a_items;
        n->n_items = n_items;
        return (ast_t*)n;
    }



enum modType // Types
{
    Module, Submodule, BlockData, Program
};

struct mod_t // Sum
{
    const static astType class_type = astType::mod;
    ast_t base;
    modType type;
};

    struct Module_t // Constructor
    {
        const static modType class_type = modType::Module;
        typedef mod_t parent_type;
        mod_t base;
        char* m_name;
        trivia_t* m_trivia;
        unit_decl1_t** m_use; size_t n_use; // Sequence
        implicit_statement_t** m_implicit; size_t n_implicit; // Sequence
        unit_decl2_t** m_decl; size_t n_decl; // Sequence
        program_unit_t** m_contains; size_t n_contains; // Sequence
    };
    static inline ast_t* make_Module_t(Allocator &al, const Location &a_loc, char* a_name, trivia_t* a_trivia, unit_decl1_t** a_use, size_t n_use, implicit_statement_t** a_implicit, size_t n_implicit, unit_decl2_t** a_decl, size_t n_decl, program_unit_t** a_contains, size_t n_contains) {
        Module_t *n;
        n = al.make_new<Module_t>();
        n->base.type = modType::Module;
        n->base.base.type = astType::mod;
        n->base.base.loc = a_loc;
        n->m_name = a_name;
        n->m_trivia = a_trivia;
        n->m_use = a_use;
        n->n_use = n_use;
        n->m_implicit = a_implicit;
        n->n_implicit = n_implicit;
        n->m_decl = a_decl;
        n->n_decl = n_decl;
        n->m_contains = a_contains;
        n->n_contains = n_contains;
        return (ast_t*)n;
    }

    struct Submodule_t // Constructor
    {
        const static modType class_type = modType::Submodule;
        typedef mod_t parent_type;
        mod_t base;
        char* m_id;
        char* m_parent_name;
        char* m_name;
        trivia_t* m_trivia;
        unit_decl1_t** m_use; size_t n_use; // Sequence
        implicit_statement_t** m_implicit; size_t n_implicit; // Sequence
        unit_decl2_t** m_decl; size_t n_decl; // Sequence
        program_unit_t** m_contains; size_t n_contains; // Sequence
    };
    static inline ast_t* make_Submodule_t(Allocator &al, const Location &a_loc, char* a_id, char* a_parent_name, char* a_name, trivia_t* a_trivia, unit_decl1_t** a_use, size_t n_use, implicit_statement_t** a_implicit, size_t n_implicit, unit_decl2_t** a_decl, size_t n_decl, program_unit_t** a_contains, size_t n_contains) {
        Submodule_t *n;
        n = al.make_new<Submodule_t>();
        n->base.type = modType::Submodule;
        n->base.base.type = astType::mod;
        n->base.base.loc = a_loc;
        n->m_id = a_id;
        n->m_parent_name = a_parent_name;
        n->m_name = a_name;
        n->m_trivia = a_trivia;
        n->m_use = a_use;
        n->n_use = n_use;
        n->m_implicit = a_implicit;
        n->n_implicit = n_implicit;
        n->m_decl = a_decl;
        n->n_decl = n_decl;
        n->m_contains = a_contains;
        n->n_contains = n_contains;
        return (ast_t*)n;
    }

    struct BlockData_t // Constructor
    {
        const static modType class_type = modType::BlockData;
        typedef mod_t parent_type;
        mod_t base;
        char* m_name;
        trivia_t* m_trivia;
        unit_decl1_t** m_use; size_t n_use; // Sequence
        implicit_statement_t** m_implicit; size_t n_implicit; // Sequence
        unit_decl2_t** m_decl; size_t n_decl; // Sequence
    };
    static inline ast_t* make_BlockData_t(Allocator &al, const Location &a_loc, char* a_name, trivia_t* a_trivia, unit_decl1_t** a_use, size_t n_use, implicit_statement_t** a_implicit, size_t n_implicit, unit_decl2_t** a_decl, size_t n_decl) {
        BlockData_t *n;
        n = al.make_new<BlockData_t>();
        n->base.type = modType::BlockData;
        n->base.base.type = astType::mod;
        n->base.base.loc = a_loc;
        n->m_name = a_name;
        n->m_trivia = a_trivia;
        n->m_use = a_use;
        n->n_use = n_use;
        n->m_implicit = a_implicit;
        n->n_implicit = n_implicit;
        n->m_decl = a_decl;
        n->n_decl = n_decl;
        return (ast_t*)n;
    }

    struct Program_t // Constructor
    {
        const static modType class_type = modType::Program;
        typedef mod_t parent_type;
        mod_t base;
        char* m_name;
        trivia_t* m_trivia;
        unit_decl1_t** m_use; size_t n_use; // Sequence
        implicit_statement_t** m_implicit; size_t n_implicit; // Sequence
        unit_decl2_t** m_decl; size_t n_decl; // Sequence
        stmt_t** m_body; size_t n_body; // Sequence
        program_unit_t** m_contains; size_t n_contains; // Sequence
    };
    static inline ast_t* make_Program_t(Allocator &al, const Location &a_loc, char* a_name, trivia_t* a_trivia, unit_decl1_t** a_use, size_t n_use, implicit_statement_t** a_implicit, size_t n_implicit, unit_decl2_t** a_decl, size_t n_decl, stmt_t** a_body, size_t n_body, program_unit_t** a_contains, size_t n_contains) {
        Program_t *n;
        n = al.make_new<Program_t>();
        n->base.type = modType::Program;
        n->base.base.type = astType::mod;
        n->base.base.loc = a_loc;
        n->m_name = a_name;
        n->m_trivia = a_trivia;
        n->m_use = a_use;
        n->n_use = n_use;
        n->m_implicit = a_implicit;
        n->n_implicit = n_implicit;
        n->m_decl = a_decl;
        n->n_decl = n_decl;
        n->m_body = a_body;
        n->n_body = n_body;
        n->m_contains = a_contains;
        n->n_contains = n_contains;
        return (ast_t*)n;
    }



enum program_unitType // Types
{
    Subroutine, Procedure, Function
};

struct program_unit_t // Sum
{
    const static astType class_type = astType::program_unit;
    ast_t base;
    program_unitType type;
};

    struct Subroutine_t // Constructor
    {
        const static program_unitType class_type = program_unitType::Subroutine;
        typedef program_unit_t parent_type;
        program_unit_t base;
        char* m_name;
        arg_t* m_args; size_t n_args; // Sequence
        decl_attribute_t** m_attributes; size_t n_attributes; // Sequence
        bind_t* m_bind;
        trivia_t* m_trivia;
        unit_decl1_t** m_use; size_t n_use; // Sequence
        import_statement_t** m_import; size_t n_import; // Sequence
        implicit_statement_t** m_implicit; size_t n_implicit; // Sequence
        unit_decl2_t** m_decl; size_t n_decl; // Sequence
        stmt_t** m_body; size_t n_body; // Sequence
        program_unit_t** m_contains; size_t n_contains; // Sequence
    };
    static inline ast_t* make_Subroutine_t(Allocator &al, const Location &a_loc, char* a_name, arg_t* a_args, size_t n_args, decl_attribute_t** a_attributes, size_t n_attributes, bind_t* a_bind, trivia_t* a_trivia, unit_decl1_t** a_use, size_t n_use, import_statement_t** a_import, size_t n_import, implicit_statement_t** a_implicit, size_t n_implicit, unit_decl2_t** a_decl, size_t n_decl, stmt_t** a_body, size_t n_body, program_unit_t** a_contains, size_t n_contains) {
        Subroutine_t *n;
        n = al.make_new<Subroutine_t>();
        n->base.type = program_unitType::Subroutine;
        n->base.base.type = astType::program_unit;
        n->base.base.loc = a_loc;
        n->m_name = a_name;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_attributes = a_attributes;
        n->n_attributes = n_attributes;
        n->m_bind = a_bind;
        n->m_trivia = a_trivia;
        n->m_use = a_use;
        n->n_use = n_use;
        n->m_import = a_import;
        n->n_import = n_import;
        n->m_implicit = a_implicit;
        n->n_implicit = n_implicit;
        n->m_decl = a_decl;
        n->n_decl = n_decl;
        n->m_body = a_body;
        n->n_body = n_body;
        n->m_contains = a_contains;
        n->n_contains = n_contains;
        return (ast_t*)n;
    }

    struct Procedure_t // Constructor
    {
        const static program_unitType class_type = program_unitType::Procedure;
        typedef program_unit_t parent_type;
        program_unit_t base;
        char* m_name;
        arg_t* m_args; size_t n_args; // Sequence
        decl_attribute_t** m_attributes; size_t n_attributes; // Sequence
        trivia_t* m_trivia;
        unit_decl1_t** m_use; size_t n_use; // Sequence
        import_statement_t** m_import; size_t n_import; // Sequence
        implicit_statement_t** m_implicit; size_t n_implicit; // Sequence
        unit_decl2_t** m_decl; size_t n_decl; // Sequence
        stmt_t** m_body; size_t n_body; // Sequence
        program_unit_t** m_contains; size_t n_contains; // Sequence
    };
    static inline ast_t* make_Procedure_t(Allocator &al, const Location &a_loc, char* a_name, arg_t* a_args, size_t n_args, decl_attribute_t** a_attributes, size_t n_attributes, trivia_t* a_trivia, unit_decl1_t** a_use, size_t n_use, import_statement_t** a_import, size_t n_import, implicit_statement_t** a_implicit, size_t n_implicit, unit_decl2_t** a_decl, size_t n_decl, stmt_t** a_body, size_t n_body, program_unit_t** a_contains, size_t n_contains) {
        Procedure_t *n;
        n = al.make_new<Procedure_t>();
        n->base.type = program_unitType::Procedure;
        n->base.base.type = astType::program_unit;
        n->base.base.loc = a_loc;
        n->m_name = a_name;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_attributes = a_attributes;
        n->n_attributes = n_attributes;
        n->m_trivia = a_trivia;
        n->m_use = a_use;
        n->n_use = n_use;
        n->m_import = a_import;
        n->n_import = n_import;
        n->m_implicit = a_implicit;
        n->n_implicit = n_implicit;
        n->m_decl = a_decl;
        n->n_decl = n_decl;
        n->m_body = a_body;
        n->n_body = n_body;
        n->m_contains = a_contains;
        n->n_contains = n_contains;
        return (ast_t*)n;
    }

    struct Function_t // Constructor
    {
        const static program_unitType class_type = program_unitType::Function;
        typedef program_unit_t parent_type;
        program_unit_t base;
        char* m_name;
        arg_t* m_args; size_t n_args; // Sequence
        decl_attribute_t** m_attributes; size_t n_attributes; // Sequence
        expr_t* m_return_var;
        bind_t* m_bind;
        trivia_t* m_trivia;
        unit_decl1_t** m_use; size_t n_use; // Sequence
        import_statement_t** m_import; size_t n_import; // Sequence
        implicit_statement_t** m_implicit; size_t n_implicit; // Sequence
        unit_decl2_t** m_decl; size_t n_decl; // Sequence
        stmt_t** m_body; size_t n_body; // Sequence
        program_unit_t** m_contains; size_t n_contains; // Sequence
    };
    static inline ast_t* make_Function_t(Allocator &al, const Location &a_loc, char* a_name, arg_t* a_args, size_t n_args, decl_attribute_t** a_attributes, size_t n_attributes, expr_t* a_return_var, bind_t* a_bind, trivia_t* a_trivia, unit_decl1_t** a_use, size_t n_use, import_statement_t** a_import, size_t n_import, implicit_statement_t** a_implicit, size_t n_implicit, unit_decl2_t** a_decl, size_t n_decl, stmt_t** a_body, size_t n_body, program_unit_t** a_contains, size_t n_contains) {
        Function_t *n;
        n = al.make_new<Function_t>();
        n->base.type = program_unitType::Function;
        n->base.base.type = astType::program_unit;
        n->base.base.loc = a_loc;
        n->m_name = a_name;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_attributes = a_attributes;
        n->n_attributes = n_attributes;
        n->m_return_var = a_return_var;
        n->m_bind = a_bind;
        n->m_trivia = a_trivia;
        n->m_use = a_use;
        n->n_use = n_use;
        n->m_import = a_import;
        n->n_import = n_import;
        n->m_implicit = a_implicit;
        n->n_implicit = n_implicit;
        n->m_decl = a_decl;
        n->n_decl = n_decl;
        n->m_body = a_body;
        n->n_body = n_body;
        n->m_contains = a_contains;
        n->n_contains = n_contains;
        return (ast_t*)n;
    }



enum unit_decl1Type // Types
{
    Use
};

struct unit_decl1_t // Sum
{
    const static astType class_type = astType::unit_decl1;
    ast_t base;
    unit_decl1Type type;
};

    struct Use_t // Constructor
    {
        const static unit_decl1Type class_type = unit_decl1Type::Use;
        typedef unit_decl1_t parent_type;
        unit_decl1_t base;
        decl_attribute_t** m_nature; size_t n_nature; // Sequence
        char* m_module;
        use_symbol_t** m_symbols; size_t n_symbols; // Sequence
        bool m_only_present;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Use_t(Allocator &al, const Location &a_loc, decl_attribute_t** a_nature, size_t n_nature, char* a_module, use_symbol_t** a_symbols, size_t n_symbols, bool a_only_present, trivia_t* a_trivia) {
        Use_t *n;
        n = al.make_new<Use_t>();
        n->base.type = unit_decl1Type::Use;
        n->base.base.type = astType::unit_decl1;
        n->base.base.loc = a_loc;
        n->m_nature = a_nature;
        n->n_nature = n_nature;
        n->m_module = a_module;
        n->m_symbols = a_symbols;
        n->n_symbols = n_symbols;
        n->m_only_present = a_only_present;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }



enum unit_decl2Type // Types
{
    Declaration, Interface, DerivedType, Enum
};

struct unit_decl2_t // Sum
{
    const static astType class_type = astType::unit_decl2;
    ast_t base;
    unit_decl2Type type;
};

    struct Declaration_t // Constructor
    {
        const static unit_decl2Type class_type = unit_decl2Type::Declaration;
        typedef unit_decl2_t parent_type;
        unit_decl2_t base;
        decl_attribute_t* m_vartype;
        decl_attribute_t** m_attributes; size_t n_attributes; // Sequence
        var_sym_t* m_syms; size_t n_syms; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Declaration_t(Allocator &al, const Location &a_loc, decl_attribute_t* a_vartype, decl_attribute_t** a_attributes, size_t n_attributes, var_sym_t* a_syms, size_t n_syms, trivia_t* a_trivia) {
        Declaration_t *n;
        n = al.make_new<Declaration_t>();
        n->base.type = unit_decl2Type::Declaration;
        n->base.base.type = astType::unit_decl2;
        n->base.base.loc = a_loc;
        n->m_vartype = a_vartype;
        n->m_attributes = a_attributes;
        n->n_attributes = n_attributes;
        n->m_syms = a_syms;
        n->n_syms = n_syms;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Interface_t // Constructor
    {
        const static unit_decl2Type class_type = unit_decl2Type::Interface;
        typedef unit_decl2_t parent_type;
        unit_decl2_t base;
        interface_header_t* m_header;
        trivia_t* m_trivia;
        interface_item_t** m_items; size_t n_items; // Sequence
    };
    static inline ast_t* make_Interface_t(Allocator &al, const Location &a_loc, interface_header_t* a_header, trivia_t* a_trivia, interface_item_t** a_items, size_t n_items) {
        Interface_t *n;
        n = al.make_new<Interface_t>();
        n->base.type = unit_decl2Type::Interface;
        n->base.base.type = astType::unit_decl2;
        n->base.base.loc = a_loc;
        n->m_header = a_header;
        n->m_trivia = a_trivia;
        n->m_items = a_items;
        n->n_items = n_items;
        return (ast_t*)n;
    }

    struct DerivedType_t // Constructor
    {
        const static unit_decl2Type class_type = unit_decl2Type::DerivedType;
        typedef unit_decl2_t parent_type;
        unit_decl2_t base;
        char* m_name;
        char** m_namelist; size_t n_namelist; // Sequence
        trivia_t* m_trivia;
        decl_attribute_t** m_attrtype; size_t n_attrtype; // Sequence
        unit_decl2_t** m_items; size_t n_items; // Sequence
        procedure_decl_t** m_contains; size_t n_contains; // Sequence
    };
    static inline ast_t* make_DerivedType_t(Allocator &al, const Location &a_loc, char* a_name, char** a_namelist, size_t n_namelist, trivia_t* a_trivia, decl_attribute_t** a_attrtype, size_t n_attrtype, unit_decl2_t** a_items, size_t n_items, procedure_decl_t** a_contains, size_t n_contains) {
        DerivedType_t *n;
        n = al.make_new<DerivedType_t>();
        n->base.type = unit_decl2Type::DerivedType;
        n->base.base.type = astType::unit_decl2;
        n->base.base.loc = a_loc;
        n->m_name = a_name;
        n->m_namelist = a_namelist;
        n->n_namelist = n_namelist;
        n->m_trivia = a_trivia;
        n->m_attrtype = a_attrtype;
        n->n_attrtype = n_attrtype;
        n->m_items = a_items;
        n->n_items = n_items;
        n->m_contains = a_contains;
        n->n_contains = n_contains;
        return (ast_t*)n;
    }

    struct Enum_t // Constructor
    {
        const static unit_decl2Type class_type = unit_decl2Type::Enum;
        typedef unit_decl2_t parent_type;
        unit_decl2_t base;
        decl_attribute_t** m_attr; size_t n_attr; // Sequence
        trivia_t* m_trivia;
        unit_decl2_t** m_items; size_t n_items; // Sequence
    };
    static inline ast_t* make_Enum_t(Allocator &al, const Location &a_loc, decl_attribute_t** a_attr, size_t n_attr, trivia_t* a_trivia, unit_decl2_t** a_items, size_t n_items) {
        Enum_t *n;
        n = al.make_new<Enum_t>();
        n->base.type = unit_decl2Type::Enum;
        n->base.base.type = astType::unit_decl2;
        n->base.base.loc = a_loc;
        n->m_attr = a_attr;
        n->n_attr = n_attr;
        n->m_trivia = a_trivia;
        n->m_items = a_items;
        n->n_items = n_items;
        return (ast_t*)n;
    }



enum interface_headerType // Types
{
    InterfaceHeader, InterfaceHeaderName, InterfaceHeaderAssignment, InterfaceHeaderOperator, InterfaceHeaderDefinedOperator, AbstractInterfaceHeader, InterfaceHeaderWrite, InterfaceHeaderRead
};

struct interface_header_t // Sum
{
    const static astType class_type = astType::interface_header;
    ast_t base;
    interface_headerType type;
};

    struct InterfaceHeader_t // Constructor
    {
        const static interface_headerType class_type = interface_headerType::InterfaceHeader;
        typedef interface_header_t parent_type;
        interface_header_t base;
    };
    static inline ast_t* make_InterfaceHeader_t(Allocator &al, const Location &a_loc) {
        InterfaceHeader_t *n;
        n = al.make_new<InterfaceHeader_t>();
        n->base.type = interface_headerType::InterfaceHeader;
        n->base.base.type = astType::interface_header;
        n->base.base.loc = a_loc;
        return (ast_t*)n;
    }

    struct InterfaceHeaderName_t // Constructor
    {
        const static interface_headerType class_type = interface_headerType::InterfaceHeaderName;
        typedef interface_header_t parent_type;
        interface_header_t base;
        char* m_name;
    };
    static inline ast_t* make_InterfaceHeaderName_t(Allocator &al, const Location &a_loc, char* a_name) {
        InterfaceHeaderName_t *n;
        n = al.make_new<InterfaceHeaderName_t>();
        n->base.type = interface_headerType::InterfaceHeaderName;
        n->base.base.type = astType::interface_header;
        n->base.base.loc = a_loc;
        n->m_name = a_name;
        return (ast_t*)n;
    }

    struct InterfaceHeaderAssignment_t // Constructor
    {
        const static interface_headerType class_type = interface_headerType::InterfaceHeaderAssignment;
        typedef interface_header_t parent_type;
        interface_header_t base;
    };
    static inline ast_t* make_InterfaceHeaderAssignment_t(Allocator &al, const Location &a_loc) {
        InterfaceHeaderAssignment_t *n;
        n = al.make_new<InterfaceHeaderAssignment_t>();
        n->base.type = interface_headerType::InterfaceHeaderAssignment;
        n->base.base.type = astType::interface_header;
        n->base.base.loc = a_loc;
        return (ast_t*)n;
    }

    struct InterfaceHeaderOperator_t // Constructor
    {
        const static interface_headerType class_type = interface_headerType::InterfaceHeaderOperator;
        typedef interface_header_t parent_type;
        interface_header_t base;
        intrinsicopType m_op;
    };
    static inline ast_t* make_InterfaceHeaderOperator_t(Allocator &al, const Location &a_loc, intrinsicopType a_op) {
        InterfaceHeaderOperator_t *n;
        n = al.make_new<InterfaceHeaderOperator_t>();
        n->base.type = interface_headerType::InterfaceHeaderOperator;
        n->base.base.type = astType::interface_header;
        n->base.base.loc = a_loc;
        n->m_op = a_op;
        return (ast_t*)n;
    }

    struct InterfaceHeaderDefinedOperator_t // Constructor
    {
        const static interface_headerType class_type = interface_headerType::InterfaceHeaderDefinedOperator;
        typedef interface_header_t parent_type;
        interface_header_t base;
        char* m_operator_name;
    };
    static inline ast_t* make_InterfaceHeaderDefinedOperator_t(Allocator &al, const Location &a_loc, char* a_operator_name) {
        InterfaceHeaderDefinedOperator_t *n;
        n = al.make_new<InterfaceHeaderDefinedOperator_t>();
        n->base.type = interface_headerType::InterfaceHeaderDefinedOperator;
        n->base.base.type = astType::interface_header;
        n->base.base.loc = a_loc;
        n->m_operator_name = a_operator_name;
        return (ast_t*)n;
    }

    struct AbstractInterfaceHeader_t // Constructor
    {
        const static interface_headerType class_type = interface_headerType::AbstractInterfaceHeader;
        typedef interface_header_t parent_type;
        interface_header_t base;
    };
    static inline ast_t* make_AbstractInterfaceHeader_t(Allocator &al, const Location &a_loc) {
        AbstractInterfaceHeader_t *n;
        n = al.make_new<AbstractInterfaceHeader_t>();
        n->base.type = interface_headerType::AbstractInterfaceHeader;
        n->base.base.type = astType::interface_header;
        n->base.base.loc = a_loc;
        return (ast_t*)n;
    }

    struct InterfaceHeaderWrite_t // Constructor
    {
        const static interface_headerType class_type = interface_headerType::InterfaceHeaderWrite;
        typedef interface_header_t parent_type;
        interface_header_t base;
        char* m_id;
    };
    static inline ast_t* make_InterfaceHeaderWrite_t(Allocator &al, const Location &a_loc, char* a_id) {
        InterfaceHeaderWrite_t *n;
        n = al.make_new<InterfaceHeaderWrite_t>();
        n->base.type = interface_headerType::InterfaceHeaderWrite;
        n->base.base.type = astType::interface_header;
        n->base.base.loc = a_loc;
        n->m_id = a_id;
        return (ast_t*)n;
    }

    struct InterfaceHeaderRead_t // Constructor
    {
        const static interface_headerType class_type = interface_headerType::InterfaceHeaderRead;
        typedef interface_header_t parent_type;
        interface_header_t base;
        char* m_id;
    };
    static inline ast_t* make_InterfaceHeaderRead_t(Allocator &al, const Location &a_loc, char* a_id) {
        InterfaceHeaderRead_t *n;
        n = al.make_new<InterfaceHeaderRead_t>();
        n->base.type = interface_headerType::InterfaceHeaderRead;
        n->base.base.type = astType::interface_header;
        n->base.base.loc = a_loc;
        n->m_id = a_id;
        return (ast_t*)n;
    }



enum interface_itemType // Types
{
    InterfaceProc, InterfaceModuleProcedure
};

struct interface_item_t // Sum
{
    const static astType class_type = astType::interface_item;
    ast_t base;
    interface_itemType type;
};

    struct InterfaceProc_t // Constructor
    {
        const static interface_itemType class_type = interface_itemType::InterfaceProc;
        typedef interface_item_t parent_type;
        interface_item_t base;
        program_unit_t* m_proc;
    };
    static inline ast_t* make_InterfaceProc_t(Allocator &al, const Location &a_loc, program_unit_t* a_proc) {
        InterfaceProc_t *n;
        n = al.make_new<InterfaceProc_t>();
        n->base.type = interface_itemType::InterfaceProc;
        n->base.base.type = astType::interface_item;
        n->base.base.loc = a_loc;
        n->m_proc = a_proc;
        return (ast_t*)n;
    }

    struct InterfaceModuleProcedure_t // Constructor
    {
        const static interface_itemType class_type = interface_itemType::InterfaceModuleProcedure;
        typedef interface_item_t parent_type;
        interface_item_t base;
        char** m_names; size_t n_names; // Sequence
        decl_attribute_t** m_attributes; size_t n_attributes; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_InterfaceModuleProcedure_t(Allocator &al, const Location &a_loc, char** a_names, size_t n_names, decl_attribute_t** a_attributes, size_t n_attributes, trivia_t* a_trivia) {
        InterfaceModuleProcedure_t *n;
        n = al.make_new<InterfaceModuleProcedure_t>();
        n->base.type = interface_itemType::InterfaceModuleProcedure;
        n->base.base.type = astType::interface_item;
        n->base.base.loc = a_loc;
        n->m_names = a_names;
        n->n_names = n_names;
        n->m_attributes = a_attributes;
        n->n_attributes = n_attributes;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }



enum import_statementType // Types
{
    Import
};

struct import_statement_t // Sum
{
    const static astType class_type = astType::import_statement;
    ast_t base;
    import_statementType type;
};

    struct Import_t // Constructor
    {
        const static import_statementType class_type = import_statementType::Import;
        typedef import_statement_t parent_type;
        import_statement_t base;
        char** m_symbols; size_t n_symbols; // Sequence
        import_modifierType m_mod;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Import_t(Allocator &al, const Location &a_loc, char** a_symbols, size_t n_symbols, import_modifierType a_mod, trivia_t* a_trivia) {
        Import_t *n;
        n = al.make_new<Import_t>();
        n->base.type = import_statementType::Import;
        n->base.base.type = astType::import_statement;
        n->base.base.loc = a_loc;
        n->m_symbols = a_symbols;
        n->n_symbols = n_symbols;
        n->m_mod = a_mod;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }



enum implicit_statementType // Types
{
    ImplicitNone, Implicit
};

struct implicit_statement_t // Sum
{
    const static astType class_type = astType::implicit_statement;
    ast_t base;
    implicit_statementType type;
};

    struct ImplicitNone_t // Constructor
    {
        const static implicit_statementType class_type = implicit_statementType::ImplicitNone;
        typedef implicit_statement_t parent_type;
        implicit_statement_t base;
        implicit_none_spec_t** m_specs; size_t n_specs; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_ImplicitNone_t(Allocator &al, const Location &a_loc, implicit_none_spec_t** a_specs, size_t n_specs, trivia_t* a_trivia) {
        ImplicitNone_t *n;
        n = al.make_new<ImplicitNone_t>();
        n->base.type = implicit_statementType::ImplicitNone;
        n->base.base.type = astType::implicit_statement;
        n->base.base.loc = a_loc;
        n->m_specs = a_specs;
        n->n_specs = n_specs;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Implicit_t // Constructor
    {
        const static implicit_statementType class_type = implicit_statementType::Implicit;
        typedef implicit_statement_t parent_type;
        implicit_statement_t base;
        decl_attribute_t* m_type;
        letter_spec_t** m_kind; size_t n_kind; // Sequence
        letter_spec_t** m_specs; size_t n_specs; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Implicit_t(Allocator &al, const Location &a_loc, decl_attribute_t* a_type, letter_spec_t** a_kind, size_t n_kind, letter_spec_t** a_specs, size_t n_specs, trivia_t* a_trivia) {
        Implicit_t *n;
        n = al.make_new<Implicit_t>();
        n->base.type = implicit_statementType::Implicit;
        n->base.base.type = astType::implicit_statement;
        n->base.base.loc = a_loc;
        n->m_type = a_type;
        n->m_kind = a_kind;
        n->n_kind = n_kind;
        n->m_specs = a_specs;
        n->n_specs = n_specs;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }



enum implicit_none_specType // Types
{
    ImplicitNoneExternal, ImplicitNoneType
};

struct implicit_none_spec_t // Sum
{
    const static astType class_type = astType::implicit_none_spec;
    ast_t base;
    implicit_none_specType type;
};

    struct ImplicitNoneExternal_t // Constructor
    {
        const static implicit_none_specType class_type = implicit_none_specType::ImplicitNoneExternal;
        typedef implicit_none_spec_t parent_type;
        implicit_none_spec_t base;
        int64_t m_dummy;
    };
    static inline ast_t* make_ImplicitNoneExternal_t(Allocator &al, const Location &a_loc, int64_t a_dummy) {
        ImplicitNoneExternal_t *n;
        n = al.make_new<ImplicitNoneExternal_t>();
        n->base.type = implicit_none_specType::ImplicitNoneExternal;
        n->base.base.type = astType::implicit_none_spec;
        n->base.base.loc = a_loc;
        n->m_dummy = a_dummy;
        return (ast_t*)n;
    }

    struct ImplicitNoneType_t // Constructor
    {
        const static implicit_none_specType class_type = implicit_none_specType::ImplicitNoneType;
        typedef implicit_none_spec_t parent_type;
        implicit_none_spec_t base;
    };
    static inline ast_t* make_ImplicitNoneType_t(Allocator &al, const Location &a_loc) {
        ImplicitNoneType_t *n;
        n = al.make_new<ImplicitNoneType_t>();
        n->base.type = implicit_none_specType::ImplicitNoneType;
        n->base.base.type = astType::implicit_none_spec;
        n->base.base.loc = a_loc;
        return (ast_t*)n;
    }



enum letter_specType // Types
{
    LetterSpec
};

struct letter_spec_t // Sum
{
    const static astType class_type = astType::letter_spec;
    ast_t base;
    letter_specType type;
};

    struct LetterSpec_t // Constructor
    {
        const static letter_specType class_type = letter_specType::LetterSpec;
        typedef letter_spec_t parent_type;
        letter_spec_t base;
        char* m_start;
        char* m_end;
    };
    static inline ast_t* make_LetterSpec_t(Allocator &al, const Location &a_loc, char* a_start, char* a_end) {
        LetterSpec_t *n;
        n = al.make_new<LetterSpec_t>();
        n->base.type = letter_specType::LetterSpec;
        n->base.base.type = astType::letter_spec;
        n->base.base.loc = a_loc;
        n->m_start = a_start;
        n->m_end = a_end;
        return (ast_t*)n;
    }



enum stmtType // Types
{
    Allocate, Assign, Assignment, Associate, Backspace, Close, Continue, Cycle, Deallocate, Endfile, Entry, ErrorStop, EventPost, EventWait, Exit, Flush, ForAllSingle, Format, FormTeam, GoTo, Inquire, Nullify, Open, Return, Print, Read, Rewind, Stop, SubroutineCall, SyncAll, SyncImages, SyncMemory, SyncTeam, Write, AssociateBlock, Block, ChangeTeam, Critical, DoConcurrentLoop, DoLoop, ForAll, If, IfArithmetic, Select, SelectRank, SelectType, Where, WhileLoop
};

struct stmt_t // Sum
{
    const static astType class_type = astType::stmt;
    ast_t base;
    stmtType type;
};

    struct Allocate_t // Constructor
    {
        const static stmtType class_type = stmtType::Allocate;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        fnarg_t* m_args; size_t n_args; // Sequence
        keyword_t* m_keywords; size_t n_keywords; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Allocate_t(Allocator &al, const Location &a_loc, int64_t a_label, fnarg_t* a_args, size_t n_args, keyword_t* a_keywords, size_t n_keywords, trivia_t* a_trivia) {
        Allocate_t *n;
        n = al.make_new<Allocate_t>();
        n->base.type = stmtType::Allocate;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_keywords = a_keywords;
        n->n_keywords = n_keywords;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Assign_t // Constructor
    {
        const static stmtType class_type = stmtType::Assign;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        int64_t m_assign_label;
        char* m_variable;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Assign_t(Allocator &al, const Location &a_loc, int64_t a_label, int64_t a_assign_label, char* a_variable, trivia_t* a_trivia) {
        Assign_t *n;
        n = al.make_new<Assign_t>();
        n->base.type = stmtType::Assign;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_assign_label = a_assign_label;
        n->m_variable = a_variable;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Assignment_t // Constructor
    {
        const static stmtType class_type = stmtType::Assignment;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t* m_target;
        expr_t* m_value;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Assignment_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t* a_target, expr_t* a_value, trivia_t* a_trivia) {
        Assignment_t *n;
        n = al.make_new<Assignment_t>();
        n->base.type = stmtType::Assignment;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_target = a_target;
        n->m_value = a_value;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Associate_t // Constructor
    {
        const static stmtType class_type = stmtType::Associate;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t* m_target;
        expr_t* m_value;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Associate_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t* a_target, expr_t* a_value, trivia_t* a_trivia) {
        Associate_t *n;
        n = al.make_new<Associate_t>();
        n->base.type = stmtType::Associate;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_target = a_target;
        n->m_value = a_value;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Backspace_t // Constructor
    {
        const static stmtType class_type = stmtType::Backspace;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t** m_args; size_t n_args; // Sequence
        keyword_t* m_kwargs; size_t n_kwargs; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Backspace_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t** a_args, size_t n_args, keyword_t* a_kwargs, size_t n_kwargs, trivia_t* a_trivia) {
        Backspace_t *n;
        n = al.make_new<Backspace_t>();
        n->base.type = stmtType::Backspace;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_kwargs = a_kwargs;
        n->n_kwargs = n_kwargs;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Close_t // Constructor
    {
        const static stmtType class_type = stmtType::Close;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t** m_args; size_t n_args; // Sequence
        keyword_t* m_kwargs; size_t n_kwargs; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Close_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t** a_args, size_t n_args, keyword_t* a_kwargs, size_t n_kwargs, trivia_t* a_trivia) {
        Close_t *n;
        n = al.make_new<Close_t>();
        n->base.type = stmtType::Close;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_kwargs = a_kwargs;
        n->n_kwargs = n_kwargs;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Continue_t // Constructor
    {
        const static stmtType class_type = stmtType::Continue;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Continue_t(Allocator &al, const Location &a_loc, int64_t a_label, trivia_t* a_trivia) {
        Continue_t *n;
        n = al.make_new<Continue_t>();
        n->base.type = stmtType::Continue;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Cycle_t // Constructor
    {
        const static stmtType class_type = stmtType::Cycle;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        char* m_stmt_name;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Cycle_t(Allocator &al, const Location &a_loc, int64_t a_label, char* a_stmt_name, trivia_t* a_trivia) {
        Cycle_t *n;
        n = al.make_new<Cycle_t>();
        n->base.type = stmtType::Cycle;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_stmt_name = a_stmt_name;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Deallocate_t // Constructor
    {
        const static stmtType class_type = stmtType::Deallocate;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        fnarg_t* m_args; size_t n_args; // Sequence
        keyword_t* m_keywords; size_t n_keywords; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Deallocate_t(Allocator &al, const Location &a_loc, int64_t a_label, fnarg_t* a_args, size_t n_args, keyword_t* a_keywords, size_t n_keywords, trivia_t* a_trivia) {
        Deallocate_t *n;
        n = al.make_new<Deallocate_t>();
        n->base.type = stmtType::Deallocate;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_keywords = a_keywords;
        n->n_keywords = n_keywords;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Endfile_t // Constructor
    {
        const static stmtType class_type = stmtType::Endfile;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t** m_args; size_t n_args; // Sequence
        keyword_t* m_kwargs; size_t n_kwargs; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Endfile_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t** a_args, size_t n_args, keyword_t* a_kwargs, size_t n_kwargs, trivia_t* a_trivia) {
        Endfile_t *n;
        n = al.make_new<Endfile_t>();
        n->base.type = stmtType::Endfile;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_kwargs = a_kwargs;
        n->n_kwargs = n_kwargs;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Entry_t // Constructor
    {
        const static stmtType class_type = stmtType::Entry;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        char* m_name;
        arg_t* m_args; size_t n_args; // Sequence
        expr_t* m_return_var;
        bind_t* m_bind;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Entry_t(Allocator &al, const Location &a_loc, int64_t a_label, char* a_name, arg_t* a_args, size_t n_args, expr_t* a_return_var, bind_t* a_bind, trivia_t* a_trivia) {
        Entry_t *n;
        n = al.make_new<Entry_t>();
        n->base.type = stmtType::Entry;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_name = a_name;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_return_var = a_return_var;
        n->m_bind = a_bind;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct ErrorStop_t // Constructor
    {
        const static stmtType class_type = stmtType::ErrorStop;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t* m_code;
        expr_t* m_quiet;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_ErrorStop_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t* a_code, expr_t* a_quiet, trivia_t* a_trivia) {
        ErrorStop_t *n;
        n = al.make_new<ErrorStop_t>();
        n->base.type = stmtType::ErrorStop;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_code = a_code;
        n->m_quiet = a_quiet;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct EventPost_t // Constructor
    {
        const static stmtType class_type = stmtType::EventPost;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t* m_variable;
        event_attribute_t** m_stat; size_t n_stat; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_EventPost_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t* a_variable, event_attribute_t** a_stat, size_t n_stat, trivia_t* a_trivia) {
        EventPost_t *n;
        n = al.make_new<EventPost_t>();
        n->base.type = stmtType::EventPost;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_variable = a_variable;
        n->m_stat = a_stat;
        n->n_stat = n_stat;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct EventWait_t // Constructor
    {
        const static stmtType class_type = stmtType::EventWait;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t* m_variable;
        event_attribute_t** m_spec; size_t n_spec; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_EventWait_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t* a_variable, event_attribute_t** a_spec, size_t n_spec, trivia_t* a_trivia) {
        EventWait_t *n;
        n = al.make_new<EventWait_t>();
        n->base.type = stmtType::EventWait;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_variable = a_variable;
        n->m_spec = a_spec;
        n->n_spec = n_spec;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Exit_t // Constructor
    {
        const static stmtType class_type = stmtType::Exit;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        char* m_stmt_name;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Exit_t(Allocator &al, const Location &a_loc, int64_t a_label, char* a_stmt_name, trivia_t* a_trivia) {
        Exit_t *n;
        n = al.make_new<Exit_t>();
        n->base.type = stmtType::Exit;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_stmt_name = a_stmt_name;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Flush_t // Constructor
    {
        const static stmtType class_type = stmtType::Flush;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t** m_args; size_t n_args; // Sequence
        keyword_t* m_kwargs; size_t n_kwargs; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Flush_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t** a_args, size_t n_args, keyword_t* a_kwargs, size_t n_kwargs, trivia_t* a_trivia) {
        Flush_t *n;
        n = al.make_new<Flush_t>();
        n->base.type = stmtType::Flush;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_kwargs = a_kwargs;
        n->n_kwargs = n_kwargs;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct ForAllSingle_t // Constructor
    {
        const static stmtType class_type = stmtType::ForAllSingle;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        char* m_stmt_name;
        concurrent_control_t** m_control; size_t n_control; // Sequence
        expr_t* m_mask;
        stmt_t* m_assign;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_ForAllSingle_t(Allocator &al, const Location &a_loc, int64_t a_label, char* a_stmt_name, concurrent_control_t** a_control, size_t n_control, expr_t* a_mask, stmt_t* a_assign, trivia_t* a_trivia) {
        ForAllSingle_t *n;
        n = al.make_new<ForAllSingle_t>();
        n->base.type = stmtType::ForAllSingle;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_stmt_name = a_stmt_name;
        n->m_control = a_control;
        n->n_control = n_control;
        n->m_mask = a_mask;
        n->m_assign = a_assign;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Format_t // Constructor
    {
        const static stmtType class_type = stmtType::Format;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        char* m_fmt;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Format_t(Allocator &al, const Location &a_loc, int64_t a_label, char* a_fmt, trivia_t* a_trivia) {
        Format_t *n;
        n = al.make_new<Format_t>();
        n->base.type = stmtType::Format;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_fmt = a_fmt;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct FormTeam_t // Constructor
    {
        const static stmtType class_type = stmtType::FormTeam;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t* m_team_number;
        char* m_team_var;
        event_attribute_t** m_sync_stat; size_t n_sync_stat; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_FormTeam_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t* a_team_number, char* a_team_var, event_attribute_t** a_sync_stat, size_t n_sync_stat, trivia_t* a_trivia) {
        FormTeam_t *n;
        n = al.make_new<FormTeam_t>();
        n->base.type = stmtType::FormTeam;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_team_number = a_team_number;
        n->m_team_var = a_team_var;
        n->m_sync_stat = a_sync_stat;
        n->n_sync_stat = n_sync_stat;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct GoTo_t // Constructor
    {
        const static stmtType class_type = stmtType::GoTo;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        char* m_int_var;
        expr_t* m_goto_label;
        expr_t** m_labels; size_t n_labels; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_GoTo_t(Allocator &al, const Location &a_loc, int64_t a_label, char* a_int_var, expr_t* a_goto_label, expr_t** a_labels, size_t n_labels, trivia_t* a_trivia) {
        GoTo_t *n;
        n = al.make_new<GoTo_t>();
        n->base.type = stmtType::GoTo;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_int_var = a_int_var;
        n->m_goto_label = a_goto_label;
        n->m_labels = a_labels;
        n->n_labels = n_labels;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Inquire_t // Constructor
    {
        const static stmtType class_type = stmtType::Inquire;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t** m_args; size_t n_args; // Sequence
        keyword_t* m_kwargs; size_t n_kwargs; // Sequence
        expr_t** m_values; size_t n_values; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Inquire_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t** a_args, size_t n_args, keyword_t* a_kwargs, size_t n_kwargs, expr_t** a_values, size_t n_values, trivia_t* a_trivia) {
        Inquire_t *n;
        n = al.make_new<Inquire_t>();
        n->base.type = stmtType::Inquire;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_kwargs = a_kwargs;
        n->n_kwargs = n_kwargs;
        n->m_values = a_values;
        n->n_values = n_values;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Nullify_t // Constructor
    {
        const static stmtType class_type = stmtType::Nullify;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t** m_args; size_t n_args; // Sequence
        keyword_t* m_kwargs; size_t n_kwargs; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Nullify_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t** a_args, size_t n_args, keyword_t* a_kwargs, size_t n_kwargs, trivia_t* a_trivia) {
        Nullify_t *n;
        n = al.make_new<Nullify_t>();
        n->base.type = stmtType::Nullify;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_kwargs = a_kwargs;
        n->n_kwargs = n_kwargs;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Open_t // Constructor
    {
        const static stmtType class_type = stmtType::Open;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t** m_args; size_t n_args; // Sequence
        keyword_t* m_kwargs; size_t n_kwargs; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Open_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t** a_args, size_t n_args, keyword_t* a_kwargs, size_t n_kwargs, trivia_t* a_trivia) {
        Open_t *n;
        n = al.make_new<Open_t>();
        n->base.type = stmtType::Open;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_kwargs = a_kwargs;
        n->n_kwargs = n_kwargs;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Return_t // Constructor
    {
        const static stmtType class_type = stmtType::Return;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t* m_value;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Return_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t* a_value, trivia_t* a_trivia) {
        Return_t *n;
        n = al.make_new<Return_t>();
        n->base.type = stmtType::Return;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_value = a_value;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Print_t // Constructor
    {
        const static stmtType class_type = stmtType::Print;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t* m_fmt;
        expr_t** m_values; size_t n_values; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Print_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t* a_fmt, expr_t** a_values, size_t n_values, trivia_t* a_trivia) {
        Print_t *n;
        n = al.make_new<Print_t>();
        n->base.type = stmtType::Print;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_fmt = a_fmt;
        n->m_values = a_values;
        n->n_values = n_values;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Read_t // Constructor
    {
        const static stmtType class_type = stmtType::Read;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t* m_format;
        argstar_t* m_args; size_t n_args; // Sequence
        kw_argstar_t* m_kwargs; size_t n_kwargs; // Sequence
        expr_t** m_values; size_t n_values; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Read_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t* a_format, argstar_t* a_args, size_t n_args, kw_argstar_t* a_kwargs, size_t n_kwargs, expr_t** a_values, size_t n_values, trivia_t* a_trivia) {
        Read_t *n;
        n = al.make_new<Read_t>();
        n->base.type = stmtType::Read;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_format = a_format;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_kwargs = a_kwargs;
        n->n_kwargs = n_kwargs;
        n->m_values = a_values;
        n->n_values = n_values;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Rewind_t // Constructor
    {
        const static stmtType class_type = stmtType::Rewind;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t** m_args; size_t n_args; // Sequence
        keyword_t* m_kwargs; size_t n_kwargs; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Rewind_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t** a_args, size_t n_args, keyword_t* a_kwargs, size_t n_kwargs, trivia_t* a_trivia) {
        Rewind_t *n;
        n = al.make_new<Rewind_t>();
        n->base.type = stmtType::Rewind;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_kwargs = a_kwargs;
        n->n_kwargs = n_kwargs;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Stop_t // Constructor
    {
        const static stmtType class_type = stmtType::Stop;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t* m_code;
        expr_t* m_quiet;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Stop_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t* a_code, expr_t* a_quiet, trivia_t* a_trivia) {
        Stop_t *n;
        n = al.make_new<Stop_t>();
        n->base.type = stmtType::Stop;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_code = a_code;
        n->m_quiet = a_quiet;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct SubroutineCall_t // Constructor
    {
        const static stmtType class_type = stmtType::SubroutineCall;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        char* m_name;
        struct_member_t* m_member; size_t n_member; // Sequence
        fnarg_t* m_args; size_t n_args; // Sequence
        keyword_t* m_keywords; size_t n_keywords; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_SubroutineCall_t(Allocator &al, const Location &a_loc, int64_t a_label, char* a_name, struct_member_t* a_member, size_t n_member, fnarg_t* a_args, size_t n_args, keyword_t* a_keywords, size_t n_keywords, trivia_t* a_trivia) {
        SubroutineCall_t *n;
        n = al.make_new<SubroutineCall_t>();
        n->base.type = stmtType::SubroutineCall;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_name = a_name;
        n->m_member = a_member;
        n->n_member = n_member;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_keywords = a_keywords;
        n->n_keywords = n_keywords;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct SyncAll_t // Constructor
    {
        const static stmtType class_type = stmtType::SyncAll;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        event_attribute_t** m_stat; size_t n_stat; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_SyncAll_t(Allocator &al, const Location &a_loc, int64_t a_label, event_attribute_t** a_stat, size_t n_stat, trivia_t* a_trivia) {
        SyncAll_t *n;
        n = al.make_new<SyncAll_t>();
        n->base.type = stmtType::SyncAll;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_stat = a_stat;
        n->n_stat = n_stat;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct SyncImages_t // Constructor
    {
        const static stmtType class_type = stmtType::SyncImages;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t* m_image_set;
        symbolType m_sym;
        event_attribute_t** m_stat; size_t n_stat; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_SyncImages_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t* a_image_set, symbolType a_sym, event_attribute_t** a_stat, size_t n_stat, trivia_t* a_trivia) {
        SyncImages_t *n;
        n = al.make_new<SyncImages_t>();
        n->base.type = stmtType::SyncImages;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_image_set = a_image_set;
        n->m_sym = a_sym;
        n->m_stat = a_stat;
        n->n_stat = n_stat;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct SyncMemory_t // Constructor
    {
        const static stmtType class_type = stmtType::SyncMemory;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        event_attribute_t** m_stat; size_t n_stat; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_SyncMemory_t(Allocator &al, const Location &a_loc, int64_t a_label, event_attribute_t** a_stat, size_t n_stat, trivia_t* a_trivia) {
        SyncMemory_t *n;
        n = al.make_new<SyncMemory_t>();
        n->base.type = stmtType::SyncMemory;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_stat = a_stat;
        n->n_stat = n_stat;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct SyncTeam_t // Constructor
    {
        const static stmtType class_type = stmtType::SyncTeam;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        expr_t* m_value;
        event_attribute_t** m_stat; size_t n_stat; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_SyncTeam_t(Allocator &al, const Location &a_loc, int64_t a_label, expr_t* a_value, event_attribute_t** a_stat, size_t n_stat, trivia_t* a_trivia) {
        SyncTeam_t *n;
        n = al.make_new<SyncTeam_t>();
        n->base.type = stmtType::SyncTeam;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_value = a_value;
        n->m_stat = a_stat;
        n->n_stat = n_stat;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Write_t // Constructor
    {
        const static stmtType class_type = stmtType::Write;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        argstar_t* m_args; size_t n_args; // Sequence
        kw_argstar_t* m_kwargs; size_t n_kwargs; // Sequence
        expr_t** m_values; size_t n_values; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Write_t(Allocator &al, const Location &a_loc, int64_t a_label, argstar_t* a_args, size_t n_args, kw_argstar_t* a_kwargs, size_t n_kwargs, expr_t** a_values, size_t n_values, trivia_t* a_trivia) {
        Write_t *n;
        n = al.make_new<Write_t>();
        n->base.type = stmtType::Write;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_kwargs = a_kwargs;
        n->n_kwargs = n_kwargs;
        n->m_values = a_values;
        n->n_values = n_values;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct AssociateBlock_t // Constructor
    {
        const static stmtType class_type = stmtType::AssociateBlock;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        char* m_stmt_name;
        var_sym_t* m_syms; size_t n_syms; // Sequence
        stmt_t** m_body; size_t n_body; // Sequence
        trivia_t* m_t_inside;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_AssociateBlock_t(Allocator &al, const Location &a_loc, int64_t a_label, char* a_stmt_name, var_sym_t* a_syms, size_t n_syms, stmt_t** a_body, size_t n_body, trivia_t* a_t_inside, trivia_t* a_trivia) {
        AssociateBlock_t *n;
        n = al.make_new<AssociateBlock_t>();
        n->base.type = stmtType::AssociateBlock;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_stmt_name = a_stmt_name;
        n->m_syms = a_syms;
        n->n_syms = n_syms;
        n->m_body = a_body;
        n->n_body = n_body;
        n->m_t_inside = a_t_inside;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Block_t // Constructor
    {
        const static stmtType class_type = stmtType::Block;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        char* m_stmt_name;
        unit_decl1_t** m_use; size_t n_use; // Sequence
        import_statement_t** m_import; size_t n_import; // Sequence
        unit_decl2_t** m_decl; size_t n_decl; // Sequence
        stmt_t** m_body; size_t n_body; // Sequence
        trivia_t* m_t_inside;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Block_t(Allocator &al, const Location &a_loc, int64_t a_label, char* a_stmt_name, unit_decl1_t** a_use, size_t n_use, import_statement_t** a_import, size_t n_import, unit_decl2_t** a_decl, size_t n_decl, stmt_t** a_body, size_t n_body, trivia_t* a_t_inside, trivia_t* a_trivia) {
        Block_t *n;
        n = al.make_new<Block_t>();
        n->base.type = stmtType::Block;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_stmt_name = a_stmt_name;
        n->m_use = a_use;
        n->n_use = n_use;
        n->m_import = a_import;
        n->n_import = n_import;
        n->m_decl = a_decl;
        n->n_decl = n_decl;
        n->m_body = a_body;
        n->n_body = n_body;
        n->m_t_inside = a_t_inside;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct ChangeTeam_t // Constructor
    {
        const static stmtType class_type = stmtType::ChangeTeam;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        char* m_stmt_name;
        expr_t* m_team_value;
        team_attribute_t** m_coarray_assoc; size_t n_coarray_assoc; // Sequence
        event_attribute_t** m_sync; size_t n_sync; // Sequence
        stmt_t** m_body; size_t n_body; // Sequence
        trivia_t* m_t_inside;
        trivia_t* m_trivia;
        event_attribute_t** m_sync_stat; size_t n_sync_stat; // Sequence
    };
    static inline ast_t* make_ChangeTeam_t(Allocator &al, const Location &a_loc, int64_t a_label, char* a_stmt_name, expr_t* a_team_value, team_attribute_t** a_coarray_assoc, size_t n_coarray_assoc, event_attribute_t** a_sync, size_t n_sync, stmt_t** a_body, size_t n_body, trivia_t* a_t_inside, trivia_t* a_trivia, event_attribute_t** a_sync_stat, size_t n_sync_stat) {
        ChangeTeam_t *n;
        n = al.make_new<ChangeTeam_t>();
        n->base.type = stmtType::ChangeTeam;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_stmt_name = a_stmt_name;
        n->m_team_value = a_team_value;
        n->m_coarray_assoc = a_coarray_assoc;
        n->n_coarray_assoc = n_coarray_assoc;
        n->m_sync = a_sync;
        n->n_sync = n_sync;
        n->m_body = a_body;
        n->n_body = n_body;
        n->m_t_inside = a_t_inside;
        n->m_trivia = a_trivia;
        n->m_sync_stat = a_sync_stat;
        n->n_sync_stat = n_sync_stat;
        return (ast_t*)n;
    }

    struct Critical_t // Constructor
    {
        const static stmtType class_type = stmtType::Critical;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        char* m_stmt_name;
        event_attribute_t** m_sync_stat; size_t n_sync_stat; // Sequence
        stmt_t** m_body; size_t n_body; // Sequence
        trivia_t* m_t_inside;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Critical_t(Allocator &al, const Location &a_loc, int64_t a_label, char* a_stmt_name, event_attribute_t** a_sync_stat, size_t n_sync_stat, stmt_t** a_body, size_t n_body, trivia_t* a_t_inside, trivia_t* a_trivia) {
        Critical_t *n;
        n = al.make_new<Critical_t>();
        n->base.type = stmtType::Critical;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_stmt_name = a_stmt_name;
        n->m_sync_stat = a_sync_stat;
        n->n_sync_stat = n_sync_stat;
        n->m_body = a_body;
        n->n_body = n_body;
        n->m_t_inside = a_t_inside;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct DoConcurrentLoop_t // Constructor
    {
        const static stmtType class_type = stmtType::DoConcurrentLoop;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        char* m_stmt_name;
        concurrent_control_t** m_control; size_t n_control; // Sequence
        expr_t* m_mask;
        concurrent_locality_t** m_locality; size_t n_locality; // Sequence
        stmt_t** m_body; size_t n_body; // Sequence
        trivia_t* m_t_inside;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_DoConcurrentLoop_t(Allocator &al, const Location &a_loc, int64_t a_label, char* a_stmt_name, concurrent_control_t** a_control, size_t n_control, expr_t* a_mask, concurrent_locality_t** a_locality, size_t n_locality, stmt_t** a_body, size_t n_body, trivia_t* a_t_inside, trivia_t* a_trivia) {
        DoConcurrentLoop_t *n;
        n = al.make_new<DoConcurrentLoop_t>();
        n->base.type = stmtType::DoConcurrentLoop;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_stmt_name = a_stmt_name;
        n->m_control = a_control;
        n->n_control = n_control;
        n->m_mask = a_mask;
        n->m_locality = a_locality;
        n->n_locality = n_locality;
        n->m_body = a_body;
        n->n_body = n_body;
        n->m_t_inside = a_t_inside;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct DoLoop_t // Constructor
    {
        const static stmtType class_type = stmtType::DoLoop;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        char* m_stmt_name;
        int64_t m_do_label;
        char* m_var;
        expr_t* m_start;
        expr_t* m_end;
        expr_t* m_increment;
        stmt_t** m_body; size_t n_body; // Sequence
        trivia_t* m_t_inside;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_DoLoop_t(Allocator &al, const Location &a_loc, int64_t a_label, char* a_stmt_name, int64_t a_do_label, char* a_var, expr_t* a_start, expr_t* a_end, expr_t* a_increment, stmt_t** a_body, size_t n_body, trivia_t* a_t_inside, trivia_t* a_trivia) {
        DoLoop_t *n;
        n = al.make_new<DoLoop_t>();
        n->base.type = stmtType::DoLoop;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_stmt_name = a_stmt_name;
        n->m_do_label = a_do_label;
        n->m_var = a_var;
        n->m_start = a_start;
        n->m_end = a_end;
        n->m_increment = a_increment;
        n->m_body = a_body;
        n->n_body = n_body;
        n->m_t_inside = a_t_inside;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct ForAll_t // Constructor
    {
        const static stmtType class_type = stmtType::ForAll;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        char* m_stmt_name;
        concurrent_control_t** m_control; size_t n_control; // Sequence
        expr_t* m_mask;
        concurrent_locality_t** m_locality; size_t n_locality; // Sequence
        stmt_t** m_body; size_t n_body; // Sequence
        trivia_t* m_t_inside;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_ForAll_t(Allocator &al, const Location &a_loc, int64_t a_label, char* a_stmt_name, concurrent_control_t** a_control, size_t n_control, expr_t* a_mask, concurrent_locality_t** a_locality, size_t n_locality, stmt_t** a_body, size_t n_body, trivia_t* a_t_inside, trivia_t* a_trivia) {
        ForAll_t *n;
        n = al.make_new<ForAll_t>();
        n->base.type = stmtType::ForAll;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_stmt_name = a_stmt_name;
        n->m_control = a_control;
        n->n_control = n_control;
        n->m_mask = a_mask;
        n->m_locality = a_locality;
        n->n_locality = n_locality;
        n->m_body = a_body;
        n->n_body = n_body;
        n->m_t_inside = a_t_inside;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct If_t // Constructor
    {
        const static stmtType class_type = stmtType::If;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        char* m_stmt_name;
        expr_t* m_test;
        stmt_t** m_body; size_t n_body; // Sequence
        stmt_t** m_orelse; size_t n_orelse; // Sequence
        trivia_t* m_if_trivia;
        trivia_t* m_else_trivia;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_If_t(Allocator &al, const Location &a_loc, int64_t a_label, char* a_stmt_name, expr_t* a_test, stmt_t** a_body, size_t n_body, stmt_t** a_orelse, size_t n_orelse, trivia_t* a_if_trivia, trivia_t* a_else_trivia, trivia_t* a_trivia) {
        If_t *n;
        n = al.make_new<If_t>();
        n->base.type = stmtType::If;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_stmt_name = a_stmt_name;
        n->m_test = a_test;
        n->m_body = a_body;
        n->n_body = n_body;
        n->m_orelse = a_orelse;
        n->n_orelse = n_orelse;
        n->m_if_trivia = a_if_trivia;
        n->m_else_trivia = a_else_trivia;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct IfArithmetic_t // Constructor
    {
        const static stmtType class_type = stmtType::IfArithmetic;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        char* m_stmt_name;
        expr_t* m_test;
        int64_t m_lt_label;
        int64_t m_eq_label;
        int64_t m_gt_label;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_IfArithmetic_t(Allocator &al, const Location &a_loc, int64_t a_label, char* a_stmt_name, expr_t* a_test, int64_t a_lt_label, int64_t a_eq_label, int64_t a_gt_label, trivia_t* a_trivia) {
        IfArithmetic_t *n;
        n = al.make_new<IfArithmetic_t>();
        n->base.type = stmtType::IfArithmetic;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_stmt_name = a_stmt_name;
        n->m_test = a_test;
        n->m_lt_label = a_lt_label;
        n->m_eq_label = a_eq_label;
        n->m_gt_label = a_gt_label;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Select_t // Constructor
    {
        const static stmtType class_type = stmtType::Select;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        char* m_stmt_name;
        expr_t* m_test;
        case_stmt_t** m_body; size_t n_body; // Sequence
        trivia_t* m_t_inside;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Select_t(Allocator &al, const Location &a_loc, int64_t a_label, char* a_stmt_name, expr_t* a_test, case_stmt_t** a_body, size_t n_body, trivia_t* a_t_inside, trivia_t* a_trivia) {
        Select_t *n;
        n = al.make_new<Select_t>();
        n->base.type = stmtType::Select;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_stmt_name = a_stmt_name;
        n->m_test = a_test;
        n->m_body = a_body;
        n->n_body = n_body;
        n->m_t_inside = a_t_inside;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct SelectRank_t // Constructor
    {
        const static stmtType class_type = stmtType::SelectRank;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        char* m_stmt_name;
        char* m_assoc_name;
        expr_t* m_selector;
        rank_stmt_t** m_body; size_t n_body; // Sequence
        trivia_t* m_t_inside;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_SelectRank_t(Allocator &al, const Location &a_loc, int64_t a_label, char* a_stmt_name, char* a_assoc_name, expr_t* a_selector, rank_stmt_t** a_body, size_t n_body, trivia_t* a_t_inside, trivia_t* a_trivia) {
        SelectRank_t *n;
        n = al.make_new<SelectRank_t>();
        n->base.type = stmtType::SelectRank;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_stmt_name = a_stmt_name;
        n->m_assoc_name = a_assoc_name;
        n->m_selector = a_selector;
        n->m_body = a_body;
        n->n_body = n_body;
        n->m_t_inside = a_t_inside;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct SelectType_t // Constructor
    {
        const static stmtType class_type = stmtType::SelectType;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        char* m_stmt_name;
        char* m_assoc_name;
        expr_t* m_selector;
        type_stmt_t** m_body; size_t n_body; // Sequence
        trivia_t* m_t_inside;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_SelectType_t(Allocator &al, const Location &a_loc, int64_t a_label, char* a_stmt_name, char* a_assoc_name, expr_t* a_selector, type_stmt_t** a_body, size_t n_body, trivia_t* a_t_inside, trivia_t* a_trivia) {
        SelectType_t *n;
        n = al.make_new<SelectType_t>();
        n->base.type = stmtType::SelectType;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_stmt_name = a_stmt_name;
        n->m_assoc_name = a_assoc_name;
        n->m_selector = a_selector;
        n->m_body = a_body;
        n->n_body = n_body;
        n->m_t_inside = a_t_inside;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Where_t // Constructor
    {
        const static stmtType class_type = stmtType::Where;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        char* m_stmt_name;
        expr_t* m_test;
        stmt_t** m_body; size_t n_body; // Sequence
        stmt_t** m_orelse; size_t n_orelse; // Sequence
        trivia_t* m_t_inside;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Where_t(Allocator &al, const Location &a_loc, int64_t a_label, char* a_stmt_name, expr_t* a_test, stmt_t** a_body, size_t n_body, stmt_t** a_orelse, size_t n_orelse, trivia_t* a_t_inside, trivia_t* a_trivia) {
        Where_t *n;
        n = al.make_new<Where_t>();
        n->base.type = stmtType::Where;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_stmt_name = a_stmt_name;
        n->m_test = a_test;
        n->m_body = a_body;
        n->n_body = n_body;
        n->m_orelse = a_orelse;
        n->n_orelse = n_orelse;
        n->m_t_inside = a_t_inside;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct WhileLoop_t // Constructor
    {
        const static stmtType class_type = stmtType::WhileLoop;
        typedef stmt_t parent_type;
        stmt_t base;
        int64_t m_label;
        char* m_stmt_name;
        expr_t* m_test;
        stmt_t** m_body; size_t n_body; // Sequence
        trivia_t* m_t_inside;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_WhileLoop_t(Allocator &al, const Location &a_loc, int64_t a_label, char* a_stmt_name, expr_t* a_test, stmt_t** a_body, size_t n_body, trivia_t* a_t_inside, trivia_t* a_trivia) {
        WhileLoop_t *n;
        n = al.make_new<WhileLoop_t>();
        n->base.type = stmtType::WhileLoop;
        n->base.base.type = astType::stmt;
        n->base.base.loc = a_loc;
        n->m_label = a_label;
        n->m_stmt_name = a_stmt_name;
        n->m_test = a_test;
        n->m_body = a_body;
        n->n_body = n_body;
        n->m_t_inside = a_t_inside;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }



enum exprType // Types
{
    BoolOp, BinOp, DefBinOp, StrOp, UnaryOp, DefUnaryOp, Compare, FuncCallOrArray, CoarrayRef, ArrayInitializer, ImpliedDoLoop, Num, Real, Complex, String, Substring, BOZ, Name, Logical, DataImpliedDo, Parenthesis
};

struct expr_t // Sum
{
    const static astType class_type = astType::expr;
    ast_t base;
    exprType type;
};

    struct BoolOp_t // Constructor
    {
        const static exprType class_type = exprType::BoolOp;
        typedef expr_t parent_type;
        expr_t base;
        expr_t* m_left;
        boolopType m_op;
        expr_t* m_right;
    };
    static inline ast_t* make_BoolOp_t(Allocator &al, const Location &a_loc, expr_t* a_left, boolopType a_op, expr_t* a_right) {
        BoolOp_t *n;
        n = al.make_new<BoolOp_t>();
        n->base.type = exprType::BoolOp;
        n->base.base.type = astType::expr;
        n->base.base.loc = a_loc;
        n->m_left = a_left;
        n->m_op = a_op;
        n->m_right = a_right;
        return (ast_t*)n;
    }

    struct BinOp_t // Constructor
    {
        const static exprType class_type = exprType::BinOp;
        typedef expr_t parent_type;
        expr_t base;
        expr_t* m_left;
        operatorType m_op;
        expr_t* m_right;
    };
    static inline ast_t* make_BinOp_t(Allocator &al, const Location &a_loc, expr_t* a_left, operatorType a_op, expr_t* a_right) {
        BinOp_t *n;
        n = al.make_new<BinOp_t>();
        n->base.type = exprType::BinOp;
        n->base.base.type = astType::expr;
        n->base.base.loc = a_loc;
        n->m_left = a_left;
        n->m_op = a_op;
        n->m_right = a_right;
        return (ast_t*)n;
    }

    struct DefBinOp_t // Constructor
    {
        const static exprType class_type = exprType::DefBinOp;
        typedef expr_t parent_type;
        expr_t base;
        expr_t* m_left;
        char* m_op;
        expr_t* m_right;
    };
    static inline ast_t* make_DefBinOp_t(Allocator &al, const Location &a_loc, expr_t* a_left, char* a_op, expr_t* a_right) {
        DefBinOp_t *n;
        n = al.make_new<DefBinOp_t>();
        n->base.type = exprType::DefBinOp;
        n->base.base.type = astType::expr;
        n->base.base.loc = a_loc;
        n->m_left = a_left;
        n->m_op = a_op;
        n->m_right = a_right;
        return (ast_t*)n;
    }

    struct StrOp_t // Constructor
    {
        const static exprType class_type = exprType::StrOp;
        typedef expr_t parent_type;
        expr_t base;
        expr_t* m_left;
        stroperatorType m_op;
        expr_t* m_right;
    };
    static inline ast_t* make_StrOp_t(Allocator &al, const Location &a_loc, expr_t* a_left, stroperatorType a_op, expr_t* a_right) {
        StrOp_t *n;
        n = al.make_new<StrOp_t>();
        n->base.type = exprType::StrOp;
        n->base.base.type = astType::expr;
        n->base.base.loc = a_loc;
        n->m_left = a_left;
        n->m_op = a_op;
        n->m_right = a_right;
        return (ast_t*)n;
    }

    struct UnaryOp_t // Constructor
    {
        const static exprType class_type = exprType::UnaryOp;
        typedef expr_t parent_type;
        expr_t base;
        unaryopType m_op;
        expr_t* m_operand;
    };
    static inline ast_t* make_UnaryOp_t(Allocator &al, const Location &a_loc, unaryopType a_op, expr_t* a_operand) {
        UnaryOp_t *n;
        n = al.make_new<UnaryOp_t>();
        n->base.type = exprType::UnaryOp;
        n->base.base.type = astType::expr;
        n->base.base.loc = a_loc;
        n->m_op = a_op;
        n->m_operand = a_operand;
        return (ast_t*)n;
    }

    struct DefUnaryOp_t // Constructor
    {
        const static exprType class_type = exprType::DefUnaryOp;
        typedef expr_t parent_type;
        expr_t base;
        char* m_op;
        expr_t* m_operand;
    };
    static inline ast_t* make_DefUnaryOp_t(Allocator &al, const Location &a_loc, char* a_op, expr_t* a_operand) {
        DefUnaryOp_t *n;
        n = al.make_new<DefUnaryOp_t>();
        n->base.type = exprType::DefUnaryOp;
        n->base.base.type = astType::expr;
        n->base.base.loc = a_loc;
        n->m_op = a_op;
        n->m_operand = a_operand;
        return (ast_t*)n;
    }

    struct Compare_t // Constructor
    {
        const static exprType class_type = exprType::Compare;
        typedef expr_t parent_type;
        expr_t base;
        expr_t* m_left;
        cmpopType m_op;
        expr_t* m_right;
    };
    static inline ast_t* make_Compare_t(Allocator &al, const Location &a_loc, expr_t* a_left, cmpopType a_op, expr_t* a_right) {
        Compare_t *n;
        n = al.make_new<Compare_t>();
        n->base.type = exprType::Compare;
        n->base.base.type = astType::expr;
        n->base.base.loc = a_loc;
        n->m_left = a_left;
        n->m_op = a_op;
        n->m_right = a_right;
        return (ast_t*)n;
    }

    struct FuncCallOrArray_t // Constructor
    {
        const static exprType class_type = exprType::FuncCallOrArray;
        typedef expr_t parent_type;
        expr_t base;
        char* m_func;
        struct_member_t* m_member; size_t n_member; // Sequence
        fnarg_t* m_args; size_t n_args; // Sequence
        keyword_t* m_keywords; size_t n_keywords; // Sequence
        fnarg_t* m_subargs; size_t n_subargs; // Sequence
    };
    static inline ast_t* make_FuncCallOrArray_t(Allocator &al, const Location &a_loc, char* a_func, struct_member_t* a_member, size_t n_member, fnarg_t* a_args, size_t n_args, keyword_t* a_keywords, size_t n_keywords, fnarg_t* a_subargs, size_t n_subargs) {
        FuncCallOrArray_t *n;
        n = al.make_new<FuncCallOrArray_t>();
        n->base.type = exprType::FuncCallOrArray;
        n->base.base.type = astType::expr;
        n->base.base.loc = a_loc;
        n->m_func = a_func;
        n->m_member = a_member;
        n->n_member = n_member;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_keywords = a_keywords;
        n->n_keywords = n_keywords;
        n->m_subargs = a_subargs;
        n->n_subargs = n_subargs;
        return (ast_t*)n;
    }

    struct CoarrayRef_t // Constructor
    {
        const static exprType class_type = exprType::CoarrayRef;
        typedef expr_t parent_type;
        expr_t base;
        char* m_name;
        struct_member_t* m_member; size_t n_member; // Sequence
        fnarg_t* m_args; size_t n_args; // Sequence
        keyword_t* m_fnkw; size_t n_fnkw; // Sequence
        coarrayarg_t* m_coargs; size_t n_coargs; // Sequence
        keyword_t* m_cokw; size_t n_cokw; // Sequence
    };
    static inline ast_t* make_CoarrayRef_t(Allocator &al, const Location &a_loc, char* a_name, struct_member_t* a_member, size_t n_member, fnarg_t* a_args, size_t n_args, keyword_t* a_fnkw, size_t n_fnkw, coarrayarg_t* a_coargs, size_t n_coargs, keyword_t* a_cokw, size_t n_cokw) {
        CoarrayRef_t *n;
        n = al.make_new<CoarrayRef_t>();
        n->base.type = exprType::CoarrayRef;
        n->base.base.type = astType::expr;
        n->base.base.loc = a_loc;
        n->m_name = a_name;
        n->m_member = a_member;
        n->n_member = n_member;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_fnkw = a_fnkw;
        n->n_fnkw = n_fnkw;
        n->m_coargs = a_coargs;
        n->n_coargs = n_coargs;
        n->m_cokw = a_cokw;
        n->n_cokw = n_cokw;
        return (ast_t*)n;
    }

    struct ArrayInitializer_t // Constructor
    {
        const static exprType class_type = exprType::ArrayInitializer;
        typedef expr_t parent_type;
        expr_t base;
        decl_attribute_t* m_vartype;
        char* m_classtype;
        expr_t** m_args; size_t n_args; // Sequence
    };
    static inline ast_t* make_ArrayInitializer_t(Allocator &al, const Location &a_loc, decl_attribute_t* a_vartype, char* a_classtype, expr_t** a_args, size_t n_args) {
        ArrayInitializer_t *n;
        n = al.make_new<ArrayInitializer_t>();
        n->base.type = exprType::ArrayInitializer;
        n->base.base.type = astType::expr;
        n->base.base.loc = a_loc;
        n->m_vartype = a_vartype;
        n->m_classtype = a_classtype;
        n->m_args = a_args;
        n->n_args = n_args;
        return (ast_t*)n;
    }

    struct ImpliedDoLoop_t // Constructor
    {
        const static exprType class_type = exprType::ImpliedDoLoop;
        typedef expr_t parent_type;
        expr_t base;
        expr_t** m_values; size_t n_values; // Sequence
        char* m_var;
        expr_t* m_start;
        expr_t* m_end;
        expr_t* m_increment;
    };
    static inline ast_t* make_ImpliedDoLoop_t(Allocator &al, const Location &a_loc, expr_t** a_values, size_t n_values, char* a_var, expr_t* a_start, expr_t* a_end, expr_t* a_increment) {
        ImpliedDoLoop_t *n;
        n = al.make_new<ImpliedDoLoop_t>();
        n->base.type = exprType::ImpliedDoLoop;
        n->base.base.type = astType::expr;
        n->base.base.loc = a_loc;
        n->m_values = a_values;
        n->n_values = n_values;
        n->m_var = a_var;
        n->m_start = a_start;
        n->m_end = a_end;
        n->m_increment = a_increment;
        return (ast_t*)n;
    }

    struct Num_t // Constructor
    {
        const static exprType class_type = exprType::Num;
        typedef expr_t parent_type;
        expr_t base;
        int64_t m_n;
        char* m_kind;
    };
    static inline ast_t* make_Num_t(Allocator &al, const Location &a_loc, int64_t a_n, char* a_kind) {
        Num_t *n;
        n = al.make_new<Num_t>();
        n->base.type = exprType::Num;
        n->base.base.type = astType::expr;
        n->base.base.loc = a_loc;
        n->m_n = a_n;
        n->m_kind = a_kind;
        return (ast_t*)n;
    }

    struct Real_t // Constructor
    {
        const static exprType class_type = exprType::Real;
        typedef expr_t parent_type;
        expr_t base;
        char* m_n;
    };
    static inline ast_t* make_Real_t(Allocator &al, const Location &a_loc, char* a_n) {
        Real_t *n;
        n = al.make_new<Real_t>();
        n->base.type = exprType::Real;
        n->base.base.type = astType::expr;
        n->base.base.loc = a_loc;
        n->m_n = a_n;
        return (ast_t*)n;
    }

    struct Complex_t // Constructor
    {
        const static exprType class_type = exprType::Complex;
        typedef expr_t parent_type;
        expr_t base;
        expr_t* m_re;
        expr_t* m_im;
    };
    static inline ast_t* make_Complex_t(Allocator &al, const Location &a_loc, expr_t* a_re, expr_t* a_im) {
        Complex_t *n;
        n = al.make_new<Complex_t>();
        n->base.type = exprType::Complex;
        n->base.base.type = astType::expr;
        n->base.base.loc = a_loc;
        n->m_re = a_re;
        n->m_im = a_im;
        return (ast_t*)n;
    }

    struct String_t // Constructor
    {
        const static exprType class_type = exprType::String;
        typedef expr_t parent_type;
        expr_t base;
        char* m_s;
    };
    static inline ast_t* make_String_t(Allocator &al, const Location &a_loc, char* a_s) {
        String_t *n;
        n = al.make_new<String_t>();
        n->base.type = exprType::String;
        n->base.base.type = astType::expr;
        n->base.base.loc = a_loc;
        n->m_s = a_s;
        return (ast_t*)n;
    }

    struct Substring_t // Constructor
    {
        const static exprType class_type = exprType::Substring;
        typedef expr_t parent_type;
        expr_t base;
        char* m_s;
        fnarg_t* m_args; size_t n_args; // Sequence
    };
    static inline ast_t* make_Substring_t(Allocator &al, const Location &a_loc, char* a_s, fnarg_t* a_args, size_t n_args) {
        Substring_t *n;
        n = al.make_new<Substring_t>();
        n->base.type = exprType::Substring;
        n->base.base.type = astType::expr;
        n->base.base.loc = a_loc;
        n->m_s = a_s;
        n->m_args = a_args;
        n->n_args = n_args;
        return (ast_t*)n;
    }

    struct BOZ_t // Constructor
    {
        const static exprType class_type = exprType::BOZ;
        typedef expr_t parent_type;
        expr_t base;
        char* m_s;
    };
    static inline ast_t* make_BOZ_t(Allocator &al, const Location &a_loc, char* a_s) {
        BOZ_t *n;
        n = al.make_new<BOZ_t>();
        n->base.type = exprType::BOZ;
        n->base.base.type = astType::expr;
        n->base.base.loc = a_loc;
        n->m_s = a_s;
        return (ast_t*)n;
    }

    struct Name_t // Constructor
    {
        const static exprType class_type = exprType::Name;
        typedef expr_t parent_type;
        expr_t base;
        char* m_id;
        struct_member_t* m_member; size_t n_member; // Sequence
    };
    static inline ast_t* make_Name_t(Allocator &al, const Location &a_loc, char* a_id, struct_member_t* a_member, size_t n_member) {
        Name_t *n;
        n = al.make_new<Name_t>();
        n->base.type = exprType::Name;
        n->base.base.type = astType::expr;
        n->base.base.loc = a_loc;
        n->m_id = a_id;
        n->m_member = a_member;
        n->n_member = n_member;
        return (ast_t*)n;
    }

    struct Logical_t // Constructor
    {
        const static exprType class_type = exprType::Logical;
        typedef expr_t parent_type;
        expr_t base;
        bool m_value;
    };
    static inline ast_t* make_Logical_t(Allocator &al, const Location &a_loc, bool a_value) {
        Logical_t *n;
        n = al.make_new<Logical_t>();
        n->base.type = exprType::Logical;
        n->base.base.type = astType::expr;
        n->base.base.loc = a_loc;
        n->m_value = a_value;
        return (ast_t*)n;
    }

    struct DataImpliedDo_t // Constructor
    {
        const static exprType class_type = exprType::DataImpliedDo;
        typedef expr_t parent_type;
        expr_t base;
        expr_t** m_object_list; size_t n_object_list; // Sequence
        decl_attribute_t* m_type;
        char* m_var;
        expr_t* m_start;
        expr_t* m_end;
        expr_t* m_increment;
    };
    static inline ast_t* make_DataImpliedDo_t(Allocator &al, const Location &a_loc, expr_t** a_object_list, size_t n_object_list, decl_attribute_t* a_type, char* a_var, expr_t* a_start, expr_t* a_end, expr_t* a_increment) {
        DataImpliedDo_t *n;
        n = al.make_new<DataImpliedDo_t>();
        n->base.type = exprType::DataImpliedDo;
        n->base.base.type = astType::expr;
        n->base.base.loc = a_loc;
        n->m_object_list = a_object_list;
        n->n_object_list = n_object_list;
        n->m_type = a_type;
        n->m_var = a_var;
        n->m_start = a_start;
        n->m_end = a_end;
        n->m_increment = a_increment;
        return (ast_t*)n;
    }

    struct Parenthesis_t // Constructor
    {
        const static exprType class_type = exprType::Parenthesis;
        typedef expr_t parent_type;
        expr_t base;
        expr_t* m_operand;
    };
    static inline ast_t* make_Parenthesis_t(Allocator &al, const Location &a_loc, expr_t* a_operand) {
        Parenthesis_t *n;
        n = al.make_new<Parenthesis_t>();
        n->base.type = exprType::Parenthesis;
        n->base.base.type = astType::expr;
        n->base.base.loc = a_loc;
        n->m_operand = a_operand;
        return (ast_t*)n;
    }



enum triviaType // Types
{
    TriviaNode
};

struct trivia_t // Sum
{
    const static astType class_type = astType::trivia;
    ast_t base;
    triviaType type;
};

    struct TriviaNode_t // Constructor
    {
        const static triviaType class_type = triviaType::TriviaNode;
        typedef trivia_t parent_type;
        trivia_t base;
        trivia_node_t** m_inside; size_t n_inside; // Sequence
        trivia_node_t** m_after; size_t n_after; // Sequence
    };
    static inline ast_t* make_TriviaNode_t(Allocator &al, const Location &a_loc, trivia_node_t** a_inside, size_t n_inside, trivia_node_t** a_after, size_t n_after) {
        TriviaNode_t *n;
        n = al.make_new<TriviaNode_t>();
        n->base.type = triviaType::TriviaNode;
        n->base.base.type = astType::trivia;
        n->base.base.loc = a_loc;
        n->m_inside = a_inside;
        n->n_inside = n_inside;
        n->m_after = a_after;
        n->n_after = n_after;
        return (ast_t*)n;
    }



enum trivia_nodeType // Types
{
    Comment, EOLComment, EndOfLine, Semicolon
};

struct trivia_node_t // Sum
{
    const static astType class_type = astType::trivia_node;
    ast_t base;
    trivia_nodeType type;
};

    struct Comment_t // Constructor
    {
        const static trivia_nodeType class_type = trivia_nodeType::Comment;
        typedef trivia_node_t parent_type;
        trivia_node_t base;
        char* m_comment;
    };
    static inline ast_t* make_Comment_t(Allocator &al, const Location &a_loc, char* a_comment) {
        Comment_t *n;
        n = al.make_new<Comment_t>();
        n->base.type = trivia_nodeType::Comment;
        n->base.base.type = astType::trivia_node;
        n->base.base.loc = a_loc;
        n->m_comment = a_comment;
        return (ast_t*)n;
    }

    struct EOLComment_t // Constructor
    {
        const static trivia_nodeType class_type = trivia_nodeType::EOLComment;
        typedef trivia_node_t parent_type;
        trivia_node_t base;
        char* m_comment;
    };
    static inline ast_t* make_EOLComment_t(Allocator &al, const Location &a_loc, char* a_comment) {
        EOLComment_t *n;
        n = al.make_new<EOLComment_t>();
        n->base.type = trivia_nodeType::EOLComment;
        n->base.base.type = astType::trivia_node;
        n->base.base.loc = a_loc;
        n->m_comment = a_comment;
        return (ast_t*)n;
    }

    struct EndOfLine_t // Constructor
    {
        const static trivia_nodeType class_type = trivia_nodeType::EndOfLine;
        typedef trivia_node_t parent_type;
        trivia_node_t base;
    };
    static inline ast_t* make_EndOfLine_t(Allocator &al, const Location &a_loc) {
        EndOfLine_t *n;
        n = al.make_new<EndOfLine_t>();
        n->base.type = trivia_nodeType::EndOfLine;
        n->base.base.type = astType::trivia_node;
        n->base.base.loc = a_loc;
        return (ast_t*)n;
    }

    struct Semicolon_t // Constructor
    {
        const static trivia_nodeType class_type = trivia_nodeType::Semicolon;
        typedef trivia_node_t parent_type;
        trivia_node_t base;
    };
    static inline ast_t* make_Semicolon_t(Allocator &al, const Location &a_loc) {
        Semicolon_t *n;
        n = al.make_new<Semicolon_t>();
        n->base.type = trivia_nodeType::Semicolon;
        n->base.base.type = astType::trivia_node;
        n->base.base.loc = a_loc;
        return (ast_t*)n;
    }



enum procedure_declType // Types
{
    DerivedTypeProc, GenericOperator, GenericDefinedOperator, GenericAssignment, GenericName, GenericWrite, GenericRead, FinalName, Private
};

struct procedure_decl_t // Sum
{
    const static astType class_type = astType::procedure_decl;
    ast_t base;
    procedure_declType type;
};

    struct DerivedTypeProc_t // Constructor
    {
        const static procedure_declType class_type = procedure_declType::DerivedTypeProc;
        typedef procedure_decl_t parent_type;
        procedure_decl_t base;
        char* m_name;
        decl_attribute_t** m_attr; size_t n_attr; // Sequence
        use_symbol_t** m_symbols; size_t n_symbols; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_DerivedTypeProc_t(Allocator &al, const Location &a_loc, char* a_name, decl_attribute_t** a_attr, size_t n_attr, use_symbol_t** a_symbols, size_t n_symbols, trivia_t* a_trivia) {
        DerivedTypeProc_t *n;
        n = al.make_new<DerivedTypeProc_t>();
        n->base.type = procedure_declType::DerivedTypeProc;
        n->base.base.type = astType::procedure_decl;
        n->base.base.loc = a_loc;
        n->m_name = a_name;
        n->m_attr = a_attr;
        n->n_attr = n_attr;
        n->m_symbols = a_symbols;
        n->n_symbols = n_symbols;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct GenericOperator_t // Constructor
    {
        const static procedure_declType class_type = procedure_declType::GenericOperator;
        typedef procedure_decl_t parent_type;
        procedure_decl_t base;
        decl_attribute_t** m_attr; size_t n_attr; // Sequence
        intrinsicopType m_op;
        char** m_names; size_t n_names; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_GenericOperator_t(Allocator &al, const Location &a_loc, decl_attribute_t** a_attr, size_t n_attr, intrinsicopType a_op, char** a_names, size_t n_names, trivia_t* a_trivia) {
        GenericOperator_t *n;
        n = al.make_new<GenericOperator_t>();
        n->base.type = procedure_declType::GenericOperator;
        n->base.base.type = astType::procedure_decl;
        n->base.base.loc = a_loc;
        n->m_attr = a_attr;
        n->n_attr = n_attr;
        n->m_op = a_op;
        n->m_names = a_names;
        n->n_names = n_names;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct GenericDefinedOperator_t // Constructor
    {
        const static procedure_declType class_type = procedure_declType::GenericDefinedOperator;
        typedef procedure_decl_t parent_type;
        procedure_decl_t base;
        decl_attribute_t** m_attr; size_t n_attr; // Sequence
        char* m_optype;
        char** m_names; size_t n_names; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_GenericDefinedOperator_t(Allocator &al, const Location &a_loc, decl_attribute_t** a_attr, size_t n_attr, char* a_optype, char** a_names, size_t n_names, trivia_t* a_trivia) {
        GenericDefinedOperator_t *n;
        n = al.make_new<GenericDefinedOperator_t>();
        n->base.type = procedure_declType::GenericDefinedOperator;
        n->base.base.type = astType::procedure_decl;
        n->base.base.loc = a_loc;
        n->m_attr = a_attr;
        n->n_attr = n_attr;
        n->m_optype = a_optype;
        n->m_names = a_names;
        n->n_names = n_names;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct GenericAssignment_t // Constructor
    {
        const static procedure_declType class_type = procedure_declType::GenericAssignment;
        typedef procedure_decl_t parent_type;
        procedure_decl_t base;
        decl_attribute_t** m_attr; size_t n_attr; // Sequence
        char** m_names; size_t n_names; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_GenericAssignment_t(Allocator &al, const Location &a_loc, decl_attribute_t** a_attr, size_t n_attr, char** a_names, size_t n_names, trivia_t* a_trivia) {
        GenericAssignment_t *n;
        n = al.make_new<GenericAssignment_t>();
        n->base.type = procedure_declType::GenericAssignment;
        n->base.base.type = astType::procedure_decl;
        n->base.base.loc = a_loc;
        n->m_attr = a_attr;
        n->n_attr = n_attr;
        n->m_names = a_names;
        n->n_names = n_names;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct GenericName_t // Constructor
    {
        const static procedure_declType class_type = procedure_declType::GenericName;
        typedef procedure_decl_t parent_type;
        procedure_decl_t base;
        decl_attribute_t** m_attr; size_t n_attr; // Sequence
        char* m_name;
        char** m_names; size_t n_names; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_GenericName_t(Allocator &al, const Location &a_loc, decl_attribute_t** a_attr, size_t n_attr, char* a_name, char** a_names, size_t n_names, trivia_t* a_trivia) {
        GenericName_t *n;
        n = al.make_new<GenericName_t>();
        n->base.type = procedure_declType::GenericName;
        n->base.base.type = astType::procedure_decl;
        n->base.base.loc = a_loc;
        n->m_attr = a_attr;
        n->n_attr = n_attr;
        n->m_name = a_name;
        n->m_names = a_names;
        n->n_names = n_names;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct GenericWrite_t // Constructor
    {
        const static procedure_declType class_type = procedure_declType::GenericWrite;
        typedef procedure_decl_t parent_type;
        procedure_decl_t base;
        decl_attribute_t** m_attr; size_t n_attr; // Sequence
        char* m_id;
        char** m_names; size_t n_names; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_GenericWrite_t(Allocator &al, const Location &a_loc, decl_attribute_t** a_attr, size_t n_attr, char* a_id, char** a_names, size_t n_names, trivia_t* a_trivia) {
        GenericWrite_t *n;
        n = al.make_new<GenericWrite_t>();
        n->base.type = procedure_declType::GenericWrite;
        n->base.base.type = astType::procedure_decl;
        n->base.base.loc = a_loc;
        n->m_attr = a_attr;
        n->n_attr = n_attr;
        n->m_id = a_id;
        n->m_names = a_names;
        n->n_names = n_names;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct GenericRead_t // Constructor
    {
        const static procedure_declType class_type = procedure_declType::GenericRead;
        typedef procedure_decl_t parent_type;
        procedure_decl_t base;
        decl_attribute_t** m_attr; size_t n_attr; // Sequence
        char* m_id;
        char** m_names; size_t n_names; // Sequence
        trivia_t* m_trivia;
    };
    static inline ast_t* make_GenericRead_t(Allocator &al, const Location &a_loc, decl_attribute_t** a_attr, size_t n_attr, char* a_id, char** a_names, size_t n_names, trivia_t* a_trivia) {
        GenericRead_t *n;
        n = al.make_new<GenericRead_t>();
        n->base.type = procedure_declType::GenericRead;
        n->base.base.type = astType::procedure_decl;
        n->base.base.loc = a_loc;
        n->m_attr = a_attr;
        n->n_attr = n_attr;
        n->m_id = a_id;
        n->m_names = a_names;
        n->n_names = n_names;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct FinalName_t // Constructor
    {
        const static procedure_declType class_type = procedure_declType::FinalName;
        typedef procedure_decl_t parent_type;
        procedure_decl_t base;
        char* m_name;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_FinalName_t(Allocator &al, const Location &a_loc, char* a_name, trivia_t* a_trivia) {
        FinalName_t *n;
        n = al.make_new<FinalName_t>();
        n->base.type = procedure_declType::FinalName;
        n->base.base.type = astType::procedure_decl;
        n->base.base.loc = a_loc;
        n->m_name = a_name;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }

    struct Private_t // Constructor
    {
        const static procedure_declType class_type = procedure_declType::Private;
        typedef procedure_decl_t parent_type;
        procedure_decl_t base;
        trivia_t* m_trivia;
    };
    static inline ast_t* make_Private_t(Allocator &al, const Location &a_loc, trivia_t* a_trivia) {
        Private_t *n;
        n = al.make_new<Private_t>();
        n->base.type = procedure_declType::Private;
        n->base.base.type = astType::procedure_decl;
        n->base.base.loc = a_loc;
        n->m_trivia = a_trivia;
        return (ast_t*)n;
    }



enum decl_attributeType // Types
{
    AttrBind, AttrData, AttrDimension, AttrCodimension, AttrEquivalence, AttrExtends, AttrIntent, AttrNamelist, AttrPass, SimpleAttribute, AttrType, AttrAssignment, AttrIntrinsicOperator, AttrDefinedOperator
};

struct decl_attribute_t // Sum
{
    const static astType class_type = astType::decl_attribute;
    ast_t base;
    decl_attributeType type;
};

    struct AttrBind_t // Constructor
    {
        const static decl_attributeType class_type = decl_attributeType::AttrBind;
        typedef decl_attribute_t parent_type;
        decl_attribute_t base;
        bind_t* m_bind;
    };
    static inline ast_t* make_AttrBind_t(Allocator &al, const Location &a_loc, bind_t* a_bind) {
        AttrBind_t *n;
        n = al.make_new<AttrBind_t>();
        n->base.type = decl_attributeType::AttrBind;
        n->base.base.type = astType::decl_attribute;
        n->base.base.loc = a_loc;
        n->m_bind = a_bind;
        return (ast_t*)n;
    }

    struct AttrData_t // Constructor
    {
        const static decl_attributeType class_type = decl_attributeType::AttrData;
        typedef decl_attribute_t parent_type;
        decl_attribute_t base;
        expr_t** m_object; size_t n_object; // Sequence
        expr_t** m_value; size_t n_value; // Sequence
    };
    static inline ast_t* make_AttrData_t(Allocator &al, const Location &a_loc, expr_t** a_object, size_t n_object, expr_t** a_value, size_t n_value) {
        AttrData_t *n;
        n = al.make_new<AttrData_t>();
        n->base.type = decl_attributeType::AttrData;
        n->base.base.type = astType::decl_attribute;
        n->base.base.loc = a_loc;
        n->m_object = a_object;
        n->n_object = n_object;
        n->m_value = a_value;
        n->n_value = n_value;
        return (ast_t*)n;
    }

    struct AttrDimension_t // Constructor
    {
        const static decl_attributeType class_type = decl_attributeType::AttrDimension;
        typedef decl_attribute_t parent_type;
        decl_attribute_t base;
        dimension_t* m_dim; size_t n_dim; // Sequence
    };
    static inline ast_t* make_AttrDimension_t(Allocator &al, const Location &a_loc, dimension_t* a_dim, size_t n_dim) {
        AttrDimension_t *n;
        n = al.make_new<AttrDimension_t>();
        n->base.type = decl_attributeType::AttrDimension;
        n->base.base.type = astType::decl_attribute;
        n->base.base.loc = a_loc;
        n->m_dim = a_dim;
        n->n_dim = n_dim;
        return (ast_t*)n;
    }

    struct AttrCodimension_t // Constructor
    {
        const static decl_attributeType class_type = decl_attributeType::AttrCodimension;
        typedef decl_attribute_t parent_type;
        decl_attribute_t base;
        codimension_t* m_codim; size_t n_codim; // Sequence
    };
    static inline ast_t* make_AttrCodimension_t(Allocator &al, const Location &a_loc, codimension_t* a_codim, size_t n_codim) {
        AttrCodimension_t *n;
        n = al.make_new<AttrCodimension_t>();
        n->base.type = decl_attributeType::AttrCodimension;
        n->base.base.type = astType::decl_attribute;
        n->base.base.loc = a_loc;
        n->m_codim = a_codim;
        n->n_codim = n_codim;
        return (ast_t*)n;
    }

    struct AttrEquivalence_t // Constructor
    {
        const static decl_attributeType class_type = decl_attributeType::AttrEquivalence;
        typedef decl_attribute_t parent_type;
        decl_attribute_t base;
        equi_t* m_args; size_t n_args; // Sequence
    };
    static inline ast_t* make_AttrEquivalence_t(Allocator &al, const Location &a_loc, equi_t* a_args, size_t n_args) {
        AttrEquivalence_t *n;
        n = al.make_new<AttrEquivalence_t>();
        n->base.type = decl_attributeType::AttrEquivalence;
        n->base.base.type = astType::decl_attribute;
        n->base.base.loc = a_loc;
        n->m_args = a_args;
        n->n_args = n_args;
        return (ast_t*)n;
    }

    struct AttrExtends_t // Constructor
    {
        const static decl_attributeType class_type = decl_attributeType::AttrExtends;
        typedef decl_attribute_t parent_type;
        decl_attribute_t base;
        char* m_name;
    };
    static inline ast_t* make_AttrExtends_t(Allocator &al, const Location &a_loc, char* a_name) {
        AttrExtends_t *n;
        n = al.make_new<AttrExtends_t>();
        n->base.type = decl_attributeType::AttrExtends;
        n->base.base.type = astType::decl_attribute;
        n->base.base.loc = a_loc;
        n->m_name = a_name;
        return (ast_t*)n;
    }

    struct AttrIntent_t // Constructor
    {
        const static decl_attributeType class_type = decl_attributeType::AttrIntent;
        typedef decl_attribute_t parent_type;
        decl_attribute_t base;
        attr_intentType m_intent;
    };
    static inline ast_t* make_AttrIntent_t(Allocator &al, const Location &a_loc, attr_intentType a_intent) {
        AttrIntent_t *n;
        n = al.make_new<AttrIntent_t>();
        n->base.type = decl_attributeType::AttrIntent;
        n->base.base.type = astType::decl_attribute;
        n->base.base.loc = a_loc;
        n->m_intent = a_intent;
        return (ast_t*)n;
    }

    struct AttrNamelist_t // Constructor
    {
        const static decl_attributeType class_type = decl_attributeType::AttrNamelist;
        typedef decl_attribute_t parent_type;
        decl_attribute_t base;
        char* m_name;
    };
    static inline ast_t* make_AttrNamelist_t(Allocator &al, const Location &a_loc, char* a_name) {
        AttrNamelist_t *n;
        n = al.make_new<AttrNamelist_t>();
        n->base.type = decl_attributeType::AttrNamelist;
        n->base.base.type = astType::decl_attribute;
        n->base.base.loc = a_loc;
        n->m_name = a_name;
        return (ast_t*)n;
    }

    struct AttrPass_t // Constructor
    {
        const static decl_attributeType class_type = decl_attributeType::AttrPass;
        typedef decl_attribute_t parent_type;
        decl_attribute_t base;
        char* m_name;
    };
    static inline ast_t* make_AttrPass_t(Allocator &al, const Location &a_loc, char* a_name) {
        AttrPass_t *n;
        n = al.make_new<AttrPass_t>();
        n->base.type = decl_attributeType::AttrPass;
        n->base.base.type = astType::decl_attribute;
        n->base.base.loc = a_loc;
        n->m_name = a_name;
        return (ast_t*)n;
    }

    struct SimpleAttribute_t // Constructor
    {
        const static decl_attributeType class_type = decl_attributeType::SimpleAttribute;
        typedef decl_attribute_t parent_type;
        decl_attribute_t base;
        simple_attributeType m_attr;
    };
    static inline ast_t* make_SimpleAttribute_t(Allocator &al, const Location &a_loc, simple_attributeType a_attr) {
        SimpleAttribute_t *n;
        n = al.make_new<SimpleAttribute_t>();
        n->base.type = decl_attributeType::SimpleAttribute;
        n->base.base.type = astType::decl_attribute;
        n->base.base.loc = a_loc;
        n->m_attr = a_attr;
        return (ast_t*)n;
    }

    struct AttrType_t // Constructor
    {
        const static decl_attributeType class_type = decl_attributeType::AttrType;
        typedef decl_attribute_t parent_type;
        decl_attribute_t base;
        decl_typeType m_type;
        kind_item_t* m_kind; size_t n_kind; // Sequence
        char* m_name;
        symbolType m_sym;
    };
    static inline ast_t* make_AttrType_t(Allocator &al, const Location &a_loc, decl_typeType a_type, kind_item_t* a_kind, size_t n_kind, char* a_name, symbolType a_sym) {
        AttrType_t *n;
        n = al.make_new<AttrType_t>();
        n->base.type = decl_attributeType::AttrType;
        n->base.base.type = astType::decl_attribute;
        n->base.base.loc = a_loc;
        n->m_type = a_type;
        n->m_kind = a_kind;
        n->n_kind = n_kind;
        n->m_name = a_name;
        n->m_sym = a_sym;
        return (ast_t*)n;
    }

    struct AttrAssignment_t // Constructor
    {
        const static decl_attributeType class_type = decl_attributeType::AttrAssignment;
        typedef decl_attribute_t parent_type;
        decl_attribute_t base;
    };
    static inline ast_t* make_AttrAssignment_t(Allocator &al, const Location &a_loc) {
        AttrAssignment_t *n;
        n = al.make_new<AttrAssignment_t>();
        n->base.type = decl_attributeType::AttrAssignment;
        n->base.base.type = astType::decl_attribute;
        n->base.base.loc = a_loc;
        return (ast_t*)n;
    }

    struct AttrIntrinsicOperator_t // Constructor
    {
        const static decl_attributeType class_type = decl_attributeType::AttrIntrinsicOperator;
        typedef decl_attribute_t parent_type;
        decl_attribute_t base;
        intrinsicopType m_op;
    };
    static inline ast_t* make_AttrIntrinsicOperator_t(Allocator &al, const Location &a_loc, intrinsicopType a_op) {
        AttrIntrinsicOperator_t *n;
        n = al.make_new<AttrIntrinsicOperator_t>();
        n->base.type = decl_attributeType::AttrIntrinsicOperator;
        n->base.base.type = astType::decl_attribute;
        n->base.base.loc = a_loc;
        n->m_op = a_op;
        return (ast_t*)n;
    }

    struct AttrDefinedOperator_t // Constructor
    {
        const static decl_attributeType class_type = decl_attributeType::AttrDefinedOperator;
        typedef decl_attribute_t parent_type;
        decl_attribute_t base;
        char* m_op_name;
    };
    static inline ast_t* make_AttrDefinedOperator_t(Allocator &al, const Location &a_loc, char* a_op_name) {
        AttrDefinedOperator_t *n;
        n = al.make_new<AttrDefinedOperator_t>();
        n->base.type = decl_attributeType::AttrDefinedOperator;
        n->base.base.type = astType::decl_attribute;
        n->base.base.loc = a_loc;
        n->m_op_name = a_op_name;
        return (ast_t*)n;
    }



enum event_attributeType // Types
{
    AttrStat, AttrErrmsg, AttrNewIndex, AttrEventWaitKwArg
};

struct event_attribute_t // Sum
{
    const static astType class_type = astType::event_attribute;
    ast_t base;
    event_attributeType type;
};

    struct AttrStat_t // Constructor
    {
        const static event_attributeType class_type = event_attributeType::AttrStat;
        typedef event_attribute_t parent_type;
        event_attribute_t base;
        char* m_variable;
    };
    static inline ast_t* make_AttrStat_t(Allocator &al, const Location &a_loc, char* a_variable) {
        AttrStat_t *n;
        n = al.make_new<AttrStat_t>();
        n->base.type = event_attributeType::AttrStat;
        n->base.base.type = astType::event_attribute;
        n->base.base.loc = a_loc;
        n->m_variable = a_variable;
        return (ast_t*)n;
    }

    struct AttrErrmsg_t // Constructor
    {
        const static event_attributeType class_type = event_attributeType::AttrErrmsg;
        typedef event_attribute_t parent_type;
        event_attribute_t base;
        char* m_variable;
    };
    static inline ast_t* make_AttrErrmsg_t(Allocator &al, const Location &a_loc, char* a_variable) {
        AttrErrmsg_t *n;
        n = al.make_new<AttrErrmsg_t>();
        n->base.type = event_attributeType::AttrErrmsg;
        n->base.base.type = astType::event_attribute;
        n->base.base.loc = a_loc;
        n->m_variable = a_variable;
        return (ast_t*)n;
    }

    struct AttrNewIndex_t // Constructor
    {
        const static event_attributeType class_type = event_attributeType::AttrNewIndex;
        typedef event_attribute_t parent_type;
        event_attribute_t base;
        expr_t* m_value;
    };
    static inline ast_t* make_AttrNewIndex_t(Allocator &al, const Location &a_loc, expr_t* a_value) {
        AttrNewIndex_t *n;
        n = al.make_new<AttrNewIndex_t>();
        n->base.type = event_attributeType::AttrNewIndex;
        n->base.base.type = astType::event_attribute;
        n->base.base.loc = a_loc;
        n->m_value = a_value;
        return (ast_t*)n;
    }

    struct AttrEventWaitKwArg_t // Constructor
    {
        const static event_attributeType class_type = event_attributeType::AttrEventWaitKwArg;
        typedef event_attribute_t parent_type;
        event_attribute_t base;
        char* m_id;
        expr_t* m_value;
    };
    static inline ast_t* make_AttrEventWaitKwArg_t(Allocator &al, const Location &a_loc, char* a_id, expr_t* a_value) {
        AttrEventWaitKwArg_t *n;
        n = al.make_new<AttrEventWaitKwArg_t>();
        n->base.type = event_attributeType::AttrEventWaitKwArg;
        n->base.base.type = astType::event_attribute;
        n->base.base.loc = a_loc;
        n->m_id = a_id;
        n->m_value = a_value;
        return (ast_t*)n;
    }



enum team_attributeType // Types
{
    CoarrayAssociation
};

struct team_attribute_t // Sum
{
    const static astType class_type = astType::team_attribute;
    ast_t base;
    team_attributeType type;
};

    struct CoarrayAssociation_t // Constructor
    {
        const static team_attributeType class_type = team_attributeType::CoarrayAssociation;
        typedef team_attribute_t parent_type;
        team_attribute_t base;
        expr_t* m_coarray;
        expr_t* m_selector;
    };
    static inline ast_t* make_CoarrayAssociation_t(Allocator &al, const Location &a_loc, expr_t* a_coarray, expr_t* a_selector) {
        CoarrayAssociation_t *n;
        n = al.make_new<CoarrayAssociation_t>();
        n->base.type = team_attributeType::CoarrayAssociation;
        n->base.base.type = astType::team_attribute;
        n->base.base.loc = a_loc;
        n->m_coarray = a_coarray;
        n->m_selector = a_selector;
        return (ast_t*)n;
    }



enum bindType // Types
{
    Bind
};

struct bind_t // Sum
{
    const static astType class_type = astType::bind;
    ast_t base;
    bindType type;
};

    struct Bind_t // Constructor
    {
        const static bindType class_type = bindType::Bind;
        typedef bind_t parent_type;
        bind_t base;
        expr_t** m_args; size_t n_args; // Sequence
        keyword_t* m_kwargs; size_t n_kwargs; // Sequence
    };
    static inline ast_t* make_Bind_t(Allocator &al, const Location &a_loc, expr_t** a_args, size_t n_args, keyword_t* a_kwargs, size_t n_kwargs) {
        Bind_t *n;
        n = al.make_new<Bind_t>();
        n->base.type = bindType::Bind;
        n->base.base.type = astType::bind;
        n->base.base.loc = a_loc;
        n->m_args = a_args;
        n->n_args = n_args;
        n->m_kwargs = a_kwargs;
        n->n_kwargs = n_kwargs;
        return (ast_t*)n;
    }



enum array_indexType // Types
{
    ArrayIndex
};

struct array_index_t // Sum
{
    const static astType class_type = astType::array_index;
    ast_t base;
    array_indexType type;
};

    struct ArrayIndex_t // Constructor
    {
        const static array_indexType class_type = array_indexType::ArrayIndex;
        typedef array_index_t parent_type;
        array_index_t base;
        expr_t* m_left;
        expr_t* m_right;
        expr_t* m_step;
    };
    static inline ast_t* make_ArrayIndex_t(Allocator &al, const Location &a_loc, expr_t* a_left, expr_t* a_right, expr_t* a_step) {
        ArrayIndex_t *n;
        n = al.make_new<ArrayIndex_t>();
        n->base.type = array_indexType::ArrayIndex;
        n->base.base.type = astType::array_index;
        n->base.base.loc = a_loc;
        n->m_left = a_left;
        n->m_right = a_right;
        n->m_step = a_step;
        return (ast_t*)n;
    }



enum case_stmtType // Types
{
    CaseStmt, CaseStmt_Default
};

struct case_stmt_t // Sum
{
    const static astType class_type = astType::case_stmt;
    ast_t base;
    case_stmtType type;
};

    struct CaseStmt_t // Constructor
    {
        const static case_stmtType class_type = case_stmtType::CaseStmt;
        typedef case_stmt_t parent_type;
        case_stmt_t base;
        case_cond_t** m_test; size_t n_test; // Sequence
        trivia_t* m_trivia;
        stmt_t** m_body; size_t n_body; // Sequence
    };
    static inline ast_t* make_CaseStmt_t(Allocator &al, const Location &a_loc, case_cond_t** a_test, size_t n_test, trivia_t* a_trivia, stmt_t** a_body, size_t n_body) {
        CaseStmt_t *n;
        n = al.make_new<CaseStmt_t>();
        n->base.type = case_stmtType::CaseStmt;
        n->base.base.type = astType::case_stmt;
        n->base.base.loc = a_loc;
        n->m_test = a_test;
        n->n_test = n_test;
        n->m_trivia = a_trivia;
        n->m_body = a_body;
        n->n_body = n_body;
        return (ast_t*)n;
    }

    struct CaseStmt_Default_t // Constructor
    {
        const static case_stmtType class_type = case_stmtType::CaseStmt_Default;
        typedef case_stmt_t parent_type;
        case_stmt_t base;
        trivia_t* m_trivia;
        stmt_t** m_body; size_t n_body; // Sequence
    };
    static inline ast_t* make_CaseStmt_Default_t(Allocator &al, const Location &a_loc, trivia_t* a_trivia, stmt_t** a_body, size_t n_body) {
        CaseStmt_Default_t *n;
        n = al.make_new<CaseStmt_Default_t>();
        n->base.type = case_stmtType::CaseStmt_Default;
        n->base.base.type = astType::case_stmt;
        n->base.base.loc = a_loc;
        n->m_trivia = a_trivia;
        n->m_body = a_body;
        n->n_body = n_body;
        return (ast_t*)n;
    }



enum case_condType // Types
{
    CaseCondExpr, CaseCondRange
};

struct case_cond_t // Sum
{
    const static astType class_type = astType::case_cond;
    ast_t base;
    case_condType type;
};

    struct CaseCondExpr_t // Constructor
    {
        const static case_condType class_type = case_condType::CaseCondExpr;
        typedef case_cond_t parent_type;
        case_cond_t base;
        expr_t* m_cond;
    };
    static inline ast_t* make_CaseCondExpr_t(Allocator &al, const Location &a_loc, expr_t* a_cond) {
        CaseCondExpr_t *n;
        n = al.make_new<CaseCondExpr_t>();
        n->base.type = case_condType::CaseCondExpr;
        n->base.base.type = astType::case_cond;
        n->base.base.loc = a_loc;
        n->m_cond = a_cond;
        return (ast_t*)n;
    }

    struct CaseCondRange_t // Constructor
    {
        const static case_condType class_type = case_condType::CaseCondRange;
        typedef case_cond_t parent_type;
        case_cond_t base;
        expr_t* m_start;
        expr_t* m_end;
    };
    static inline ast_t* make_CaseCondRange_t(Allocator &al, const Location &a_loc, expr_t* a_start, expr_t* a_end) {
        CaseCondRange_t *n;
        n = al.make_new<CaseCondRange_t>();
        n->base.type = case_condType::CaseCondRange;
        n->base.base.type = astType::case_cond;
        n->base.base.loc = a_loc;
        n->m_start = a_start;
        n->m_end = a_end;
        return (ast_t*)n;
    }



enum rank_stmtType // Types
{
    RankExpr, RankStar, RankDefault
};

struct rank_stmt_t // Sum
{
    const static astType class_type = astType::rank_stmt;
    ast_t base;
    rank_stmtType type;
};

    struct RankExpr_t // Constructor
    {
        const static rank_stmtType class_type = rank_stmtType::RankExpr;
        typedef rank_stmt_t parent_type;
        rank_stmt_t base;
        expr_t* m_value;
        trivia_t* m_trivia;
        stmt_t** m_body; size_t n_body; // Sequence
    };
    static inline ast_t* make_RankExpr_t(Allocator &al, const Location &a_loc, expr_t* a_value, trivia_t* a_trivia, stmt_t** a_body, size_t n_body) {
        RankExpr_t *n;
        n = al.make_new<RankExpr_t>();
        n->base.type = rank_stmtType::RankExpr;
        n->base.base.type = astType::rank_stmt;
        n->base.base.loc = a_loc;
        n->m_value = a_value;
        n->m_trivia = a_trivia;
        n->m_body = a_body;
        n->n_body = n_body;
        return (ast_t*)n;
    }

    struct RankStar_t // Constructor
    {
        const static rank_stmtType class_type = rank_stmtType::RankStar;
        typedef rank_stmt_t parent_type;
        rank_stmt_t base;
        trivia_t* m_trivia;
        stmt_t** m_body; size_t n_body; // Sequence
    };
    static inline ast_t* make_RankStar_t(Allocator &al, const Location &a_loc, trivia_t* a_trivia, stmt_t** a_body, size_t n_body) {
        RankStar_t *n;
        n = al.make_new<RankStar_t>();
        n->base.type = rank_stmtType::RankStar;
        n->base.base.type = astType::rank_stmt;
        n->base.base.loc = a_loc;
        n->m_trivia = a_trivia;
        n->m_body = a_body;
        n->n_body = n_body;
        return (ast_t*)n;
    }

    struct RankDefault_t // Constructor
    {
        const static rank_stmtType class_type = rank_stmtType::RankDefault;
        typedef rank_stmt_t parent_type;
        rank_stmt_t base;
        trivia_t* m_trivia;
        stmt_t** m_body; size_t n_body; // Sequence
    };
    static inline ast_t* make_RankDefault_t(Allocator &al, const Location &a_loc, trivia_t* a_trivia, stmt_t** a_body, size_t n_body) {
        RankDefault_t *n;
        n = al.make_new<RankDefault_t>();
        n->base.type = rank_stmtType::RankDefault;
        n->base.base.type = astType::rank_stmt;
        n->base.base.loc = a_loc;
        n->m_trivia = a_trivia;
        n->m_body = a_body;
        n->n_body = n_body;
        return (ast_t*)n;
    }



enum type_stmtType // Types
{
    TypeStmtName, TypeStmtType, ClassStmt, ClassDefault
};

struct type_stmt_t // Sum
{
    const static astType class_type = astType::type_stmt;
    ast_t base;
    type_stmtType type;
};

    struct TypeStmtName_t // Constructor
    {
        const static type_stmtType class_type = type_stmtType::TypeStmtName;
        typedef type_stmt_t parent_type;
        type_stmt_t base;
        char* m_name;
        trivia_t* m_trivia;
        stmt_t** m_body; size_t n_body; // Sequence
    };
    static inline ast_t* make_TypeStmtName_t(Allocator &al, const Location &a_loc, char* a_name, trivia_t* a_trivia, stmt_t** a_body, size_t n_body) {
        TypeStmtName_t *n;
        n = al.make_new<TypeStmtName_t>();
        n->base.type = type_stmtType::TypeStmtName;
        n->base.base.type = astType::type_stmt;
        n->base.base.loc = a_loc;
        n->m_name = a_name;
        n->m_trivia = a_trivia;
        n->m_body = a_body;
        n->n_body = n_body;
        return (ast_t*)n;
    }

    struct TypeStmtType_t // Constructor
    {
        const static type_stmtType class_type = type_stmtType::TypeStmtType;
        typedef type_stmt_t parent_type;
        type_stmt_t base;
        decl_attribute_t* m_vartype;
        trivia_t* m_trivia;
        stmt_t** m_body; size_t n_body; // Sequence
    };
    static inline ast_t* make_TypeStmtType_t(Allocator &al, const Location &a_loc, decl_attribute_t* a_vartype, trivia_t* a_trivia, stmt_t** a_body, size_t n_body) {
        TypeStmtType_t *n;
        n = al.make_new<TypeStmtType_t>();
        n->base.type = type_stmtType::TypeStmtType;
        n->base.base.type = astType::type_stmt;
        n->base.base.loc = a_loc;
        n->m_vartype = a_vartype;
        n->m_trivia = a_trivia;
        n->m_body = a_body;
        n->n_body = n_body;
        return (ast_t*)n;
    }

    struct ClassStmt_t // Constructor
    {
        const static type_stmtType class_type = type_stmtType::ClassStmt;
        typedef type_stmt_t parent_type;
        type_stmt_t base;
        char* m_id;
        trivia_t* m_trivia;
        stmt_t** m_body; size_t n_body; // Sequence
    };
    static inline ast_t* make_ClassStmt_t(Allocator &al, const Location &a_loc, char* a_id, trivia_t* a_trivia, stmt_t** a_body, size_t n_body) {
        ClassStmt_t *n;
        n = al.make_new<ClassStmt_t>();
        n->base.type = type_stmtType::ClassStmt;
        n->base.base.type = astType::type_stmt;
        n->base.base.loc = a_loc;
        n->m_id = a_id;
        n->m_trivia = a_trivia;
        n->m_body = a_body;
        n->n_body = n_body;
        return (ast_t*)n;
    }

    struct ClassDefault_t // Constructor
    {
        const static type_stmtType class_type = type_stmtType::ClassDefault;
        typedef type_stmt_t parent_type;
        type_stmt_t base;
        trivia_t* m_trivia;
        stmt_t** m_body; size_t n_body; // Sequence
    };
    static inline ast_t* make_ClassDefault_t(Allocator &al, const Location &a_loc, trivia_t* a_trivia, stmt_t** a_body, size_t n_body) {
        ClassDefault_t *n;
        n = al.make_new<ClassDefault_t>();
        n->base.type = type_stmtType::ClassDefault;
        n->base.base.type = astType::type_stmt;
        n->base.base.loc = a_loc;
        n->m_trivia = a_trivia;
        n->m_body = a_body;
        n->n_body = n_body;
        return (ast_t*)n;
    }



enum use_symbolType // Types
{
    UseSymbol, UseAssignment, IntrinsicOperator, DefinedOperator, RenameOperator, UseWrite, UseRead
};

struct use_symbol_t // Sum
{
    const static astType class_type = astType::use_symbol;
    ast_t base;
    use_symbolType type;
};

    struct UseSymbol_t // Constructor
    {
        const static use_symbolType class_type = use_symbolType::UseSymbol;
        typedef use_symbol_t parent_type;
        use_symbol_t base;
        char* m_remote_sym;
        char* m_local_rename;
    };
    static inline ast_t* make_UseSymbol_t(Allocator &al, const Location &a_loc, char* a_remote_sym, char* a_local_rename) {
        UseSymbol_t *n;
        n = al.make_new<UseSymbol_t>();
        n->base.type = use_symbolType::UseSymbol;
        n->base.base.type = astType::use_symbol;
        n->base.base.loc = a_loc;
        n->m_remote_sym = a_remote_sym;
        n->m_local_rename = a_local_rename;
        return (ast_t*)n;
    }

    struct UseAssignment_t // Constructor
    {
        const static use_symbolType class_type = use_symbolType::UseAssignment;
        typedef use_symbol_t parent_type;
        use_symbol_t base;
    };
    static inline ast_t* make_UseAssignment_t(Allocator &al, const Location &a_loc) {
        UseAssignment_t *n;
        n = al.make_new<UseAssignment_t>();
        n->base.type = use_symbolType::UseAssignment;
        n->base.base.type = astType::use_symbol;
        n->base.base.loc = a_loc;
        return (ast_t*)n;
    }

    struct IntrinsicOperator_t // Constructor
    {
        const static use_symbolType class_type = use_symbolType::IntrinsicOperator;
        typedef use_symbol_t parent_type;
        use_symbol_t base;
        intrinsicopType m_op;
    };
    static inline ast_t* make_IntrinsicOperator_t(Allocator &al, const Location &a_loc, intrinsicopType a_op) {
        IntrinsicOperator_t *n;
        n = al.make_new<IntrinsicOperator_t>();
        n->base.type = use_symbolType::IntrinsicOperator;
        n->base.base.type = astType::use_symbol;
        n->base.base.loc = a_loc;
        n->m_op = a_op;
        return (ast_t*)n;
    }

    struct DefinedOperator_t // Constructor
    {
        const static use_symbolType class_type = use_symbolType::DefinedOperator;
        typedef use_symbol_t parent_type;
        use_symbol_t base;
        char* m_opName;
    };
    static inline ast_t* make_DefinedOperator_t(Allocator &al, const Location &a_loc, char* a_opName) {
        DefinedOperator_t *n;
        n = al.make_new<DefinedOperator_t>();
        n->base.type = use_symbolType::DefinedOperator;
        n->base.base.type = astType::use_symbol;
        n->base.base.loc = a_loc;
        n->m_opName = a_opName;
        return (ast_t*)n;
    }

    struct RenameOperator_t // Constructor
    {
        const static use_symbolType class_type = use_symbolType::RenameOperator;
        typedef use_symbol_t parent_type;
        use_symbol_t base;
        char* m_local_defop;
        char* m_use_defop;
    };
    static inline ast_t* make_RenameOperator_t(Allocator &al, const Location &a_loc, char* a_local_defop, char* a_use_defop) {
        RenameOperator_t *n;
        n = al.make_new<RenameOperator_t>();
        n->base.type = use_symbolType::RenameOperator;
        n->base.base.type = astType::use_symbol;
        n->base.base.loc = a_loc;
        n->m_local_defop = a_local_defop;
        n->m_use_defop = a_use_defop;
        return (ast_t*)n;
    }

    struct UseWrite_t // Constructor
    {
        const static use_symbolType class_type = use_symbolType::UseWrite;
        typedef use_symbol_t parent_type;
        use_symbol_t base;
        char* m_id;
    };
    static inline ast_t* make_UseWrite_t(Allocator &al, const Location &a_loc, char* a_id) {
        UseWrite_t *n;
        n = al.make_new<UseWrite_t>();
        n->base.type = use_symbolType::UseWrite;
        n->base.base.type = astType::use_symbol;
        n->base.base.loc = a_loc;
        n->m_id = a_id;
        return (ast_t*)n;
    }

    struct UseRead_t // Constructor
    {
        const static use_symbolType class_type = use_symbolType::UseRead;
        typedef use_symbol_t parent_type;
        use_symbol_t base;
        char* m_id;
    };
    static inline ast_t* make_UseRead_t(Allocator &al, const Location &a_loc, char* a_id) {
        UseRead_t *n;
        n = al.make_new<UseRead_t>();
        n->base.type = use_symbolType::UseRead;
        n->base.base.type = astType::use_symbol;
        n->base.base.loc = a_loc;
        n->m_id = a_id;
        return (ast_t*)n;
    }



enum concurrent_controlType // Types
{
    ConcurrentControl
};

struct concurrent_control_t // Sum
{
    const static astType class_type = astType::concurrent_control;
    ast_t base;
    concurrent_controlType type;
};

    struct ConcurrentControl_t // Constructor
    {
        const static concurrent_controlType class_type = concurrent_controlType::ConcurrentControl;
        typedef concurrent_control_t parent_type;
        concurrent_control_t base;
        char* m_var;
        expr_t* m_start;
        expr_t* m_end;
        expr_t* m_increment;
    };
    static inline ast_t* make_ConcurrentControl_t(Allocator &al, const Location &a_loc, char* a_var, expr_t* a_start, expr_t* a_end, expr_t* a_increment) {
        ConcurrentControl_t *n;
        n = al.make_new<ConcurrentControl_t>();
        n->base.type = concurrent_controlType::ConcurrentControl;
        n->base.base.type = astType::concurrent_control;
        n->base.base.loc = a_loc;
        n->m_var = a_var;
        n->m_start = a_start;
        n->m_end = a_end;
        n->m_increment = a_increment;
        return (ast_t*)n;
    }



enum concurrent_localityType // Types
{
    ConcurrentLocal, ConcurrentLocalInit, ConcurrentShared, ConcurrentDefault, ConcurrentReduce
};

struct concurrent_locality_t // Sum
{
    const static astType class_type = astType::concurrent_locality;
    ast_t base;
    concurrent_localityType type;
};

    struct ConcurrentLocal_t // Constructor
    {
        const static concurrent_localityType class_type = concurrent_localityType::ConcurrentLocal;
        typedef concurrent_locality_t parent_type;
        concurrent_locality_t base;
        char** m_vars; size_t n_vars; // Sequence
    };
    static inline ast_t* make_ConcurrentLocal_t(Allocator &al, const Location &a_loc, char** a_vars, size_t n_vars) {
        ConcurrentLocal_t *n;
        n = al.make_new<ConcurrentLocal_t>();
        n->base.type = concurrent_localityType::ConcurrentLocal;
        n->base.base.type = astType::concurrent_locality;
        n->base.base.loc = a_loc;
        n->m_vars = a_vars;
        n->n_vars = n_vars;
        return (ast_t*)n;
    }

    struct ConcurrentLocalInit_t // Constructor
    {
        const static concurrent_localityType class_type = concurrent_localityType::ConcurrentLocalInit;
        typedef concurrent_locality_t parent_type;
        concurrent_locality_t base;
        char** m_vars; size_t n_vars; // Sequence
    };
    static inline ast_t* make_ConcurrentLocalInit_t(Allocator &al, const Location &a_loc, char** a_vars, size_t n_vars) {
        ConcurrentLocalInit_t *n;
        n = al.make_new<ConcurrentLocalInit_t>();
        n->base.type = concurrent_localityType::ConcurrentLocalInit;
        n->base.base.type = astType::concurrent_locality;
        n->base.base.loc = a_loc;
        n->m_vars = a_vars;
        n->n_vars = n_vars;
        return (ast_t*)n;
    }

    struct ConcurrentShared_t // Constructor
    {
        const static concurrent_localityType class_type = concurrent_localityType::ConcurrentShared;
        typedef concurrent_locality_t parent_type;
        concurrent_locality_t base;
        char** m_vars; size_t n_vars; // Sequence
    };
    static inline ast_t* make_ConcurrentShared_t(Allocator &al, const Location &a_loc, char** a_vars, size_t n_vars) {
        ConcurrentShared_t *n;
        n = al.make_new<ConcurrentShared_t>();
        n->base.type = concurrent_localityType::ConcurrentShared;
        n->base.base.type = astType::concurrent_locality;
        n->base.base.loc = a_loc;
        n->m_vars = a_vars;
        n->n_vars = n_vars;
        return (ast_t*)n;
    }

    struct ConcurrentDefault_t // Constructor
    {
        const static concurrent_localityType class_type = concurrent_localityType::ConcurrentDefault;
        typedef concurrent_locality_t parent_type;
        concurrent_locality_t base;
    };
    static inline ast_t* make_ConcurrentDefault_t(Allocator &al, const Location &a_loc) {
        ConcurrentDefault_t *n;
        n = al.make_new<ConcurrentDefault_t>();
        n->base.type = concurrent_localityType::ConcurrentDefault;
        n->base.base.type = astType::concurrent_locality;
        n->base.base.loc = a_loc;
        return (ast_t*)n;
    }

    struct ConcurrentReduce_t // Constructor
    {
        const static concurrent_localityType class_type = concurrent_localityType::ConcurrentReduce;
        typedef concurrent_locality_t parent_type;
        concurrent_locality_t base;
        reduce_opType m_op;
        char** m_vars; size_t n_vars; // Sequence
    };
    static inline ast_t* make_ConcurrentReduce_t(Allocator &al, const Location &a_loc, reduce_opType a_op, char** a_vars, size_t n_vars) {
        ConcurrentReduce_t *n;
        n = al.make_new<ConcurrentReduce_t>();
        n->base.type = concurrent_localityType::ConcurrentReduce;
        n->base.base.type = astType::concurrent_locality;
        n->base.base.loc = a_loc;
        n->m_op = a_op;
        n->m_vars = a_vars;
        n->n_vars = n_vars;
        return (ast_t*)n;
    }





/******************************************************************************/
// Visitor functions

template <class Visitor>
static void visit_unit_t(const unit_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::unit)
    switch (x.type) {
        case unitType::TranslationUnit: { v.visit_TranslationUnit((const TranslationUnit_t &)x); return; }
    }
}

template <class Visitor>
static void visit_mod_t(const mod_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::mod)
    switch (x.type) {
        case modType::Module: { v.visit_Module((const Module_t &)x); return; }
        case modType::Submodule: { v.visit_Submodule((const Submodule_t &)x); return; }
        case modType::BlockData: { v.visit_BlockData((const BlockData_t &)x); return; }
        case modType::Program: { v.visit_Program((const Program_t &)x); return; }
    }
}

template <class Visitor>
static void visit_program_unit_t(const program_unit_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::program_unit)
    switch (x.type) {
        case program_unitType::Subroutine: { v.visit_Subroutine((const Subroutine_t &)x); return; }
        case program_unitType::Procedure: { v.visit_Procedure((const Procedure_t &)x); return; }
        case program_unitType::Function: { v.visit_Function((const Function_t &)x); return; }
    }
}

template <class Visitor>
static void visit_unit_decl1_t(const unit_decl1_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::unit_decl1)
    switch (x.type) {
        case unit_decl1Type::Use: { v.visit_Use((const Use_t &)x); return; }
    }
}

template <class Visitor>
static void visit_unit_decl2_t(const unit_decl2_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::unit_decl2)
    switch (x.type) {
        case unit_decl2Type::Declaration: { v.visit_Declaration((const Declaration_t &)x); return; }
        case unit_decl2Type::Interface: { v.visit_Interface((const Interface_t &)x); return; }
        case unit_decl2Type::DerivedType: { v.visit_DerivedType((const DerivedType_t &)x); return; }
        case unit_decl2Type::Enum: { v.visit_Enum((const Enum_t &)x); return; }
    }
}

template <class Visitor>
static void visit_interface_header_t(const interface_header_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::interface_header)
    switch (x.type) {
        case interface_headerType::InterfaceHeader: { v.visit_InterfaceHeader((const InterfaceHeader_t &)x); return; }
        case interface_headerType::InterfaceHeaderName: { v.visit_InterfaceHeaderName((const InterfaceHeaderName_t &)x); return; }
        case interface_headerType::InterfaceHeaderAssignment: { v.visit_InterfaceHeaderAssignment((const InterfaceHeaderAssignment_t &)x); return; }
        case interface_headerType::InterfaceHeaderOperator: { v.visit_InterfaceHeaderOperator((const InterfaceHeaderOperator_t &)x); return; }
        case interface_headerType::InterfaceHeaderDefinedOperator: { v.visit_InterfaceHeaderDefinedOperator((const InterfaceHeaderDefinedOperator_t &)x); return; }
        case interface_headerType::AbstractInterfaceHeader: { v.visit_AbstractInterfaceHeader((const AbstractInterfaceHeader_t &)x); return; }
        case interface_headerType::InterfaceHeaderWrite: { v.visit_InterfaceHeaderWrite((const InterfaceHeaderWrite_t &)x); return; }
        case interface_headerType::InterfaceHeaderRead: { v.visit_InterfaceHeaderRead((const InterfaceHeaderRead_t &)x); return; }
    }
}

template <class Visitor>
static void visit_interface_item_t(const interface_item_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::interface_item)
    switch (x.type) {
        case interface_itemType::InterfaceProc: { v.visit_InterfaceProc((const InterfaceProc_t &)x); return; }
        case interface_itemType::InterfaceModuleProcedure: { v.visit_InterfaceModuleProcedure((const InterfaceModuleProcedure_t &)x); return; }
    }
}

template <class Visitor>
static void visit_import_statement_t(const import_statement_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::import_statement)
    switch (x.type) {
        case import_statementType::Import: { v.visit_Import((const Import_t &)x); return; }
    }
}

template <class Visitor>
static void visit_implicit_statement_t(const implicit_statement_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::implicit_statement)
    switch (x.type) {
        case implicit_statementType::ImplicitNone: { v.visit_ImplicitNone((const ImplicitNone_t &)x); return; }
        case implicit_statementType::Implicit: { v.visit_Implicit((const Implicit_t &)x); return; }
    }
}

template <class Visitor>
static void visit_implicit_none_spec_t(const implicit_none_spec_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::implicit_none_spec)
    switch (x.type) {
        case implicit_none_specType::ImplicitNoneExternal: { v.visit_ImplicitNoneExternal((const ImplicitNoneExternal_t &)x); return; }
        case implicit_none_specType::ImplicitNoneType: { v.visit_ImplicitNoneType((const ImplicitNoneType_t &)x); return; }
    }
}

template <class Visitor>
static void visit_letter_spec_t(const letter_spec_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::letter_spec)
    switch (x.type) {
        case letter_specType::LetterSpec: { v.visit_LetterSpec((const LetterSpec_t &)x); return; }
    }
}

template <class Visitor>
static void visit_stmt_t(const stmt_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::stmt)
    switch (x.type) {
        case stmtType::Allocate: { v.visit_Allocate((const Allocate_t &)x); return; }
        case stmtType::Assign: { v.visit_Assign((const Assign_t &)x); return; }
        case stmtType::Assignment: { v.visit_Assignment((const Assignment_t &)x); return; }
        case stmtType::Associate: { v.visit_Associate((const Associate_t &)x); return; }
        case stmtType::Backspace: { v.visit_Backspace((const Backspace_t &)x); return; }
        case stmtType::Close: { v.visit_Close((const Close_t &)x); return; }
        case stmtType::Continue: { v.visit_Continue((const Continue_t &)x); return; }
        case stmtType::Cycle: { v.visit_Cycle((const Cycle_t &)x); return; }
        case stmtType::Deallocate: { v.visit_Deallocate((const Deallocate_t &)x); return; }
        case stmtType::Endfile: { v.visit_Endfile((const Endfile_t &)x); return; }
        case stmtType::Entry: { v.visit_Entry((const Entry_t &)x); return; }
        case stmtType::ErrorStop: { v.visit_ErrorStop((const ErrorStop_t &)x); return; }
        case stmtType::EventPost: { v.visit_EventPost((const EventPost_t &)x); return; }
        case stmtType::EventWait: { v.visit_EventWait((const EventWait_t &)x); return; }
        case stmtType::Exit: { v.visit_Exit((const Exit_t &)x); return; }
        case stmtType::Flush: { v.visit_Flush((const Flush_t &)x); return; }
        case stmtType::ForAllSingle: { v.visit_ForAllSingle((const ForAllSingle_t &)x); return; }
        case stmtType::Format: { v.visit_Format((const Format_t &)x); return; }
        case stmtType::FormTeam: { v.visit_FormTeam((const FormTeam_t &)x); return; }
        case stmtType::GoTo: { v.visit_GoTo((const GoTo_t &)x); return; }
        case stmtType::Inquire: { v.visit_Inquire((const Inquire_t &)x); return; }
        case stmtType::Nullify: { v.visit_Nullify((const Nullify_t &)x); return; }
        case stmtType::Open: { v.visit_Open((const Open_t &)x); return; }
        case stmtType::Return: { v.visit_Return((const Return_t &)x); return; }
        case stmtType::Print: { v.visit_Print((const Print_t &)x); return; }
        case stmtType::Read: { v.visit_Read((const Read_t &)x); return; }
        case stmtType::Rewind: { v.visit_Rewind((const Rewind_t &)x); return; }
        case stmtType::Stop: { v.visit_Stop((const Stop_t &)x); return; }
        case stmtType::SubroutineCall: { v.visit_SubroutineCall((const SubroutineCall_t &)x); return; }
        case stmtType::SyncAll: { v.visit_SyncAll((const SyncAll_t &)x); return; }
        case stmtType::SyncImages: { v.visit_SyncImages((const SyncImages_t &)x); return; }
        case stmtType::SyncMemory: { v.visit_SyncMemory((const SyncMemory_t &)x); return; }
        case stmtType::SyncTeam: { v.visit_SyncTeam((const SyncTeam_t &)x); return; }
        case stmtType::Write: { v.visit_Write((const Write_t &)x); return; }
        case stmtType::AssociateBlock: { v.visit_AssociateBlock((const AssociateBlock_t &)x); return; }
        case stmtType::Block: { v.visit_Block((const Block_t &)x); return; }
        case stmtType::ChangeTeam: { v.visit_ChangeTeam((const ChangeTeam_t &)x); return; }
        case stmtType::Critical: { v.visit_Critical((const Critical_t &)x); return; }
        case stmtType::DoConcurrentLoop: { v.visit_DoConcurrentLoop((const DoConcurrentLoop_t &)x); return; }
        case stmtType::DoLoop: { v.visit_DoLoop((const DoLoop_t &)x); return; }
        case stmtType::ForAll: { v.visit_ForAll((const ForAll_t &)x); return; }
        case stmtType::If: { v.visit_If((const If_t &)x); return; }
        case stmtType::IfArithmetic: { v.visit_IfArithmetic((const IfArithmetic_t &)x); return; }
        case stmtType::Select: { v.visit_Select((const Select_t &)x); return; }
        case stmtType::SelectRank: { v.visit_SelectRank((const SelectRank_t &)x); return; }
        case stmtType::SelectType: { v.visit_SelectType((const SelectType_t &)x); return; }
        case stmtType::Where: { v.visit_Where((const Where_t &)x); return; }
        case stmtType::WhileLoop: { v.visit_WhileLoop((const WhileLoop_t &)x); return; }
    }
}

template <class Visitor>
static void visit_expr_t(const expr_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::expr)
    switch (x.type) {
        case exprType::BoolOp: { v.visit_BoolOp((const BoolOp_t &)x); return; }
        case exprType::BinOp: { v.visit_BinOp((const BinOp_t &)x); return; }
        case exprType::DefBinOp: { v.visit_DefBinOp((const DefBinOp_t &)x); return; }
        case exprType::StrOp: { v.visit_StrOp((const StrOp_t &)x); return; }
        case exprType::UnaryOp: { v.visit_UnaryOp((const UnaryOp_t &)x); return; }
        case exprType::DefUnaryOp: { v.visit_DefUnaryOp((const DefUnaryOp_t &)x); return; }
        case exprType::Compare: { v.visit_Compare((const Compare_t &)x); return; }
        case exprType::FuncCallOrArray: { v.visit_FuncCallOrArray((const FuncCallOrArray_t &)x); return; }
        case exprType::CoarrayRef: { v.visit_CoarrayRef((const CoarrayRef_t &)x); return; }
        case exprType::ArrayInitializer: { v.visit_ArrayInitializer((const ArrayInitializer_t &)x); return; }
        case exprType::ImpliedDoLoop: { v.visit_ImpliedDoLoop((const ImpliedDoLoop_t &)x); return; }
        case exprType::Num: { v.visit_Num((const Num_t &)x); return; }
        case exprType::Real: { v.visit_Real((const Real_t &)x); return; }
        case exprType::Complex: { v.visit_Complex((const Complex_t &)x); return; }
        case exprType::String: { v.visit_String((const String_t &)x); return; }
        case exprType::Substring: { v.visit_Substring((const Substring_t &)x); return; }
        case exprType::BOZ: { v.visit_BOZ((const BOZ_t &)x); return; }
        case exprType::Name: { v.visit_Name((const Name_t &)x); return; }
        case exprType::Logical: { v.visit_Logical((const Logical_t &)x); return; }
        case exprType::DataImpliedDo: { v.visit_DataImpliedDo((const DataImpliedDo_t &)x); return; }
        case exprType::Parenthesis: { v.visit_Parenthesis((const Parenthesis_t &)x); return; }
    }
}

template <class Visitor>
static void visit_trivia_t(const trivia_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::trivia)
    switch (x.type) {
        case triviaType::TriviaNode: { v.visit_TriviaNode((const TriviaNode_t &)x); return; }
    }
}

template <class Visitor>
static void visit_trivia_node_t(const trivia_node_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::trivia_node)
    switch (x.type) {
        case trivia_nodeType::Comment: { v.visit_Comment((const Comment_t &)x); return; }
        case trivia_nodeType::EOLComment: { v.visit_EOLComment((const EOLComment_t &)x); return; }
        case trivia_nodeType::EndOfLine: { v.visit_EndOfLine((const EndOfLine_t &)x); return; }
        case trivia_nodeType::Semicolon: { v.visit_Semicolon((const Semicolon_t &)x); return; }
    }
}

template <class Visitor>
static void visit_procedure_decl_t(const procedure_decl_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::procedure_decl)
    switch (x.type) {
        case procedure_declType::DerivedTypeProc: { v.visit_DerivedTypeProc((const DerivedTypeProc_t &)x); return; }
        case procedure_declType::GenericOperator: { v.visit_GenericOperator((const GenericOperator_t &)x); return; }
        case procedure_declType::GenericDefinedOperator: { v.visit_GenericDefinedOperator((const GenericDefinedOperator_t &)x); return; }
        case procedure_declType::GenericAssignment: { v.visit_GenericAssignment((const GenericAssignment_t &)x); return; }
        case procedure_declType::GenericName: { v.visit_GenericName((const GenericName_t &)x); return; }
        case procedure_declType::GenericWrite: { v.visit_GenericWrite((const GenericWrite_t &)x); return; }
        case procedure_declType::GenericRead: { v.visit_GenericRead((const GenericRead_t &)x); return; }
        case procedure_declType::FinalName: { v.visit_FinalName((const FinalName_t &)x); return; }
        case procedure_declType::Private: { v.visit_Private((const Private_t &)x); return; }
    }
}

template <class Visitor>
static void visit_decl_attribute_t(const decl_attribute_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::decl_attribute)
    switch (x.type) {
        case decl_attributeType::AttrBind: { v.visit_AttrBind((const AttrBind_t &)x); return; }
        case decl_attributeType::AttrData: { v.visit_AttrData((const AttrData_t &)x); return; }
        case decl_attributeType::AttrDimension: { v.visit_AttrDimension((const AttrDimension_t &)x); return; }
        case decl_attributeType::AttrCodimension: { v.visit_AttrCodimension((const AttrCodimension_t &)x); return; }
        case decl_attributeType::AttrEquivalence: { v.visit_AttrEquivalence((const AttrEquivalence_t &)x); return; }
        case decl_attributeType::AttrExtends: { v.visit_AttrExtends((const AttrExtends_t &)x); return; }
        case decl_attributeType::AttrIntent: { v.visit_AttrIntent((const AttrIntent_t &)x); return; }
        case decl_attributeType::AttrNamelist: { v.visit_AttrNamelist((const AttrNamelist_t &)x); return; }
        case decl_attributeType::AttrPass: { v.visit_AttrPass((const AttrPass_t &)x); return; }
        case decl_attributeType::SimpleAttribute: { v.visit_SimpleAttribute((const SimpleAttribute_t &)x); return; }
        case decl_attributeType::AttrType: { v.visit_AttrType((const AttrType_t &)x); return; }
        case decl_attributeType::AttrAssignment: { v.visit_AttrAssignment((const AttrAssignment_t &)x); return; }
        case decl_attributeType::AttrIntrinsicOperator: { v.visit_AttrIntrinsicOperator((const AttrIntrinsicOperator_t &)x); return; }
        case decl_attributeType::AttrDefinedOperator: { v.visit_AttrDefinedOperator((const AttrDefinedOperator_t &)x); return; }
    }
}

template <class Visitor>
static void visit_event_attribute_t(const event_attribute_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::event_attribute)
    switch (x.type) {
        case event_attributeType::AttrStat: { v.visit_AttrStat((const AttrStat_t &)x); return; }
        case event_attributeType::AttrErrmsg: { v.visit_AttrErrmsg((const AttrErrmsg_t &)x); return; }
        case event_attributeType::AttrNewIndex: { v.visit_AttrNewIndex((const AttrNewIndex_t &)x); return; }
        case event_attributeType::AttrEventWaitKwArg: { v.visit_AttrEventWaitKwArg((const AttrEventWaitKwArg_t &)x); return; }
    }
}

template <class Visitor>
static void visit_team_attribute_t(const team_attribute_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::team_attribute)
    switch (x.type) {
        case team_attributeType::CoarrayAssociation: { v.visit_CoarrayAssociation((const CoarrayAssociation_t &)x); return; }
    }
}

template <class Visitor>
static void visit_bind_t(const bind_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::bind)
    switch (x.type) {
        case bindType::Bind: { v.visit_Bind((const Bind_t &)x); return; }
    }
}

template <class Visitor>
static void visit_array_index_t(const array_index_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::array_index)
    switch (x.type) {
        case array_indexType::ArrayIndex: { v.visit_ArrayIndex((const ArrayIndex_t &)x); return; }
    }
}

template <class Visitor>
static void visit_case_stmt_t(const case_stmt_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::case_stmt)
    switch (x.type) {
        case case_stmtType::CaseStmt: { v.visit_CaseStmt((const CaseStmt_t &)x); return; }
        case case_stmtType::CaseStmt_Default: { v.visit_CaseStmt_Default((const CaseStmt_Default_t &)x); return; }
    }
}

template <class Visitor>
static void visit_case_cond_t(const case_cond_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::case_cond)
    switch (x.type) {
        case case_condType::CaseCondExpr: { v.visit_CaseCondExpr((const CaseCondExpr_t &)x); return; }
        case case_condType::CaseCondRange: { v.visit_CaseCondRange((const CaseCondRange_t &)x); return; }
    }
}

template <class Visitor>
static void visit_rank_stmt_t(const rank_stmt_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::rank_stmt)
    switch (x.type) {
        case rank_stmtType::RankExpr: { v.visit_RankExpr((const RankExpr_t &)x); return; }
        case rank_stmtType::RankStar: { v.visit_RankStar((const RankStar_t &)x); return; }
        case rank_stmtType::RankDefault: { v.visit_RankDefault((const RankDefault_t &)x); return; }
    }
}

template <class Visitor>
static void visit_type_stmt_t(const type_stmt_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::type_stmt)
    switch (x.type) {
        case type_stmtType::TypeStmtName: { v.visit_TypeStmtName((const TypeStmtName_t &)x); return; }
        case type_stmtType::TypeStmtType: { v.visit_TypeStmtType((const TypeStmtType_t &)x); return; }
        case type_stmtType::ClassStmt: { v.visit_ClassStmt((const ClassStmt_t &)x); return; }
        case type_stmtType::ClassDefault: { v.visit_ClassDefault((const ClassDefault_t &)x); return; }
    }
}

template <class Visitor>
static void visit_use_symbol_t(const use_symbol_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::use_symbol)
    switch (x.type) {
        case use_symbolType::UseSymbol: { v.visit_UseSymbol((const UseSymbol_t &)x); return; }
        case use_symbolType::UseAssignment: { v.visit_UseAssignment((const UseAssignment_t &)x); return; }
        case use_symbolType::IntrinsicOperator: { v.visit_IntrinsicOperator((const IntrinsicOperator_t &)x); return; }
        case use_symbolType::DefinedOperator: { v.visit_DefinedOperator((const DefinedOperator_t &)x); return; }
        case use_symbolType::RenameOperator: { v.visit_RenameOperator((const RenameOperator_t &)x); return; }
        case use_symbolType::UseWrite: { v.visit_UseWrite((const UseWrite_t &)x); return; }
        case use_symbolType::UseRead: { v.visit_UseRead((const UseRead_t &)x); return; }
    }
}

template <class Visitor>
static void visit_concurrent_control_t(const concurrent_control_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::concurrent_control)
    switch (x.type) {
        case concurrent_controlType::ConcurrentControl: { v.visit_ConcurrentControl((const ConcurrentControl_t &)x); return; }
    }
}

template <class Visitor>
static void visit_concurrent_locality_t(const concurrent_locality_t &x, Visitor &v) {
    LFORTRAN_ASSERT(x.base.type == astType::concurrent_locality)
    switch (x.type) {
        case concurrent_localityType::ConcurrentLocal: { v.visit_ConcurrentLocal((const ConcurrentLocal_t &)x); return; }
        case concurrent_localityType::ConcurrentLocalInit: { v.visit_ConcurrentLocalInit((const ConcurrentLocalInit_t &)x); return; }
        case concurrent_localityType::ConcurrentShared: { v.visit_ConcurrentShared((const ConcurrentShared_t &)x); return; }
        case concurrent_localityType::ConcurrentDefault: { v.visit_ConcurrentDefault((const ConcurrentDefault_t &)x); return; }
        case concurrent_localityType::ConcurrentReduce: { v.visit_ConcurrentReduce((const ConcurrentReduce_t &)x); return; }
    }
}



template <class Visitor>
static void visit_ast_t(const ast_t &x, Visitor &v) {
    switch (x.type) {
        case astType::unit: { v.visit_unit((const unit_t &)x); return; }
        case astType::mod: { v.visit_mod((const mod_t &)x); return; }
        case astType::program_unit: { v.visit_program_unit((const program_unit_t &)x); return; }
        case astType::unit_decl1: { v.visit_unit_decl1((const unit_decl1_t &)x); return; }
        case astType::unit_decl2: { v.visit_unit_decl2((const unit_decl2_t &)x); return; }
        case astType::interface_header: { v.visit_interface_header((const interface_header_t &)x); return; }
        case astType::interface_item: { v.visit_interface_item((const interface_item_t &)x); return; }
        case astType::import_statement: { v.visit_import_statement((const import_statement_t &)x); return; }
        case astType::implicit_statement: { v.visit_implicit_statement((const implicit_statement_t &)x); return; }
        case astType::implicit_none_spec: { v.visit_implicit_none_spec((const implicit_none_spec_t &)x); return; }
        case astType::letter_spec: { v.visit_letter_spec((const letter_spec_t &)x); return; }
        case astType::stmt: { v.visit_stmt((const stmt_t &)x); return; }
        case astType::expr: { v.visit_expr((const expr_t &)x); return; }
        case astType::trivia: { v.visit_trivia((const trivia_t &)x); return; }
        case astType::trivia_node: { v.visit_trivia_node((const trivia_node_t &)x); return; }
        case astType::procedure_decl: { v.visit_procedure_decl((const procedure_decl_t &)x); return; }
        case astType::decl_attribute: { v.visit_decl_attribute((const decl_attribute_t &)x); return; }
        case astType::event_attribute: { v.visit_event_attribute((const event_attribute_t &)x); return; }
        case astType::team_attribute: { v.visit_team_attribute((const team_attribute_t &)x); return; }
        case astType::bind: { v.visit_bind((const bind_t &)x); return; }
        case astType::array_index: { v.visit_array_index((const array_index_t &)x); return; }
        case astType::case_stmt: { v.visit_case_stmt((const case_stmt_t &)x); return; }
        case astType::case_cond: { v.visit_case_cond((const case_cond_t &)x); return; }
        case astType::rank_stmt: { v.visit_rank_stmt((const rank_stmt_t &)x); return; }
        case astType::type_stmt: { v.visit_type_stmt((const type_stmt_t &)x); return; }
        case astType::use_symbol: { v.visit_use_symbol((const use_symbol_t &)x); return; }
        case astType::concurrent_control: { v.visit_concurrent_control((const concurrent_control_t &)x); return; }
        case astType::concurrent_locality: { v.visit_concurrent_locality((const concurrent_locality_t &)x); return; }
    }
}



/******************************************************************************/
// Visitor base class

template <class Derived>
class BaseVisitor
{
private:
    Derived& self() { return static_cast<Derived&>(*this); }
public:
    void visit_ast(const ast_t &b) { visit_ast_t(b, self()); }
    void visit_unit(const unit_t &b) { visit_unit_t(b, self()); }
        void visit_TranslationUnit(const TranslationUnit_t & /* x */) { throw LFortran::LFortranException("visit_TranslationUnit() not implemented"); }
    void visit_mod(const mod_t &b) { visit_mod_t(b, self()); }
        void visit_Module(const Module_t & /* x */) { throw LFortran::LFortranException("visit_Module() not implemented"); }
        void visit_Submodule(const Submodule_t & /* x */) { throw LFortran::LFortranException("visit_Submodule() not implemented"); }
        void visit_BlockData(const BlockData_t & /* x */) { throw LFortran::LFortranException("visit_BlockData() not implemented"); }
        void visit_Program(const Program_t & /* x */) { throw LFortran::LFortranException("visit_Program() not implemented"); }
    void visit_program_unit(const program_unit_t &b) { visit_program_unit_t(b, self()); }
        void visit_Subroutine(const Subroutine_t & /* x */) { throw LFortran::LFortranException("visit_Subroutine() not implemented"); }
        void visit_Procedure(const Procedure_t & /* x */) { throw LFortran::LFortranException("visit_Procedure() not implemented"); }
        void visit_Function(const Function_t & /* x */) { throw LFortran::LFortranException("visit_Function() not implemented"); }
    void visit_unit_decl1(const unit_decl1_t &b) { visit_unit_decl1_t(b, self()); }
        void visit_Use(const Use_t & /* x */) { throw LFortran::LFortranException("visit_Use() not implemented"); }
    void visit_unit_decl2(const unit_decl2_t &b) { visit_unit_decl2_t(b, self()); }
        void visit_Declaration(const Declaration_t & /* x */) { throw LFortran::LFortranException("visit_Declaration() not implemented"); }
        void visit_Interface(const Interface_t & /* x */) { throw LFortran::LFortranException("visit_Interface() not implemented"); }
        void visit_DerivedType(const DerivedType_t & /* x */) { throw LFortran::LFortranException("visit_DerivedType() not implemented"); }
        void visit_Enum(const Enum_t & /* x */) { throw LFortran::LFortranException("visit_Enum() not implemented"); }
    void visit_interface_header(const interface_header_t &b) { visit_interface_header_t(b, self()); }
        void visit_InterfaceHeader(const InterfaceHeader_t & /* x */) { throw LFortran::LFortranException("visit_InterfaceHeader() not implemented"); }
        void visit_InterfaceHeaderName(const InterfaceHeaderName_t & /* x */) { throw LFortran::LFortranException("visit_InterfaceHeaderName() not implemented"); }
        void visit_InterfaceHeaderAssignment(const InterfaceHeaderAssignment_t & /* x */) { throw LFortran::LFortranException("visit_InterfaceHeaderAssignment() not implemented"); }
        void visit_InterfaceHeaderOperator(const InterfaceHeaderOperator_t & /* x */) { throw LFortran::LFortranException("visit_InterfaceHeaderOperator() not implemented"); }
        void visit_InterfaceHeaderDefinedOperator(const InterfaceHeaderDefinedOperator_t & /* x */) { throw LFortran::LFortranException("visit_InterfaceHeaderDefinedOperator() not implemented"); }
        void visit_AbstractInterfaceHeader(const AbstractInterfaceHeader_t & /* x */) { throw LFortran::LFortranException("visit_AbstractInterfaceHeader() not implemented"); }
        void visit_InterfaceHeaderWrite(const InterfaceHeaderWrite_t & /* x */) { throw LFortran::LFortranException("visit_InterfaceHeaderWrite() not implemented"); }
        void visit_InterfaceHeaderRead(const InterfaceHeaderRead_t & /* x */) { throw LFortran::LFortranException("visit_InterfaceHeaderRead() not implemented"); }
    void visit_interface_item(const interface_item_t &b) { visit_interface_item_t(b, self()); }
        void visit_InterfaceProc(const InterfaceProc_t & /* x */) { throw LFortran::LFortranException("visit_InterfaceProc() not implemented"); }
        void visit_InterfaceModuleProcedure(const InterfaceModuleProcedure_t & /* x */) { throw LFortran::LFortranException("visit_InterfaceModuleProcedure() not implemented"); }
    void visit_import_statement(const import_statement_t &b) { visit_import_statement_t(b, self()); }
        void visit_Import(const Import_t & /* x */) { throw LFortran::LFortranException("visit_Import() not implemented"); }
    void visit_implicit_statement(const implicit_statement_t &b) { visit_implicit_statement_t(b, self()); }
        void visit_ImplicitNone(const ImplicitNone_t & /* x */) { throw LFortran::LFortranException("visit_ImplicitNone() not implemented"); }
        void visit_Implicit(const Implicit_t & /* x */) { throw LFortran::LFortranException("visit_Implicit() not implemented"); }
    void visit_implicit_none_spec(const implicit_none_spec_t &b) { visit_implicit_none_spec_t(b, self()); }
        void visit_ImplicitNoneExternal(const ImplicitNoneExternal_t & /* x */) { throw LFortran::LFortranException("visit_ImplicitNoneExternal() not implemented"); }
        void visit_ImplicitNoneType(const ImplicitNoneType_t & /* x */) { throw LFortran::LFortranException("visit_ImplicitNoneType() not implemented"); }
    void visit_letter_spec(const letter_spec_t &b) { visit_letter_spec_t(b, self()); }
        void visit_LetterSpec(const LetterSpec_t & /* x */) { throw LFortran::LFortranException("visit_LetterSpec() not implemented"); }
    void visit_stmt(const stmt_t &b) { visit_stmt_t(b, self()); }
        void visit_Allocate(const Allocate_t & /* x */) { throw LFortran::LFortranException("visit_Allocate() not implemented"); }
        void visit_Assign(const Assign_t & /* x */) { throw LFortran::LFortranException("visit_Assign() not implemented"); }
        void visit_Assignment(const Assignment_t & /* x */) { throw LFortran::LFortranException("visit_Assignment() not implemented"); }
        void visit_Associate(const Associate_t & /* x */) { throw LFortran::LFortranException("visit_Associate() not implemented"); }
        void visit_Backspace(const Backspace_t & /* x */) { throw LFortran::LFortranException("visit_Backspace() not implemented"); }
        void visit_Close(const Close_t & /* x */) { throw LFortran::LFortranException("visit_Close() not implemented"); }
        void visit_Continue(const Continue_t & /* x */) { throw LFortran::LFortranException("visit_Continue() not implemented"); }
        void visit_Cycle(const Cycle_t & /* x */) { throw LFortran::LFortranException("visit_Cycle() not implemented"); }
        void visit_Deallocate(const Deallocate_t & /* x */) { throw LFortran::LFortranException("visit_Deallocate() not implemented"); }
        void visit_Endfile(const Endfile_t & /* x */) { throw LFortran::LFortranException("visit_Endfile() not implemented"); }
        void visit_Entry(const Entry_t & /* x */) { throw LFortran::LFortranException("visit_Entry() not implemented"); }
        void visit_ErrorStop(const ErrorStop_t & /* x */) { throw LFortran::LFortranException("visit_ErrorStop() not implemented"); }
        void visit_EventPost(const EventPost_t & /* x */) { throw LFortran::LFortranException("visit_EventPost() not implemented"); }
        void visit_EventWait(const EventWait_t & /* x */) { throw LFortran::LFortranException("visit_EventWait() not implemented"); }
        void visit_Exit(const Exit_t & /* x */) { throw LFortran::LFortranException("visit_Exit() not implemented"); }
        void visit_Flush(const Flush_t & /* x */) { throw LFortran::LFortranException("visit_Flush() not implemented"); }
        void visit_ForAllSingle(const ForAllSingle_t & /* x */) { throw LFortran::LFortranException("visit_ForAllSingle() not implemented"); }
        void visit_Format(const Format_t & /* x */) { throw LFortran::LFortranException("visit_Format() not implemented"); }
        void visit_FormTeam(const FormTeam_t & /* x */) { throw LFortran::LFortranException("visit_FormTeam() not implemented"); }
        void visit_GoTo(const GoTo_t & /* x */) { throw LFortran::LFortranException("visit_GoTo() not implemented"); }
        void visit_Inquire(const Inquire_t & /* x */) { throw LFortran::LFortranException("visit_Inquire() not implemented"); }
        void visit_Nullify(const Nullify_t & /* x */) { throw LFortran::LFortranException("visit_Nullify() not implemented"); }
        void visit_Open(const Open_t & /* x */) { throw LFortran::LFortranException("visit_Open() not implemented"); }
        void visit_Return(const Return_t & /* x */) { throw LFortran::LFortranException("visit_Return() not implemented"); }
        void visit_Print(const Print_t & /* x */) { throw LFortran::LFortranException("visit_Print() not implemented"); }
        void visit_Read(const Read_t & /* x */) { throw LFortran::LFortranException("visit_Read() not implemented"); }
        void visit_Rewind(const Rewind_t & /* x */) { throw LFortran::LFortranException("visit_Rewind() not implemented"); }
        void visit_Stop(const Stop_t & /* x */) { throw LFortran::LFortranException("visit_Stop() not implemented"); }
        void visit_SubroutineCall(const SubroutineCall_t & /* x */) { throw LFortran::LFortranException("visit_SubroutineCall() not implemented"); }
        void visit_SyncAll(const SyncAll_t & /* x */) { throw LFortran::LFortranException("visit_SyncAll() not implemented"); }
        void visit_SyncImages(const SyncImages_t & /* x */) { throw LFortran::LFortranException("visit_SyncImages() not implemented"); }
        void visit_SyncMemory(const SyncMemory_t & /* x */) { throw LFortran::LFortranException("visit_SyncMemory() not implemented"); }
        void visit_SyncTeam(const SyncTeam_t & /* x */) { throw LFortran::LFortranException("visit_SyncTeam() not implemented"); }
        void visit_Write(const Write_t & /* x */) { throw LFortran::LFortranException("visit_Write() not implemented"); }
        void visit_AssociateBlock(const AssociateBlock_t & /* x */) { throw LFortran::LFortranException("visit_AssociateBlock() not implemented"); }
        void visit_Block(const Block_t & /* x */) { throw LFortran::LFortranException("visit_Block() not implemented"); }
        void visit_ChangeTeam(const ChangeTeam_t & /* x */) { throw LFortran::LFortranException("visit_ChangeTeam() not implemented"); }
        void visit_Critical(const Critical_t & /* x */) { throw LFortran::LFortranException("visit_Critical() not implemented"); }
        void visit_DoConcurrentLoop(const DoConcurrentLoop_t & /* x */) { throw LFortran::LFortranException("visit_DoConcurrentLoop() not implemented"); }
        void visit_DoLoop(const DoLoop_t & /* x */) { throw LFortran::LFortranException("visit_DoLoop() not implemented"); }
        void visit_ForAll(const ForAll_t & /* x */) { throw LFortran::LFortranException("visit_ForAll() not implemented"); }
        void visit_If(const If_t & /* x */) { throw LFortran::LFortranException("visit_If() not implemented"); }
        void visit_IfArithmetic(const IfArithmetic_t & /* x */) { throw LFortran::LFortranException("visit_IfArithmetic() not implemented"); }
        void visit_Select(const Select_t & /* x */) { throw LFortran::LFortranException("visit_Select() not implemented"); }
        void visit_SelectRank(const SelectRank_t & /* x */) { throw LFortran::LFortranException("visit_SelectRank() not implemented"); }
        void visit_SelectType(const SelectType_t & /* x */) { throw LFortran::LFortranException("visit_SelectType() not implemented"); }
        void visit_Where(const Where_t & /* x */) { throw LFortran::LFortranException("visit_Where() not implemented"); }
        void visit_WhileLoop(const WhileLoop_t & /* x */) { throw LFortran::LFortranException("visit_WhileLoop() not implemented"); }
    void visit_expr(const expr_t &b) { visit_expr_t(b, self()); }
        void visit_BoolOp(const BoolOp_t & /* x */) { throw LFortran::LFortranException("visit_BoolOp() not implemented"); }
        void visit_BinOp(const BinOp_t & /* x */) { throw LFortran::LFortranException("visit_BinOp() not implemented"); }
        void visit_DefBinOp(const DefBinOp_t & /* x */) { throw LFortran::LFortranException("visit_DefBinOp() not implemented"); }
        void visit_StrOp(const StrOp_t & /* x */) { throw LFortran::LFortranException("visit_StrOp() not implemented"); }
        void visit_UnaryOp(const UnaryOp_t & /* x */) { throw LFortran::LFortranException("visit_UnaryOp() not implemented"); }
        void visit_DefUnaryOp(const DefUnaryOp_t & /* x */) { throw LFortran::LFortranException("visit_DefUnaryOp() not implemented"); }
        void visit_Compare(const Compare_t & /* x */) { throw LFortran::LFortranException("visit_Compare() not implemented"); }
        void visit_FuncCallOrArray(const FuncCallOrArray_t & /* x */) { throw LFortran::LFortranException("visit_FuncCallOrArray() not implemented"); }
        void visit_CoarrayRef(const CoarrayRef_t & /* x */) { throw LFortran::LFortranException("visit_CoarrayRef() not implemented"); }
        void visit_ArrayInitializer(const ArrayInitializer_t & /* x */) { throw LFortran::LFortranException("visit_ArrayInitializer() not implemented"); }
        void visit_ImpliedDoLoop(const ImpliedDoLoop_t & /* x */) { throw LFortran::LFortranException("visit_ImpliedDoLoop() not implemented"); }
        void visit_Num(const Num_t & /* x */) { throw LFortran::LFortranException("visit_Num() not implemented"); }
        void visit_Real(const Real_t & /* x */) { throw LFortran::LFortranException("visit_Real() not implemented"); }
        void visit_Complex(const Complex_t & /* x */) { throw LFortran::LFortranException("visit_Complex() not implemented"); }
        void visit_String(const String_t & /* x */) { throw LFortran::LFortranException("visit_String() not implemented"); }
        void visit_Substring(const Substring_t & /* x */) { throw LFortran::LFortranException("visit_Substring() not implemented"); }
        void visit_BOZ(const BOZ_t & /* x */) { throw LFortran::LFortranException("visit_BOZ() not implemented"); }
        void visit_Name(const Name_t & /* x */) { throw LFortran::LFortranException("visit_Name() not implemented"); }
        void visit_Logical(const Logical_t & /* x */) { throw LFortran::LFortranException("visit_Logical() not implemented"); }
        void visit_DataImpliedDo(const DataImpliedDo_t & /* x */) { throw LFortran::LFortranException("visit_DataImpliedDo() not implemented"); }
        void visit_Parenthesis(const Parenthesis_t & /* x */) { throw LFortran::LFortranException("visit_Parenthesis() not implemented"); }
    void visit_trivia(const trivia_t &b) { visit_trivia_t(b, self()); }
        void visit_TriviaNode(const TriviaNode_t & /* x */) { throw LFortran::LFortranException("visit_TriviaNode() not implemented"); }
    void visit_trivia_node(const trivia_node_t &b) { visit_trivia_node_t(b, self()); }
        void visit_Comment(const Comment_t & /* x */) { throw LFortran::LFortranException("visit_Comment() not implemented"); }
        void visit_EOLComment(const EOLComment_t & /* x */) { throw LFortran::LFortranException("visit_EOLComment() not implemented"); }
        void visit_EndOfLine(const EndOfLine_t & /* x */) { throw LFortran::LFortranException("visit_EndOfLine() not implemented"); }
        void visit_Semicolon(const Semicolon_t & /* x */) { throw LFortran::LFortranException("visit_Semicolon() not implemented"); }
    void visit_procedure_decl(const procedure_decl_t &b) { visit_procedure_decl_t(b, self()); }
        void visit_DerivedTypeProc(const DerivedTypeProc_t & /* x */) { throw LFortran::LFortranException("visit_DerivedTypeProc() not implemented"); }
        void visit_GenericOperator(const GenericOperator_t & /* x */) { throw LFortran::LFortranException("visit_GenericOperator() not implemented"); }
        void visit_GenericDefinedOperator(const GenericDefinedOperator_t & /* x */) { throw LFortran::LFortranException("visit_GenericDefinedOperator() not implemented"); }
        void visit_GenericAssignment(const GenericAssignment_t & /* x */) { throw LFortran::LFortranException("visit_GenericAssignment() not implemented"); }
        void visit_GenericName(const GenericName_t & /* x */) { throw LFortran::LFortranException("visit_GenericName() not implemented"); }
        void visit_GenericWrite(const GenericWrite_t & /* x */) { throw LFortran::LFortranException("visit_GenericWrite() not implemented"); }
        void visit_GenericRead(const GenericRead_t & /* x */) { throw LFortran::LFortranException("visit_GenericRead() not implemented"); }
        void visit_FinalName(const FinalName_t & /* x */) { throw LFortran::LFortranException("visit_FinalName() not implemented"); }
        void visit_Private(const Private_t & /* x */) { throw LFortran::LFortranException("visit_Private() not implemented"); }
    void visit_decl_attribute(const decl_attribute_t &b) { visit_decl_attribute_t(b, self()); }
        void visit_AttrBind(const AttrBind_t & /* x */) { throw LFortran::LFortranException("visit_AttrBind() not implemented"); }
        void visit_AttrData(const AttrData_t & /* x */) { throw LFortran::LFortranException("visit_AttrData() not implemented"); }
        void visit_AttrDimension(const AttrDimension_t & /* x */) { throw LFortran::LFortranException("visit_AttrDimension() not implemented"); }
        void visit_AttrCodimension(const AttrCodimension_t & /* x */) { throw LFortran::LFortranException("visit_AttrCodimension() not implemented"); }
        void visit_AttrEquivalence(const AttrEquivalence_t & /* x */) { throw LFortran::LFortranException("visit_AttrEquivalence() not implemented"); }
        void visit_AttrExtends(const AttrExtends_t & /* x */) { throw LFortran::LFortranException("visit_AttrExtends() not implemented"); }
        void visit_AttrIntent(const AttrIntent_t & /* x */) { throw LFortran::LFortranException("visit_AttrIntent() not implemented"); }
        void visit_AttrNamelist(const AttrNamelist_t & /* x */) { throw LFortran::LFortranException("visit_AttrNamelist() not implemented"); }
        void visit_AttrPass(const AttrPass_t & /* x */) { throw LFortran::LFortranException("visit_AttrPass() not implemented"); }
        void visit_SimpleAttribute(const SimpleAttribute_t & /* x */) { throw LFortran::LFortranException("visit_SimpleAttribute() not implemented"); }
        void visit_AttrType(const AttrType_t & /* x */) { throw LFortran::LFortranException("visit_AttrType() not implemented"); }
        void visit_AttrAssignment(const AttrAssignment_t & /* x */) { throw LFortran::LFortranException("visit_AttrAssignment() not implemented"); }
        void visit_AttrIntrinsicOperator(const AttrIntrinsicOperator_t & /* x */) { throw LFortran::LFortranException("visit_AttrIntrinsicOperator() not implemented"); }
        void visit_AttrDefinedOperator(const AttrDefinedOperator_t & /* x */) { throw LFortran::LFortranException("visit_AttrDefinedOperator() not implemented"); }
    void visit_event_attribute(const event_attribute_t &b) { visit_event_attribute_t(b, self()); }
        void visit_AttrStat(const AttrStat_t & /* x */) { throw LFortran::LFortranException("visit_AttrStat() not implemented"); }
        void visit_AttrErrmsg(const AttrErrmsg_t & /* x */) { throw LFortran::LFortranException("visit_AttrErrmsg() not implemented"); }
        void visit_AttrNewIndex(const AttrNewIndex_t & /* x */) { throw LFortran::LFortranException("visit_AttrNewIndex() not implemented"); }
        void visit_AttrEventWaitKwArg(const AttrEventWaitKwArg_t & /* x */) { throw LFortran::LFortranException("visit_AttrEventWaitKwArg() not implemented"); }
    void visit_team_attribute(const team_attribute_t &b) { visit_team_attribute_t(b, self()); }
        void visit_CoarrayAssociation(const CoarrayAssociation_t & /* x */) { throw LFortran::LFortranException("visit_CoarrayAssociation() not implemented"); }
    void visit_bind(const bind_t &b) { visit_bind_t(b, self()); }
        void visit_Bind(const Bind_t & /* x */) { throw LFortran::LFortranException("visit_Bind() not implemented"); }
    void visit_array_index(const array_index_t &b) { visit_array_index_t(b, self()); }
        void visit_ArrayIndex(const ArrayIndex_t & /* x */) { throw LFortran::LFortranException("visit_ArrayIndex() not implemented"); }
    void visit_case_stmt(const case_stmt_t &b) { visit_case_stmt_t(b, self()); }
        void visit_CaseStmt(const CaseStmt_t & /* x */) { throw LFortran::LFortranException("visit_CaseStmt() not implemented"); }
        void visit_CaseStmt_Default(const CaseStmt_Default_t & /* x */) { throw LFortran::LFortranException("visit_CaseStmt_Default() not implemented"); }
    void visit_case_cond(const case_cond_t &b) { visit_case_cond_t(b, self()); }
        void visit_CaseCondExpr(const CaseCondExpr_t & /* x */) { throw LFortran::LFortranException("visit_CaseCondExpr() not implemented"); }
        void visit_CaseCondRange(const CaseCondRange_t & /* x */) { throw LFortran::LFortranException("visit_CaseCondRange() not implemented"); }
    void visit_rank_stmt(const rank_stmt_t &b) { visit_rank_stmt_t(b, self()); }
        void visit_RankExpr(const RankExpr_t & /* x */) { throw LFortran::LFortranException("visit_RankExpr() not implemented"); }
        void visit_RankStar(const RankStar_t & /* x */) { throw LFortran::LFortranException("visit_RankStar() not implemented"); }
        void visit_RankDefault(const RankDefault_t & /* x */) { throw LFortran::LFortranException("visit_RankDefault() not implemented"); }
    void visit_type_stmt(const type_stmt_t &b) { visit_type_stmt_t(b, self()); }
        void visit_TypeStmtName(const TypeStmtName_t & /* x */) { throw LFortran::LFortranException("visit_TypeStmtName() not implemented"); }
        void visit_TypeStmtType(const TypeStmtType_t & /* x */) { throw LFortran::LFortranException("visit_TypeStmtType() not implemented"); }
        void visit_ClassStmt(const ClassStmt_t & /* x */) { throw LFortran::LFortranException("visit_ClassStmt() not implemented"); }
        void visit_ClassDefault(const ClassDefault_t & /* x */) { throw LFortran::LFortranException("visit_ClassDefault() not implemented"); }
    void visit_use_symbol(const use_symbol_t &b) { visit_use_symbol_t(b, self()); }
        void visit_UseSymbol(const UseSymbol_t & /* x */) { throw LFortran::LFortranException("visit_UseSymbol() not implemented"); }
        void visit_UseAssignment(const UseAssignment_t & /* x */) { throw LFortran::LFortranException("visit_UseAssignment() not implemented"); }
        void visit_IntrinsicOperator(const IntrinsicOperator_t & /* x */) { throw LFortran::LFortranException("visit_IntrinsicOperator() not implemented"); }
        void visit_DefinedOperator(const DefinedOperator_t & /* x */) { throw LFortran::LFortranException("visit_DefinedOperator() not implemented"); }
        void visit_RenameOperator(const RenameOperator_t & /* x */) { throw LFortran::LFortranException("visit_RenameOperator() not implemented"); }
        void visit_UseWrite(const UseWrite_t & /* x */) { throw LFortran::LFortranException("visit_UseWrite() not implemented"); }
        void visit_UseRead(const UseRead_t & /* x */) { throw LFortran::LFortranException("visit_UseRead() not implemented"); }
    void visit_concurrent_control(const concurrent_control_t &b) { visit_concurrent_control_t(b, self()); }
        void visit_ConcurrentControl(const ConcurrentControl_t & /* x */) { throw LFortran::LFortranException("visit_ConcurrentControl() not implemented"); }
    void visit_concurrent_locality(const concurrent_locality_t &b) { visit_concurrent_locality_t(b, self()); }
        void visit_ConcurrentLocal(const ConcurrentLocal_t & /* x */) { throw LFortran::LFortranException("visit_ConcurrentLocal() not implemented"); }
        void visit_ConcurrentLocalInit(const ConcurrentLocalInit_t & /* x */) { throw LFortran::LFortranException("visit_ConcurrentLocalInit() not implemented"); }
        void visit_ConcurrentShared(const ConcurrentShared_t & /* x */) { throw LFortran::LFortranException("visit_ConcurrentShared() not implemented"); }
        void visit_ConcurrentDefault(const ConcurrentDefault_t & /* x */) { throw LFortran::LFortranException("visit_ConcurrentDefault() not implemented"); }
        void visit_ConcurrentReduce(const ConcurrentReduce_t & /* x */) { throw LFortran::LFortranException("visit_ConcurrentReduce() not implemented"); }
};


/******************************************************************************/
// Walk Visitor base class

template <class Derived>
class BaseWalkVisitor : public BaseVisitor<Derived>
{
private:
    Derived& self() { return static_cast<Derived&>(*this); }
public:
    void visit_TranslationUnit(const TranslationUnit_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Module(const Module_t &x) {
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
        }
        for (size_t i=0; i<x.n_implicit; i++) {
            self().visit_implicit_statement(*x.m_implicit[i]);
        }
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
        }
        for (size_t i=0; i<x.n_contains; i++) {
            self().visit_program_unit(*x.m_contains[i]);
        }
    }
    void visit_Submodule(const Submodule_t &x) {
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
        }
        for (size_t i=0; i<x.n_implicit; i++) {
            self().visit_implicit_statement(*x.m_implicit[i]);
        }
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
        }
        for (size_t i=0; i<x.n_contains; i++) {
            self().visit_program_unit(*x.m_contains[i]);
        }
    }
    void visit_BlockData(const BlockData_t &x) {
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
        }
        for (size_t i=0; i<x.n_implicit; i++) {
            self().visit_implicit_statement(*x.m_implicit[i]);
        }
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
        }
    }
    void visit_Program(const Program_t &x) {
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
        }
        for (size_t i=0; i<x.n_implicit; i++) {
            self().visit_implicit_statement(*x.m_implicit[i]);
        }
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
        }
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        for (size_t i=0; i<x.n_contains; i++) {
            self().visit_program_unit(*x.m_contains[i]);
        }
    }
    void visit_Subroutine(const Subroutine_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_arg(x.m_args[i]);
        }
        for (size_t i=0; i<x.n_attributes; i++) {
            self().visit_decl_attribute(*x.m_attributes[i]);
        }
        if (x.m_bind)
            self().visit_bind(*x.m_bind);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
        }
        for (size_t i=0; i<x.n_import; i++) {
            self().visit_import_statement(*x.m_import[i]);
        }
        for (size_t i=0; i<x.n_implicit; i++) {
            self().visit_implicit_statement(*x.m_implicit[i]);
        }
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
        }
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        for (size_t i=0; i<x.n_contains; i++) {
            self().visit_program_unit(*x.m_contains[i]);
        }
    }
    void visit_Procedure(const Procedure_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_arg(x.m_args[i]);
        }
        for (size_t i=0; i<x.n_attributes; i++) {
            self().visit_decl_attribute(*x.m_attributes[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
        }
        for (size_t i=0; i<x.n_import; i++) {
            self().visit_import_statement(*x.m_import[i]);
        }
        for (size_t i=0; i<x.n_implicit; i++) {
            self().visit_implicit_statement(*x.m_implicit[i]);
        }
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
        }
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        for (size_t i=0; i<x.n_contains; i++) {
            self().visit_program_unit(*x.m_contains[i]);
        }
    }
    void visit_Function(const Function_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_arg(x.m_args[i]);
        }
        for (size_t i=0; i<x.n_attributes; i++) {
            self().visit_decl_attribute(*x.m_attributes[i]);
        }
        if (x.m_return_var)
            self().visit_expr(*x.m_return_var);
        if (x.m_bind)
            self().visit_bind(*x.m_bind);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
        }
        for (size_t i=0; i<x.n_import; i++) {
            self().visit_import_statement(*x.m_import[i]);
        }
        for (size_t i=0; i<x.n_implicit; i++) {
            self().visit_implicit_statement(*x.m_implicit[i]);
        }
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
        }
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        for (size_t i=0; i<x.n_contains; i++) {
            self().visit_program_unit(*x.m_contains[i]);
        }
    }
    void visit_Use(const Use_t &x) {
        for (size_t i=0; i<x.n_nature; i++) {
            self().visit_decl_attribute(*x.m_nature[i]);
        }
        for (size_t i=0; i<x.n_symbols; i++) {
            self().visit_use_symbol(*x.m_symbols[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Declaration(const Declaration_t &x) {
        if (x.m_vartype)
            self().visit_decl_attribute(*x.m_vartype);
        for (size_t i=0; i<x.n_attributes; i++) {
            self().visit_decl_attribute(*x.m_attributes[i]);
        }
        for (size_t i=0; i<x.n_syms; i++) {
            self().visit_var_sym(x.m_syms[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Interface(const Interface_t &x) {
        self().visit_interface_header(*x.m_header);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
        for (size_t i=0; i<x.n_items; i++) {
            self().visit_interface_item(*x.m_items[i]);
        }
    }
    void visit_DerivedType(const DerivedType_t &x) {
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
        for (size_t i=0; i<x.n_attrtype; i++) {
            self().visit_decl_attribute(*x.m_attrtype[i]);
        }
        for (size_t i=0; i<x.n_items; i++) {
            self().visit_unit_decl2(*x.m_items[i]);
        }
        for (size_t i=0; i<x.n_contains; i++) {
            self().visit_procedure_decl(*x.m_contains[i]);
        }
    }
    void visit_Enum(const Enum_t &x) {
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
        for (size_t i=0; i<x.n_items; i++) {
            self().visit_unit_decl2(*x.m_items[i]);
        }
    }
    void visit_InterfaceHeader(const InterfaceHeader_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_InterfaceHeaderName(const InterfaceHeaderName_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_InterfaceHeaderAssignment(const InterfaceHeaderAssignment_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_InterfaceHeaderOperator(const InterfaceHeaderOperator_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_InterfaceHeaderDefinedOperator(const InterfaceHeaderDefinedOperator_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AbstractInterfaceHeader(const AbstractInterfaceHeader_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_InterfaceHeaderWrite(const InterfaceHeaderWrite_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_InterfaceHeaderRead(const InterfaceHeaderRead_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_InterfaceProc(const InterfaceProc_t &x) {
        self().visit_program_unit(*x.m_proc);
    }
    void visit_InterfaceModuleProcedure(const InterfaceModuleProcedure_t &x) {
        for (size_t i=0; i<x.n_attributes; i++) {
            self().visit_decl_attribute(*x.m_attributes[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Import(const Import_t &x) {
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_ImplicitNone(const ImplicitNone_t &x) {
        for (size_t i=0; i<x.n_specs; i++) {
            self().visit_implicit_none_spec(*x.m_specs[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Implicit(const Implicit_t &x) {
        self().visit_decl_attribute(*x.m_type);
        for (size_t i=0; i<x.n_kind; i++) {
            self().visit_letter_spec(*x.m_kind[i]);
        }
        for (size_t i=0; i<x.n_specs; i++) {
            self().visit_letter_spec(*x.m_specs[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_ImplicitNoneExternal(const ImplicitNoneExternal_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ImplicitNoneType(const ImplicitNoneType_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_LetterSpec(const LetterSpec_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Allocate(const Allocate_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_fnarg(x.m_args[i]);
        }
        for (size_t i=0; i<x.n_keywords; i++) {
            self().visit_keyword(x.m_keywords[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Assign(const Assign_t &x) {
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Assignment(const Assignment_t &x) {
        self().visit_expr(*x.m_target);
        self().visit_expr(*x.m_value);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Associate(const Associate_t &x) {
        self().visit_expr(*x.m_target);
        self().visit_expr(*x.m_value);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Backspace(const Backspace_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Close(const Close_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Continue(const Continue_t &x) {
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Cycle(const Cycle_t &x) {
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Deallocate(const Deallocate_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_fnarg(x.m_args[i]);
        }
        for (size_t i=0; i<x.n_keywords; i++) {
            self().visit_keyword(x.m_keywords[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Endfile(const Endfile_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Entry(const Entry_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_arg(x.m_args[i]);
        }
        if (x.m_return_var)
            self().visit_expr(*x.m_return_var);
        if (x.m_bind)
            self().visit_bind(*x.m_bind);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_ErrorStop(const ErrorStop_t &x) {
        if (x.m_code)
            self().visit_expr(*x.m_code);
        if (x.m_quiet)
            self().visit_expr(*x.m_quiet);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_EventPost(const EventPost_t &x) {
        self().visit_expr(*x.m_variable);
        for (size_t i=0; i<x.n_stat; i++) {
            self().visit_event_attribute(*x.m_stat[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_EventWait(const EventWait_t &x) {
        self().visit_expr(*x.m_variable);
        for (size_t i=0; i<x.n_spec; i++) {
            self().visit_event_attribute(*x.m_spec[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Exit(const Exit_t &x) {
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Flush(const Flush_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_ForAllSingle(const ForAllSingle_t &x) {
        for (size_t i=0; i<x.n_control; i++) {
            self().visit_concurrent_control(*x.m_control[i]);
        }
        if (x.m_mask)
            self().visit_expr(*x.m_mask);
        self().visit_stmt(*x.m_assign);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Format(const Format_t &x) {
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_FormTeam(const FormTeam_t &x) {
        self().visit_expr(*x.m_team_number);
        for (size_t i=0; i<x.n_sync_stat; i++) {
            self().visit_event_attribute(*x.m_sync_stat[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_GoTo(const GoTo_t &x) {
        if (x.m_goto_label)
            self().visit_expr(*x.m_goto_label);
        for (size_t i=0; i<x.n_labels; i++) {
            self().visit_expr(*x.m_labels[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Inquire(const Inquire_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
        }
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Nullify(const Nullify_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Open(const Open_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Return(const Return_t &x) {
        if (x.m_value)
            self().visit_expr(*x.m_value);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Print(const Print_t &x) {
        if (x.m_fmt)
            self().visit_expr(*x.m_fmt);
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Read(const Read_t &x) {
        if (x.m_format)
            self().visit_expr(*x.m_format);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_argstar(x.m_args[i]);
        }
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_kw_argstar(x.m_kwargs[i]);
        }
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Rewind(const Rewind_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Stop(const Stop_t &x) {
        if (x.m_code)
            self().visit_expr(*x.m_code);
        if (x.m_quiet)
            self().visit_expr(*x.m_quiet);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_SubroutineCall(const SubroutineCall_t &x) {
        for (size_t i=0; i<x.n_member; i++) {
            self().visit_struct_member(x.m_member[i]);
        }
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_fnarg(x.m_args[i]);
        }
        for (size_t i=0; i<x.n_keywords; i++) {
            self().visit_keyword(x.m_keywords[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_SyncAll(const SyncAll_t &x) {
        for (size_t i=0; i<x.n_stat; i++) {
            self().visit_event_attribute(*x.m_stat[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_SyncImages(const SyncImages_t &x) {
        if (x.m_image_set)
            self().visit_expr(*x.m_image_set);
        for (size_t i=0; i<x.n_stat; i++) {
            self().visit_event_attribute(*x.m_stat[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_SyncMemory(const SyncMemory_t &x) {
        for (size_t i=0; i<x.n_stat; i++) {
            self().visit_event_attribute(*x.m_stat[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_SyncTeam(const SyncTeam_t &x) {
        self().visit_expr(*x.m_value);
        for (size_t i=0; i<x.n_stat; i++) {
            self().visit_event_attribute(*x.m_stat[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Write(const Write_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_argstar(x.m_args[i]);
        }
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_kw_argstar(x.m_kwargs[i]);
        }
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_AssociateBlock(const AssociateBlock_t &x) {
        for (size_t i=0; i<x.n_syms; i++) {
            self().visit_var_sym(x.m_syms[i]);
        }
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        if (x.m_t_inside)
            self().visit_trivia(*x.m_t_inside);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Block(const Block_t &x) {
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
        }
        for (size_t i=0; i<x.n_import; i++) {
            self().visit_import_statement(*x.m_import[i]);
        }
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
        }
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        if (x.m_t_inside)
            self().visit_trivia(*x.m_t_inside);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_ChangeTeam(const ChangeTeam_t &x) {
        self().visit_expr(*x.m_team_value);
        for (size_t i=0; i<x.n_coarray_assoc; i++) {
            self().visit_team_attribute(*x.m_coarray_assoc[i]);
        }
        for (size_t i=0; i<x.n_sync; i++) {
            self().visit_event_attribute(*x.m_sync[i]);
        }
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        if (x.m_t_inside)
            self().visit_trivia(*x.m_t_inside);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
        for (size_t i=0; i<x.n_sync_stat; i++) {
            self().visit_event_attribute(*x.m_sync_stat[i]);
        }
    }
    void visit_Critical(const Critical_t &x) {
        for (size_t i=0; i<x.n_sync_stat; i++) {
            self().visit_event_attribute(*x.m_sync_stat[i]);
        }
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        if (x.m_t_inside)
            self().visit_trivia(*x.m_t_inside);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_DoConcurrentLoop(const DoConcurrentLoop_t &x) {
        for (size_t i=0; i<x.n_control; i++) {
            self().visit_concurrent_control(*x.m_control[i]);
        }
        if (x.m_mask)
            self().visit_expr(*x.m_mask);
        for (size_t i=0; i<x.n_locality; i++) {
            self().visit_concurrent_locality(*x.m_locality[i]);
        }
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        if (x.m_t_inside)
            self().visit_trivia(*x.m_t_inside);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_DoLoop(const DoLoop_t &x) {
        if (x.m_start)
            self().visit_expr(*x.m_start);
        if (x.m_end)
            self().visit_expr(*x.m_end);
        if (x.m_increment)
            self().visit_expr(*x.m_increment);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        if (x.m_t_inside)
            self().visit_trivia(*x.m_t_inside);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_ForAll(const ForAll_t &x) {
        for (size_t i=0; i<x.n_control; i++) {
            self().visit_concurrent_control(*x.m_control[i]);
        }
        if (x.m_mask)
            self().visit_expr(*x.m_mask);
        for (size_t i=0; i<x.n_locality; i++) {
            self().visit_concurrent_locality(*x.m_locality[i]);
        }
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        if (x.m_t_inside)
            self().visit_trivia(*x.m_t_inside);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_If(const If_t &x) {
        self().visit_expr(*x.m_test);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        for (size_t i=0; i<x.n_orelse; i++) {
            self().visit_stmt(*x.m_orelse[i]);
        }
        if (x.m_if_trivia)
            self().visit_trivia(*x.m_if_trivia);
        if (x.m_else_trivia)
            self().visit_trivia(*x.m_else_trivia);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_IfArithmetic(const IfArithmetic_t &x) {
        self().visit_expr(*x.m_test);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Select(const Select_t &x) {
        self().visit_expr(*x.m_test);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_case_stmt(*x.m_body[i]);
        }
        if (x.m_t_inside)
            self().visit_trivia(*x.m_t_inside);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_SelectRank(const SelectRank_t &x) {
        self().visit_expr(*x.m_selector);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_rank_stmt(*x.m_body[i]);
        }
        if (x.m_t_inside)
            self().visit_trivia(*x.m_t_inside);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_SelectType(const SelectType_t &x) {
        self().visit_expr(*x.m_selector);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_type_stmt(*x.m_body[i]);
        }
        if (x.m_t_inside)
            self().visit_trivia(*x.m_t_inside);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Where(const Where_t &x) {
        self().visit_expr(*x.m_test);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        for (size_t i=0; i<x.n_orelse; i++) {
            self().visit_stmt(*x.m_orelse[i]);
        }
        if (x.m_t_inside)
            self().visit_trivia(*x.m_t_inside);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_WhileLoop(const WhileLoop_t &x) {
        self().visit_expr(*x.m_test);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        if (x.m_t_inside)
            self().visit_trivia(*x.m_t_inside);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_BoolOp(const BoolOp_t &x) {
        self().visit_expr(*x.m_left);
        self().visit_expr(*x.m_right);
    }
    void visit_BinOp(const BinOp_t &x) {
        self().visit_expr(*x.m_left);
        self().visit_expr(*x.m_right);
    }
    void visit_DefBinOp(const DefBinOp_t &x) {
        self().visit_expr(*x.m_left);
        self().visit_expr(*x.m_right);
    }
    void visit_StrOp(const StrOp_t &x) {
        self().visit_expr(*x.m_left);
        self().visit_expr(*x.m_right);
    }
    void visit_UnaryOp(const UnaryOp_t &x) {
        self().visit_expr(*x.m_operand);
    }
    void visit_DefUnaryOp(const DefUnaryOp_t &x) {
        self().visit_expr(*x.m_operand);
    }
    void visit_Compare(const Compare_t &x) {
        self().visit_expr(*x.m_left);
        self().visit_expr(*x.m_right);
    }
    void visit_FuncCallOrArray(const FuncCallOrArray_t &x) {
        for (size_t i=0; i<x.n_member; i++) {
            self().visit_struct_member(x.m_member[i]);
        }
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_fnarg(x.m_args[i]);
        }
        for (size_t i=0; i<x.n_keywords; i++) {
            self().visit_keyword(x.m_keywords[i]);
        }
        for (size_t i=0; i<x.n_subargs; i++) {
            self().visit_fnarg(x.m_subargs[i]);
        }
    }
    void visit_CoarrayRef(const CoarrayRef_t &x) {
        for (size_t i=0; i<x.n_member; i++) {
            self().visit_struct_member(x.m_member[i]);
        }
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_fnarg(x.m_args[i]);
        }
        for (size_t i=0; i<x.n_fnkw; i++) {
            self().visit_keyword(x.m_fnkw[i]);
        }
        for (size_t i=0; i<x.n_coargs; i++) {
            self().visit_coarrayarg(x.m_coargs[i]);
        }
        for (size_t i=0; i<x.n_cokw; i++) {
            self().visit_keyword(x.m_cokw[i]);
        }
    }
    void visit_ArrayInitializer(const ArrayInitializer_t &x) {
        if (x.m_vartype)
            self().visit_decl_attribute(*x.m_vartype);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
    }
    void visit_ImpliedDoLoop(const ImpliedDoLoop_t &x) {
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
        }
        self().visit_expr(*x.m_start);
        self().visit_expr(*x.m_end);
        if (x.m_increment)
            self().visit_expr(*x.m_increment);
    }
    void visit_Num(const Num_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Real(const Real_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Complex(const Complex_t &x) {
        self().visit_expr(*x.m_re);
        self().visit_expr(*x.m_im);
    }
    void visit_String(const String_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Substring(const Substring_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_fnarg(x.m_args[i]);
        }
    }
    void visit_BOZ(const BOZ_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Name(const Name_t &x) {
        for (size_t i=0; i<x.n_member; i++) {
            self().visit_struct_member(x.m_member[i]);
        }
    }
    void visit_Logical(const Logical_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_DataImpliedDo(const DataImpliedDo_t &x) {
        for (size_t i=0; i<x.n_object_list; i++) {
            self().visit_expr(*x.m_object_list[i]);
        }
        if (x.m_type)
            self().visit_decl_attribute(*x.m_type);
        self().visit_expr(*x.m_start);
        self().visit_expr(*x.m_end);
        if (x.m_increment)
            self().visit_expr(*x.m_increment);
    }
    void visit_Parenthesis(const Parenthesis_t &x) {
        self().visit_expr(*x.m_operand);
    }
    void visit_TriviaNode(const TriviaNode_t &x) {
        for (size_t i=0; i<x.n_inside; i++) {
            self().visit_trivia_node(*x.m_inside[i]);
        }
        for (size_t i=0; i<x.n_after; i++) {
            self().visit_trivia_node(*x.m_after[i]);
        }
    }
    void visit_Comment(const Comment_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_EOLComment(const EOLComment_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_EndOfLine(const EndOfLine_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Semicolon(const Semicolon_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_DerivedTypeProc(const DerivedTypeProc_t &x) {
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
        }
        for (size_t i=0; i<x.n_symbols; i++) {
            self().visit_use_symbol(*x.m_symbols[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_GenericOperator(const GenericOperator_t &x) {
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_GenericDefinedOperator(const GenericDefinedOperator_t &x) {
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_GenericAssignment(const GenericAssignment_t &x) {
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_GenericName(const GenericName_t &x) {
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_GenericWrite(const GenericWrite_t &x) {
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_GenericRead(const GenericRead_t &x) {
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_FinalName(const FinalName_t &x) {
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_Private(const Private_t &x) {
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
    }
    void visit_AttrBind(const AttrBind_t &x) {
        self().visit_bind(*x.m_bind);
    }
    void visit_AttrData(const AttrData_t &x) {
        for (size_t i=0; i<x.n_object; i++) {
            self().visit_expr(*x.m_object[i]);
        }
        for (size_t i=0; i<x.n_value; i++) {
            self().visit_expr(*x.m_value[i]);
        }
    }
    void visit_AttrDimension(const AttrDimension_t &x) {
        for (size_t i=0; i<x.n_dim; i++) {
            self().visit_dimension(x.m_dim[i]);
        }
    }
    void visit_AttrCodimension(const AttrCodimension_t &x) {
        for (size_t i=0; i<x.n_codim; i++) {
            self().visit_codimension(x.m_codim[i]);
        }
    }
    void visit_AttrEquivalence(const AttrEquivalence_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_equi(x.m_args[i]);
        }
    }
    void visit_AttrExtends(const AttrExtends_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrIntent(const AttrIntent_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrNamelist(const AttrNamelist_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrPass(const AttrPass_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_SimpleAttribute(const SimpleAttribute_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrType(const AttrType_t &x) {
        for (size_t i=0; i<x.n_kind; i++) {
            self().visit_kind_item(x.m_kind[i]);
        }
    }
    void visit_AttrAssignment(const AttrAssignment_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrIntrinsicOperator(const AttrIntrinsicOperator_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrDefinedOperator(const AttrDefinedOperator_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrStat(const AttrStat_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrErrmsg(const AttrErrmsg_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrNewIndex(const AttrNewIndex_t &x) {
        self().visit_expr(*x.m_value);
    }
    void visit_AttrEventWaitKwArg(const AttrEventWaitKwArg_t &x) {
        self().visit_expr(*x.m_value);
    }
    void visit_CoarrayAssociation(const CoarrayAssociation_t &x) {
        self().visit_expr(*x.m_coarray);
        self().visit_expr(*x.m_selector);
    }
    void visit_var_sym(const var_sym_t &x) {
        for (size_t i=0; i<x.n_dim; i++) {
            self().visit_dimension(x.m_dim[i]);
        }
        for (size_t i=0; i<x.n_codim; i++) {
            self().visit_codimension(x.m_codim[i]);
        }
        if (x.m_initializer)
            self().visit_expr(*x.m_initializer);
        if (x.m_spec)
            self().visit_decl_attribute(*x.m_spec);
    }
    void visit_kind_item(const kind_item_t &x) {
        if (x.m_value)
            self().visit_expr(*x.m_value);
    }
    void visit_dimension(const dimension_t &x) {
        if (x.m_start)
            self().visit_expr(*x.m_start);
        if (x.m_end)
            self().visit_expr(*x.m_end);
    }
    void visit_codimension(const codimension_t &x) {
        if (x.m_start)
            self().visit_expr(*x.m_start);
        if (x.m_end)
            self().visit_expr(*x.m_end);
    }
    void visit_equi(const equi_t &x) {
        for (size_t i=0; i<x.n_set_list; i++) {
            self().visit_expr(*x.m_set_list[i]);
        }
    }
    void visit_kw_argstar(const kw_argstar_t &x) {
        if (x.m_value)
            self().visit_expr(*x.m_value);
    }
    void visit_argstar(const argstar_t &x) {
        if (x.m_value)
            self().visit_expr(*x.m_value);
    }
    void visit_arg(const arg_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_fnarg(const fnarg_t &x) {
        if (x.m_start)
            self().visit_expr(*x.m_start);
        if (x.m_end)
            self().visit_expr(*x.m_end);
        if (x.m_step)
            self().visit_expr(*x.m_step);
    }
    void visit_coarrayarg(const coarrayarg_t &x) {
        if (x.m_start)
            self().visit_expr(*x.m_start);
        if (x.m_end)
            self().visit_expr(*x.m_end);
        if (x.m_step)
            self().visit_expr(*x.m_step);
    }
    void visit_keyword(const keyword_t &x) {
        self().visit_expr(*x.m_value);
    }
    void visit_struct_member(const struct_member_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_fnarg(x.m_args[i]);
        }
    }
    void visit_Bind(const Bind_t &x) {
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
        }
    }
    void visit_ArrayIndex(const ArrayIndex_t &x) {
        if (x.m_left)
            self().visit_expr(*x.m_left);
        if (x.m_right)
            self().visit_expr(*x.m_right);
        if (x.m_step)
            self().visit_expr(*x.m_step);
    }
    void visit_CaseStmt(const CaseStmt_t &x) {
        for (size_t i=0; i<x.n_test; i++) {
            self().visit_case_cond(*x.m_test[i]);
        }
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_CaseStmt_Default(const CaseStmt_Default_t &x) {
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_CaseCondExpr(const CaseCondExpr_t &x) {
        self().visit_expr(*x.m_cond);
    }
    void visit_CaseCondRange(const CaseCondRange_t &x) {
        if (x.m_start)
            self().visit_expr(*x.m_start);
        if (x.m_end)
            self().visit_expr(*x.m_end);
    }
    void visit_RankExpr(const RankExpr_t &x) {
        self().visit_expr(*x.m_value);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_RankStar(const RankStar_t &x) {
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_RankDefault(const RankDefault_t &x) {
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_TypeStmtName(const TypeStmtName_t &x) {
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_TypeStmtType(const TypeStmtType_t &x) {
        if (x.m_vartype)
            self().visit_decl_attribute(*x.m_vartype);
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_ClassStmt(const ClassStmt_t &x) {
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_ClassDefault(const ClassDefault_t &x) {
        if (x.m_trivia)
            self().visit_trivia(*x.m_trivia);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_UseSymbol(const UseSymbol_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_UseAssignment(const UseAssignment_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_IntrinsicOperator(const IntrinsicOperator_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_DefinedOperator(const DefinedOperator_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_RenameOperator(const RenameOperator_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_UseWrite(const UseWrite_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_UseRead(const UseRead_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ConcurrentControl(const ConcurrentControl_t &x) {
        if (x.m_start)
            self().visit_expr(*x.m_start);
        if (x.m_end)
            self().visit_expr(*x.m_end);
        if (x.m_increment)
            self().visit_expr(*x.m_increment);
    }
    void visit_ConcurrentLocal(const ConcurrentLocal_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ConcurrentLocalInit(const ConcurrentLocalInit_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ConcurrentShared(const ConcurrentShared_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ConcurrentDefault(const ConcurrentDefault_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ConcurrentReduce(const ConcurrentReduce_t &x) {
        if ((bool&)x) { } // Suppress unused warning
    }
};


/******************************************************************************/
// Pickle Visitor base class

template <class Derived>
class PickleBaseVisitor : public BaseVisitor<Derived>
{
private:
    Derived& self() { return static_cast<Derived&>(*this); }
public:
    std::string s, indtd;
    bool use_colors;
    bool indent, start_line = true;
    int indent_level = 0, indent_spaces = 3, lvl = 0;
    int tmp = 0, tmp1 = 0, tmp2 = 2;
    int curly[2000], round[2000];
public:
    PickleBaseVisitor() : use_colors(false), indent(false) { s.reserve(100000); }
    void inc_indent() {
        indent_level++;
        indtd = std::string(indent_level*indent_spaces, ' ');
    }
    void dec_indent() {
        indent_level--;
        LFORTRAN_ASSERT(indent_level >= 0);
        indtd = std::string(indent_level*indent_spaces, ' ');
    }
    void visit_TranslationUnit(const TranslationUnit_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("TranslationUnit");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append("[");
        for (size_t i=0; i<x.n_items; i++) {
            self().visit_ast(*x.m_items[i]);
            if (i < x.n_items-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Module(const Module_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Module");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
            if (i < x.n_use-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_implicit; i++) {
            self().visit_implicit_statement(*x.m_implicit[i]);
            if (i < x.n_implicit-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
            if (i < x.n_decl-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_contains; i++) {
            self().visit_program_unit(*x.m_contains[i]);
            if (i < x.n_contains-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Submodule(const Submodule_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Submodule");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_id);
        s.append(" ");
        if (x.m_parent_name) {
            s.append(x.m_parent_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
            if (i < x.n_use-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_implicit; i++) {
            self().visit_implicit_statement(*x.m_implicit[i]);
            if (i < x.n_implicit-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
            if (i < x.n_decl-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_contains; i++) {
            self().visit_program_unit(*x.m_contains[i]);
            if (i < x.n_contains-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_BlockData(const BlockData_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("BlockData");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_name) {
            s.append(x.m_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
            if (i < x.n_use-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_implicit; i++) {
            self().visit_implicit_statement(*x.m_implicit[i]);
            if (i < x.n_implicit-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
            if (i < x.n_decl-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Program(const Program_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Program");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
            if (i < x.n_use-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_implicit; i++) {
            self().visit_implicit_statement(*x.m_implicit[i]);
            if (i < x.n_implicit-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
            if (i < x.n_decl-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_contains; i++) {
            self().visit_program_unit(*x.m_contains[i]);
            if (i < x.n_contains-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Subroutine(const Subroutine_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Subroutine");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_arg(x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_attributes; i++) {
            self().visit_decl_attribute(*x.m_attributes[i]);
            if (i < x.n_attributes-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_bind) {
            self().visit_bind(*x.m_bind);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
            if (i < x.n_use-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_import; i++) {
            self().visit_import_statement(*x.m_import[i]);
            if (i < x.n_import-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_implicit; i++) {
            self().visit_implicit_statement(*x.m_implicit[i]);
            if (i < x.n_implicit-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
            if (i < x.n_decl-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_contains; i++) {
            self().visit_program_unit(*x.m_contains[i]);
            if (i < x.n_contains-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Procedure(const Procedure_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Procedure");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_arg(x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_attributes; i++) {
            self().visit_decl_attribute(*x.m_attributes[i]);
            if (i < x.n_attributes-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
            if (i < x.n_use-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_import; i++) {
            self().visit_import_statement(*x.m_import[i]);
            if (i < x.n_import-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_implicit; i++) {
            self().visit_implicit_statement(*x.m_implicit[i]);
            if (i < x.n_implicit-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
            if (i < x.n_decl-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_contains; i++) {
            self().visit_program_unit(*x.m_contains[i]);
            if (i < x.n_contains-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Function(const Function_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Function");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_arg(x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_attributes; i++) {
            self().visit_decl_attribute(*x.m_attributes[i]);
            if (i < x.n_attributes-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_return_var) {
            self().visit_expr(*x.m_return_var);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_bind) {
            self().visit_bind(*x.m_bind);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
            if (i < x.n_use-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_import; i++) {
            self().visit_import_statement(*x.m_import[i]);
            if (i < x.n_import-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_implicit; i++) {
            self().visit_implicit_statement(*x.m_implicit[i]);
            if (i < x.n_implicit-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
            if (i < x.n_decl-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_contains; i++) {
            self().visit_program_unit(*x.m_contains[i]);
            if (i < x.n_contains-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Use(const Use_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Use");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_nature; i++) {
            self().visit_decl_attribute(*x.m_nature[i]);
            if (i < x.n_nature-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_module);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_symbols; i++) {
            self().visit_use_symbol(*x.m_symbols[i]);
            if (i < x.n_symbols-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_only_present) {
            s.append(".true.");
        } else {
            s.append(".false.");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Declaration(const Declaration_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Declaration");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_vartype) {
            self().visit_decl_attribute(*x.m_vartype);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_attributes; i++) {
            self().visit_decl_attribute(*x.m_attributes[i]);
            if (i < x.n_attributes-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_syms; i++) {
            self().visit_var_sym(x.m_syms[i]);
            if (i < x.n_syms-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Interface(const Interface_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Interface");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_interface_header(*x.m_header);
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_items; i++) {
            self().visit_interface_item(*x.m_items[i]);
            if (i < x.n_items-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_DerivedType(const DerivedType_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("DerivedType");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_namelist; i++) {
            s.append(x.m_namelist[i]);
            if (i < x.n_namelist-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_attrtype; i++) {
            self().visit_decl_attribute(*x.m_attrtype[i]);
            if (i < x.n_attrtype-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_items; i++) {
            self().visit_unit_decl2(*x.m_items[i]);
            if (i < x.n_items-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_contains; i++) {
            self().visit_procedure_decl(*x.m_contains[i]);
            if (i < x.n_contains-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Enum(const Enum_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Enum");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
            if (i < x.n_attr-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_items; i++) {
            self().visit_unit_decl2(*x.m_items[i]);
            if (i < x.n_items-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_InterfaceHeader(const InterfaceHeader_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("InterfaceHeader");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_InterfaceHeaderName(const InterfaceHeaderName_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("InterfaceHeaderName");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_InterfaceHeaderAssignment(const InterfaceHeaderAssignment_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("InterfaceHeaderAssignment");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_InterfaceHeaderOperator(const InterfaceHeaderOperator_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("InterfaceHeaderOperator");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        visit_intrinsicopType(x.m_op);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_InterfaceHeaderDefinedOperator(const InterfaceHeaderDefinedOperator_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("InterfaceHeaderDefinedOperator");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("\"" + std::string(x.m_operator_name) + "\"");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AbstractInterfaceHeader(const AbstractInterfaceHeader_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("AbstractInterfaceHeader");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_InterfaceHeaderWrite(const InterfaceHeaderWrite_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("InterfaceHeaderWrite");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_id);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_InterfaceHeaderRead(const InterfaceHeaderRead_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("InterfaceHeaderRead");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_id);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_InterfaceProc(const InterfaceProc_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("InterfaceProc");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_program_unit(*x.m_proc);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_InterfaceModuleProcedure(const InterfaceModuleProcedure_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("InterfaceModuleProcedure");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_names; i++) {
            s.append(x.m_names[i]);
            if (i < x.n_names-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_attributes; i++) {
            self().visit_decl_attribute(*x.m_attributes[i]);
            if (i < x.n_attributes-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Import(const Import_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Import");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_symbols; i++) {
            s.append(x.m_symbols[i]);
            if (i < x.n_symbols-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        visit_import_modifierType(x.m_mod);
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_import_modifierType(const import_modifierType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (import_modifierType::ImportDefault) : {
                if(indent) s.append("\n"+indtd);
                s.append("ImportDefault");
             break; }
            case (import_modifierType::ImportOnly) : {
                if(indent) s.append("\n"+indtd);
                s.append("ImportOnly");
             break; }
            case (import_modifierType::ImportNone) : {
                if(indent) s.append("\n"+indtd);
                s.append("ImportNone");
             break; }
            case (import_modifierType::ImportAll) : {
                if(indent) s.append("\n"+indtd);
                s.append("ImportAll");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_ImplicitNone(const ImplicitNone_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ImplicitNone");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_specs; i++) {
            self().visit_implicit_none_spec(*x.m_specs[i]);
            if (i < x.n_specs-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Implicit(const Implicit_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Implicit");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_decl_attribute(*x.m_type);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_kind; i++) {
            self().visit_letter_spec(*x.m_kind[i]);
            if (i < x.n_kind-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_specs; i++) {
            self().visit_letter_spec(*x.m_specs[i]);
            if (i < x.n_specs-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ImplicitNoneExternal(const ImplicitNoneExternal_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ImplicitNoneExternal");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_dummy));
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ImplicitNoneType(const ImplicitNoneType_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ImplicitNoneType");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_LetterSpec(const LetterSpec_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("LetterSpec");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_start) {
            s.append(x.m_start);
        } else {
            s.append("()");
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_end);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Allocate(const Allocate_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Allocate");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_fnarg(x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_keywords; i++) {
            self().visit_keyword(x.m_keywords[i]);
            if (i < x.n_keywords-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Assign(const Assign_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Assign");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        s.append(std::to_string(x.m_assign_label));
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_variable);
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Assignment(const Assignment_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("=");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        self().visit_expr(*x.m_target);
        s.append(" ");
        self().visit_expr(*x.m_value);
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Associate(const Associate_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("=>");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        self().visit_expr(*x.m_target);
        s.append(" ");
        self().visit_expr(*x.m_value);
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Backspace(const Backspace_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Backspace");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
            if (i < x.n_kwargs-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Close(const Close_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Close");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
            if (i < x.n_kwargs-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Continue(const Continue_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Continue");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Cycle(const Cycle_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Cycle");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_stmt_name) {
            s.append(x.m_stmt_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Deallocate(const Deallocate_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Deallocate");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_fnarg(x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_keywords; i++) {
            self().visit_keyword(x.m_keywords[i]);
            if (i < x.n_keywords-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Endfile(const Endfile_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Endfile");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
            if (i < x.n_kwargs-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Entry(const Entry_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Entry");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_arg(x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_return_var) {
            self().visit_expr(*x.m_return_var);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_bind) {
            self().visit_bind(*x.m_bind);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ErrorStop(const ErrorStop_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ErrorStop");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_code) {
            self().visit_expr(*x.m_code);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_quiet) {
            self().visit_expr(*x.m_quiet);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_EventPost(const EventPost_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("EventPost");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        self().visit_expr(*x.m_variable);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_stat; i++) {
            self().visit_event_attribute(*x.m_stat[i]);
            if (i < x.n_stat-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_EventWait(const EventWait_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("EventWait");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        self().visit_expr(*x.m_variable);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_spec; i++) {
            self().visit_event_attribute(*x.m_spec[i]);
            if (i < x.n_spec-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Exit(const Exit_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Exit");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_stmt_name) {
            s.append(x.m_stmt_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Flush(const Flush_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Flush");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
            if (i < x.n_kwargs-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ForAllSingle(const ForAllSingle_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ForAllSingle");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_stmt_name) {
            s.append(x.m_stmt_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_control; i++) {
            self().visit_concurrent_control(*x.m_control[i]);
            if (i < x.n_control-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_mask) {
            self().visit_expr(*x.m_mask);
        } else {
            s.append("()");
        }
        s.append(" ");
        self().visit_stmt(*x.m_assign);
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Format(const Format_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Format");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        s.append("\"" + std::string(x.m_fmt) + "\"");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_FormTeam(const FormTeam_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("FormTeam");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        self().visit_expr(*x.m_team_number);
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_team_var);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_sync_stat; i++) {
            self().visit_event_attribute(*x.m_sync_stat[i]);
            if (i < x.n_sync_stat-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_GoTo(const GoTo_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("GoTo");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_int_var) {
            s.append(x.m_int_var);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_goto_label) {
            self().visit_expr(*x.m_goto_label);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_labels; i++) {
            self().visit_expr(*x.m_labels[i]);
            if (i < x.n_labels-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Inquire(const Inquire_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Inquire");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
            if (i < x.n_kwargs-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
            if (i < x.n_values-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Nullify(const Nullify_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Nullify");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
            if (i < x.n_kwargs-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Open(const Open_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Open");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
            if (i < x.n_kwargs-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Return(const Return_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Return");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_value) {
            self().visit_expr(*x.m_value);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Print(const Print_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Print");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_fmt) {
            self().visit_expr(*x.m_fmt);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
            if (i < x.n_values-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Read(const Read_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Read");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_format) {
            self().visit_expr(*x.m_format);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_argstar(x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_kw_argstar(x.m_kwargs[i]);
            if (i < x.n_kwargs-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
            if (i < x.n_values-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Rewind(const Rewind_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Rewind");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
            if (i < x.n_kwargs-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Stop(const Stop_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Stop");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_code) {
            self().visit_expr(*x.m_code);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_quiet) {
            self().visit_expr(*x.m_quiet);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_SubroutineCall(const SubroutineCall_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("SubroutineCall");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_member; i++) {
            self().visit_struct_member(x.m_member[i]);
            if (i < x.n_member-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_fnarg(x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_keywords; i++) {
            self().visit_keyword(x.m_keywords[i]);
            if (i < x.n_keywords-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_SyncAll(const SyncAll_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("SyncAll");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_stat; i++) {
            self().visit_event_attribute(*x.m_stat[i]);
            if (i < x.n_stat-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_SyncImages(const SyncImages_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("SyncImages");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_image_set) {
            self().visit_expr(*x.m_image_set);
        } else {
            s.append("()");
        }
        s.append(" ");
        visit_symbolType(x.m_sym);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_stat; i++) {
            self().visit_event_attribute(*x.m_stat[i]);
            if (i < x.n_stat-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_SyncMemory(const SyncMemory_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("SyncMemory");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_stat; i++) {
            self().visit_event_attribute(*x.m_stat[i]);
            if (i < x.n_stat-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_SyncTeam(const SyncTeam_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("SyncTeam");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        self().visit_expr(*x.m_value);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_stat; i++) {
            self().visit_event_attribute(*x.m_stat[i]);
            if (i < x.n_stat-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Write(const Write_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Write");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_argstar(x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_kw_argstar(x.m_kwargs[i]);
            if (i < x.n_kwargs-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
            if (i < x.n_values-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_AssociateBlock(const AssociateBlock_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("AssociateBlock");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_stmt_name) {
            s.append(x.m_stmt_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_syms; i++) {
            self().visit_var_sym(x.m_syms[i]);
            if (i < x.n_syms-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_t_inside) {
            self().visit_trivia(*x.m_t_inside);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Block(const Block_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Block");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_stmt_name) {
            s.append(x.m_stmt_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
            if (i < x.n_use-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_import; i++) {
            self().visit_import_statement(*x.m_import[i]);
            if (i < x.n_import-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
            if (i < x.n_decl-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_t_inside) {
            self().visit_trivia(*x.m_t_inside);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ChangeTeam(const ChangeTeam_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ChangeTeam");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_stmt_name) {
            s.append(x.m_stmt_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        self().visit_expr(*x.m_team_value);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_coarray_assoc; i++) {
            self().visit_team_attribute(*x.m_coarray_assoc[i]);
            if (i < x.n_coarray_assoc-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_sync; i++) {
            self().visit_event_attribute(*x.m_sync[i]);
            if (i < x.n_sync-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_t_inside) {
            self().visit_trivia(*x.m_t_inside);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_sync_stat; i++) {
            self().visit_event_attribute(*x.m_sync_stat[i]);
            if (i < x.n_sync_stat-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Critical(const Critical_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Critical");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_stmt_name) {
            s.append(x.m_stmt_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_sync_stat; i++) {
            self().visit_event_attribute(*x.m_sync_stat[i]);
            if (i < x.n_sync_stat-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_t_inside) {
            self().visit_trivia(*x.m_t_inside);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_DoConcurrentLoop(const DoConcurrentLoop_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("DoConcurrentLoop");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_stmt_name) {
            s.append(x.m_stmt_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_control; i++) {
            self().visit_concurrent_control(*x.m_control[i]);
            if (i < x.n_control-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_mask) {
            self().visit_expr(*x.m_mask);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_locality; i++) {
            self().visit_concurrent_locality(*x.m_locality[i]);
            if (i < x.n_locality-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_t_inside) {
            self().visit_trivia(*x.m_t_inside);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_DoLoop(const DoLoop_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("DoLoop");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_stmt_name) {
            s.append(x.m_stmt_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append(std::to_string(x.m_do_label));
        s.append(" ");
        if (x.m_var) {
            s.append(x.m_var);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_start) {
            self().visit_expr(*x.m_start);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_end) {
            self().visit_expr(*x.m_end);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_increment) {
            self().visit_expr(*x.m_increment);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_t_inside) {
            self().visit_trivia(*x.m_t_inside);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ForAll(const ForAll_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ForAll");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_stmt_name) {
            s.append(x.m_stmt_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_control; i++) {
            self().visit_concurrent_control(*x.m_control[i]);
            if (i < x.n_control-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_mask) {
            self().visit_expr(*x.m_mask);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_locality; i++) {
            self().visit_concurrent_locality(*x.m_locality[i]);
            if (i < x.n_locality-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_t_inside) {
            self().visit_trivia(*x.m_t_inside);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_If(const If_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("If");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_stmt_name) {
            s.append(x.m_stmt_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        self().visit_expr(*x.m_test);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_orelse; i++) {
            self().visit_stmt(*x.m_orelse[i]);
            if (i < x.n_orelse-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_if_trivia) {
            self().visit_trivia(*x.m_if_trivia);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_else_trivia) {
            self().visit_trivia(*x.m_else_trivia);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_IfArithmetic(const IfArithmetic_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("IfArithmetic");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_stmt_name) {
            s.append(x.m_stmt_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        self().visit_expr(*x.m_test);
        s.append(" ");
        s.append(std::to_string(x.m_lt_label));
        s.append(" ");
        s.append(std::to_string(x.m_eq_label));
        s.append(" ");
        s.append(std::to_string(x.m_gt_label));
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Select(const Select_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Select");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_stmt_name) {
            s.append(x.m_stmt_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        self().visit_expr(*x.m_test);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_case_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_t_inside) {
            self().visit_trivia(*x.m_t_inside);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_SelectRank(const SelectRank_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("SelectRank");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_stmt_name) {
            s.append(x.m_stmt_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_assoc_name) {
            s.append(x.m_assoc_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        self().visit_expr(*x.m_selector);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_rank_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_t_inside) {
            self().visit_trivia(*x.m_t_inside);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_SelectType(const SelectType_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("SelectType");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_stmt_name) {
            s.append(x.m_stmt_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_assoc_name) {
            s.append(x.m_assoc_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        self().visit_expr(*x.m_selector);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_type_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_t_inside) {
            self().visit_trivia(*x.m_t_inside);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Where(const Where_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Where");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_stmt_name) {
            s.append(x.m_stmt_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        self().visit_expr(*x.m_test);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_orelse; i++) {
            self().visit_stmt(*x.m_orelse[i]);
            if (i < x.n_orelse-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_t_inside) {
            self().visit_trivia(*x.m_t_inside);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_WhileLoop(const WhileLoop_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("WhileLoop");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_label));
        s.append(" ");
        if (x.m_stmt_name) {
            s.append(x.m_stmt_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        self().visit_expr(*x.m_test);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_t_inside) {
            self().visit_trivia(*x.m_t_inside);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_BoolOp(const BoolOp_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("BoolOp");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_left);
        s.append(" ");
        visit_boolopType(x.m_op);
        s.append(" ");
        self().visit_expr(*x.m_right);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_BinOp(const BinOp_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("BinOp");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_left);
        s.append(" ");
        visit_operatorType(x.m_op);
        s.append(" ");
        self().visit_expr(*x.m_right);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_DefBinOp(const DefBinOp_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("DefBinOp");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_left);
        s.append(" ");
        s.append("\"" + std::string(x.m_op) + "\"");
        s.append(" ");
        self().visit_expr(*x.m_right);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_StrOp(const StrOp_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("StrOp");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_left);
        s.append(" ");
        visit_stroperatorType(x.m_op);
        s.append(" ");
        self().visit_expr(*x.m_right);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_UnaryOp(const UnaryOp_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("UnaryOp");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        visit_unaryopType(x.m_op);
        s.append(" ");
        self().visit_expr(*x.m_operand);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_DefUnaryOp(const DefUnaryOp_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("DefUnaryOp");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("\"" + std::string(x.m_op) + "\"");
        s.append(" ");
        self().visit_expr(*x.m_operand);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Compare(const Compare_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Compare");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_left);
        s.append(" ");
        visit_cmpopType(x.m_op);
        s.append(" ");
        self().visit_expr(*x.m_right);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_FuncCallOrArray(const FuncCallOrArray_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("FuncCallOrArray");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_func);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_member; i++) {
            self().visit_struct_member(x.m_member[i]);
            if (i < x.n_member-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_fnarg(x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_keywords; i++) {
            self().visit_keyword(x.m_keywords[i]);
            if (i < x.n_keywords-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_subargs; i++) {
            self().visit_fnarg(x.m_subargs[i]);
            if (i < x.n_subargs-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_CoarrayRef(const CoarrayRef_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("CoarrayRef");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_member; i++) {
            self().visit_struct_member(x.m_member[i]);
            if (i < x.n_member-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_fnarg(x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_fnkw; i++) {
            self().visit_keyword(x.m_fnkw[i]);
            if (i < x.n_fnkw-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_coargs; i++) {
            self().visit_coarrayarg(x.m_coargs[i]);
            if (i < x.n_coargs-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_cokw; i++) {
            self().visit_keyword(x.m_cokw[i]);
            if (i < x.n_cokw-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ArrayInitializer(const ArrayInitializer_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ArrayInitializer");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_vartype) {
            self().visit_decl_attribute(*x.m_vartype);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_classtype) {
            s.append(x.m_classtype);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ImpliedDoLoop(const ImpliedDoLoop_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ImpliedDoLoop");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
            if (i < x.n_values-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_var);
        s.append(" ");
        self().visit_expr(*x.m_start);
        s.append(" ");
        self().visit_expr(*x.m_end);
        s.append(" ");
        if (x.m_increment) {
            self().visit_expr(*x.m_increment);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Num(const Num_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Num");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append(std::to_string(x.m_n));
        s.append(" ");
        if (x.m_kind) {
            s.append("\"" + std::string(x.m_kind) + "\"");
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Real(const Real_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Real");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("\"" + std::string(x.m_n) + "\"");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Complex(const Complex_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Complex");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_re);
        s.append(" ");
        self().visit_expr(*x.m_im);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_String(const String_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("String");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("\"" + std::string(x.m_s) + "\"");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Substring(const Substring_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Substring");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("\"" + std::string(x.m_s) + "\"");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_fnarg(x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_BOZ(const BOZ_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("BOZ");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("\"" + std::string(x.m_s) + "\"");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Name(const Name_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Name");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_id);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_member; i++) {
            self().visit_struct_member(x.m_member[i]);
            if (i < x.n_member-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Logical(const Logical_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Logical");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_value) {
            s.append(".true.");
        } else {
            s.append(".false.");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_DataImpliedDo(const DataImpliedDo_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("DataImpliedDo");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_object_list; i++) {
            self().visit_expr(*x.m_object_list[i]);
            if (i < x.n_object_list-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_type) {
            self().visit_decl_attribute(*x.m_type);
        } else {
            s.append("()");
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_var);
        s.append(" ");
        self().visit_expr(*x.m_start);
        s.append(" ");
        self().visit_expr(*x.m_end);
        s.append(" ");
        if (x.m_increment) {
            self().visit_expr(*x.m_increment);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Parenthesis(const Parenthesis_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Parenthesis");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_operand);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_TriviaNode(const TriviaNode_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("TriviaNode");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_inside; i++) {
            self().visit_trivia_node(*x.m_inside[i]);
            if (i < x.n_inside-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_after; i++) {
            self().visit_trivia_node(*x.m_after[i]);
            if (i < x.n_after-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Comment(const Comment_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Comment");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("\"" + std::string(x.m_comment) + "\"");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_EOLComment(const EOLComment_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("EOLComment");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("\"" + std::string(x.m_comment) + "\"");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_EndOfLine(const EndOfLine_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("EndOfLine");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Semicolon(const Semicolon_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Semicolon");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_boolopType(const boolopType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (boolopType::And) : {
                if(indent) s.append("\n"+indtd);
                s.append("And");
             break; }
            case (boolopType::Or) : {
                if(indent) s.append("\n"+indtd);
                s.append("Or");
             break; }
            case (boolopType::Xor) : {
                if(indent) s.append("\n"+indtd);
                s.append("Xor");
             break; }
            case (boolopType::Eqv) : {
                if(indent) s.append("\n"+indtd);
                s.append("Eqv");
             break; }
            case (boolopType::NEqv) : {
                if(indent) s.append("\n"+indtd);
                s.append("NEqv");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_operatorType(const operatorType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (operatorType::Add) : {
                if(indent) s.append("\n"+indtd);
                s.append("Add");
             break; }
            case (operatorType::Sub) : {
                if(indent) s.append("\n"+indtd);
                s.append("Sub");
             break; }
            case (operatorType::Mul) : {
                if(indent) s.append("\n"+indtd);
                s.append("Mul");
             break; }
            case (operatorType::Div) : {
                if(indent) s.append("\n"+indtd);
                s.append("Div");
             break; }
            case (operatorType::Pow) : {
                if(indent) s.append("\n"+indtd);
                s.append("Pow");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_stroperatorType(const stroperatorType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (stroperatorType::Concat) : {
                if(indent) s.append("\n"+indtd);
                s.append("Concat");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_unaryopType(const unaryopType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (unaryopType::Invert) : {
                if(indent) s.append("\n"+indtd);
                s.append("Invert");
             break; }
            case (unaryopType::Not) : {
                if(indent) s.append("\n"+indtd);
                s.append("Not");
             break; }
            case (unaryopType::UAdd) : {
                if(indent) s.append("\n"+indtd);
                s.append("UAdd");
             break; }
            case (unaryopType::USub) : {
                if(indent) s.append("\n"+indtd);
                s.append("USub");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_cmpopType(const cmpopType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (cmpopType::Eq) : {
                if(indent) s.append("\n"+indtd);
                s.append("Eq");
             break; }
            case (cmpopType::NotEq) : {
                if(indent) s.append("\n"+indtd);
                s.append("NotEq");
             break; }
            case (cmpopType::Lt) : {
                if(indent) s.append("\n"+indtd);
                s.append("Lt");
             break; }
            case (cmpopType::LtE) : {
                if(indent) s.append("\n"+indtd);
                s.append("LtE");
             break; }
            case (cmpopType::Gt) : {
                if(indent) s.append("\n"+indtd);
                s.append("Gt");
             break; }
            case (cmpopType::GtE) : {
                if(indent) s.append("\n"+indtd);
                s.append("GtE");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_intrinsicopType(const intrinsicopType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (intrinsicopType::AND) : {
                if(indent) s.append("\n"+indtd);
                s.append("AND");
             break; }
            case (intrinsicopType::OR) : {
                if(indent) s.append("\n"+indtd);
                s.append("OR");
             break; }
            case (intrinsicopType::XOR) : {
                if(indent) s.append("\n"+indtd);
                s.append("XOR");
             break; }
            case (intrinsicopType::EQV) : {
                if(indent) s.append("\n"+indtd);
                s.append("EQV");
             break; }
            case (intrinsicopType::NEQV) : {
                if(indent) s.append("\n"+indtd);
                s.append("NEQV");
             break; }
            case (intrinsicopType::PLUS) : {
                if(indent) s.append("\n"+indtd);
                s.append("PLUS");
             break; }
            case (intrinsicopType::MINUS) : {
                if(indent) s.append("\n"+indtd);
                s.append("MINUS");
             break; }
            case (intrinsicopType::STAR) : {
                if(indent) s.append("\n"+indtd);
                s.append("STAR");
             break; }
            case (intrinsicopType::DIV) : {
                if(indent) s.append("\n"+indtd);
                s.append("DIV");
             break; }
            case (intrinsicopType::POW) : {
                if(indent) s.append("\n"+indtd);
                s.append("POW");
             break; }
            case (intrinsicopType::NOT) : {
                if(indent) s.append("\n"+indtd);
                s.append("NOT");
             break; }
            case (intrinsicopType::EQ) : {
                if(indent) s.append("\n"+indtd);
                s.append("EQ");
             break; }
            case (intrinsicopType::NOTEQ) : {
                if(indent) s.append("\n"+indtd);
                s.append("NOTEQ");
             break; }
            case (intrinsicopType::LT) : {
                if(indent) s.append("\n"+indtd);
                s.append("LT");
             break; }
            case (intrinsicopType::LTE) : {
                if(indent) s.append("\n"+indtd);
                s.append("LTE");
             break; }
            case (intrinsicopType::GT) : {
                if(indent) s.append("\n"+indtd);
                s.append("GT");
             break; }
            case (intrinsicopType::GTE) : {
                if(indent) s.append("\n"+indtd);
                s.append("GTE");
             break; }
            case (intrinsicopType::CONCAT) : {
                if(indent) s.append("\n"+indtd);
                s.append("CONCAT");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_DerivedTypeProc(const DerivedTypeProc_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("DerivedTypeProc");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_name) {
            s.append(x.m_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
            if (i < x.n_attr-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_symbols; i++) {
            self().visit_use_symbol(*x.m_symbols[i]);
            if (i < x.n_symbols-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_GenericOperator(const GenericOperator_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("GenericOperator");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
            if (i < x.n_attr-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        visit_intrinsicopType(x.m_op);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_names; i++) {
            s.append(x.m_names[i]);
            if (i < x.n_names-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_GenericDefinedOperator(const GenericDefinedOperator_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("GenericDefinedOperator");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
            if (i < x.n_attr-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("\"" + std::string(x.m_optype) + "\"");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_names; i++) {
            s.append(x.m_names[i]);
            if (i < x.n_names-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_GenericAssignment(const GenericAssignment_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("GenericAssignment");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
            if (i < x.n_attr-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_names; i++) {
            s.append(x.m_names[i]);
            if (i < x.n_names-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_GenericName(const GenericName_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("GenericName");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
            if (i < x.n_attr-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_names; i++) {
            s.append(x.m_names[i]);
            if (i < x.n_names-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_GenericWrite(const GenericWrite_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("GenericWrite");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
            if (i < x.n_attr-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_id);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_names; i++) {
            s.append(x.m_names[i]);
            if (i < x.n_names-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_GenericRead(const GenericRead_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("GenericRead");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
            if (i < x.n_attr-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_id);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_names; i++) {
            s.append(x.m_names[i]);
            if (i < x.n_names-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_FinalName(const FinalName_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("FinalName");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Private(const Private_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Private");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_AttrBind(const AttrBind_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("AttrBind");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_bind(*x.m_bind);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_AttrData(const AttrData_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("AttrData");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_object; i++) {
            self().visit_expr(*x.m_object[i]);
            if (i < x.n_object-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_value; i++) {
            self().visit_expr(*x.m_value[i]);
            if (i < x.n_value-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_AttrDimension(const AttrDimension_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("AttrDimension");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_dim; i++) {
            self().visit_dimension(x.m_dim[i]);
            if (i < x.n_dim-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_AttrCodimension(const AttrCodimension_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("AttrCodimension");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_codim; i++) {
            self().visit_codimension(x.m_codim[i]);
            if (i < x.n_codim-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_AttrEquivalence(const AttrEquivalence_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("AttrEquivalence");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_equi(x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_AttrExtends(const AttrExtends_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("AttrExtends");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrIntent(const AttrIntent_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("AttrIntent");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        visit_attr_intentType(x.m_intent);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrNamelist(const AttrNamelist_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("AttrNamelist");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrPass(const AttrPass_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("AttrPass");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_name) {
            s.append(x.m_name);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_SimpleAttribute(const SimpleAttribute_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("SimpleAttribute");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        visit_simple_attributeType(x.m_attr);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrType(const AttrType_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("AttrType");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        visit_decl_typeType(x.m_type);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_kind; i++) {
            self().visit_kind_item(x.m_kind[i]);
            if (i < x.n_kind-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_name) {
            s.append(x.m_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        visit_symbolType(x.m_sym);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_AttrAssignment(const AttrAssignment_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("AttrAssignment");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrIntrinsicOperator(const AttrIntrinsicOperator_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("AttrIntrinsicOperator");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        visit_intrinsicopType(x.m_op);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrDefinedOperator(const AttrDefinedOperator_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("AttrDefinedOperator");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("\"" + std::string(x.m_op_name) + "\"");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_simple_attributeType(const simple_attributeType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (simple_attributeType::AttrAbstract) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrAbstract");
             break; }
            case (simple_attributeType::AttrAllocatable) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrAllocatable");
             break; }
            case (simple_attributeType::AttrAsynchronous) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrAsynchronous");
             break; }
            case (simple_attributeType::AttrCommon) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrCommon");
             break; }
            case (simple_attributeType::AttrContiguous) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrContiguous");
             break; }
            case (simple_attributeType::AttrDeferred) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrDeferred");
             break; }
            case (simple_attributeType::AttrElemental) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrElemental");
             break; }
            case (simple_attributeType::AttrEnumerator) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrEnumerator");
             break; }
            case (simple_attributeType::AttrExternal) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrExternal");
             break; }
            case (simple_attributeType::AttrImpure) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrImpure");
             break; }
            case (simple_attributeType::AttrIntrinsic) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrIntrinsic");
             break; }
            case (simple_attributeType::AttrKind) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrKind");
             break; }
            case (simple_attributeType::AttrLen) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrLen");
             break; }
            case (simple_attributeType::AttrModule) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrModule");
             break; }
            case (simple_attributeType::AttrNoPass) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrNoPass");
             break; }
            case (simple_attributeType::AttrNonDeferred) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrNonDeferred");
             break; }
            case (simple_attributeType::AttrNon_Intrinsic) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrNon_Intrinsic");
             break; }
            case (simple_attributeType::AttrOptional) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrOptional");
             break; }
            case (simple_attributeType::AttrParameter) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrParameter");
             break; }
            case (simple_attributeType::AttrPointer) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrPointer");
             break; }
            case (simple_attributeType::AttrPrivate) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrPrivate");
             break; }
            case (simple_attributeType::AttrProtected) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrProtected");
             break; }
            case (simple_attributeType::AttrPublic) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrPublic");
             break; }
            case (simple_attributeType::AttrPure) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrPure");
             break; }
            case (simple_attributeType::AttrRecursive) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrRecursive");
             break; }
            case (simple_attributeType::AttrSave) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrSave");
             break; }
            case (simple_attributeType::AttrSequence) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrSequence");
             break; }
            case (simple_attributeType::AttrTarget) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrTarget");
             break; }
            case (simple_attributeType::AttrValue) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrValue");
             break; }
            case (simple_attributeType::AttrVolatile) : {
                if(indent) s.append("\n"+indtd);
                s.append("AttrVolatile");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_attr_intentType(const attr_intentType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (attr_intentType::In) : {
                if(indent) s.append("\n"+indtd);
                s.append("In");
             break; }
            case (attr_intentType::Out) : {
                if(indent) s.append("\n"+indtd);
                s.append("Out");
             break; }
            case (attr_intentType::InOut) : {
                if(indent) s.append("\n"+indtd);
                s.append("InOut");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_decl_typeType(const decl_typeType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (decl_typeType::TypeClass) : {
                if(indent) s.append("\n"+indtd);
                s.append("TypeClass");
             break; }
            case (decl_typeType::TypeCharacter) : {
                if(indent) s.append("\n"+indtd);
                s.append("TypeCharacter");
             break; }
            case (decl_typeType::TypeComplex) : {
                if(indent) s.append("\n"+indtd);
                s.append("TypeComplex");
             break; }
            case (decl_typeType::TypeDoublePrecision) : {
                if(indent) s.append("\n"+indtd);
                s.append("TypeDoublePrecision");
             break; }
            case (decl_typeType::TypeInteger) : {
                if(indent) s.append("\n"+indtd);
                s.append("TypeInteger");
             break; }
            case (decl_typeType::TypeLogical) : {
                if(indent) s.append("\n"+indtd);
                s.append("TypeLogical");
             break; }
            case (decl_typeType::TypeProcedure) : {
                if(indent) s.append("\n"+indtd);
                s.append("TypeProcedure");
             break; }
            case (decl_typeType::TypeReal) : {
                if(indent) s.append("\n"+indtd);
                s.append("TypeReal");
             break; }
            case (decl_typeType::TypeType) : {
                if(indent) s.append("\n"+indtd);
                s.append("TypeType");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_AttrStat(const AttrStat_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("AttrStat");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_variable);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrErrmsg(const AttrErrmsg_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("AttrErrmsg");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_variable);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrNewIndex(const AttrNewIndex_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("AttrNewIndex");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_value);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_AttrEventWaitKwArg(const AttrEventWaitKwArg_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("AttrEventWaitKwArg");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_id);
        s.append(" ");
        self().visit_expr(*x.m_value);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_CoarrayAssociation(const CoarrayAssociation_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("CoarrayAssociation");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_coarray);
        s.append(" ");
        self().visit_expr(*x.m_selector);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_var_sym(const var_sym_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (x.m_name) {
            s.append(x.m_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_dim; i++) {
            self().visit_dimension(x.m_dim[i]);
            if (i < x.n_dim-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_codim; i++) {
            self().visit_codimension(x.m_codim[i]);
            if (i < x.n_codim-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_initializer) {
            self().visit_expr(*x.m_initializer);
        } else {
            s.append("()");
        }
        s.append(" ");
        visit_symbolType(x.m_sym);
        s.append(" ");
        if (x.m_spec) {
            self().visit_decl_attribute(*x.m_spec);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_kind_item(const kind_item_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (x.m_id) {
            s.append(x.m_id);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_value) {
            self().visit_expr(*x.m_value);
        } else {
            s.append("()");
        }
        s.append(" ");
        visit_kind_item_typeType(x.m_type);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_kind_item_typeType(const kind_item_typeType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (kind_item_typeType::Star) : {
                if(indent) s.append("\n"+indtd);
                s.append("Star");
             break; }
            case (kind_item_typeType::Colon) : {
                if(indent) s.append("\n"+indtd);
                s.append("Colon");
             break; }
            case (kind_item_typeType::Value) : {
                if(indent) s.append("\n"+indtd);
                s.append("Value");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_dimension(const dimension_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (x.m_start) {
            self().visit_expr(*x.m_start);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_end) {
            self().visit_expr(*x.m_end);
        } else {
            s.append("()");
        }
        s.append(" ");
        visit_dimension_typeType(x.m_end_star);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_dimension_typeType(const dimension_typeType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (dimension_typeType::DimensionExpr) : {
                if(indent) s.append("\n"+indtd);
                s.append("DimensionExpr");
             break; }
            case (dimension_typeType::DimensionStar) : {
                if(indent) s.append("\n"+indtd);
                s.append("DimensionStar");
             break; }
            case (dimension_typeType::AssumedRank) : {
                if(indent) s.append("\n"+indtd);
                s.append("AssumedRank");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_codimension(const codimension_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (x.m_start) {
            self().visit_expr(*x.m_start);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_end) {
            self().visit_expr(*x.m_end);
        } else {
            s.append("()");
        }
        s.append(" ");
        visit_codimension_typeType(x.m_end_star);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_codimension_typeType(const codimension_typeType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (codimension_typeType::CodimensionExpr) : {
                if(indent) s.append("\n"+indtd);
                s.append("CodimensionExpr");
             break; }
            case (codimension_typeType::CodimensionStar) : {
                if(indent) s.append("\n"+indtd);
                s.append("CodimensionStar");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_symbolType(const symbolType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (symbolType::None) : {
                if(indent) s.append("\n"+indtd);
                s.append("None");
             break; }
            case (symbolType::Arrow) : {
                if(indent) s.append("\n"+indtd);
                s.append("Arrow");
             break; }
            case (symbolType::Equal) : {
                if(indent) s.append("\n"+indtd);
                s.append("Equal");
             break; }
            case (symbolType::Asterisk) : {
                if(indent) s.append("\n"+indtd);
                s.append("Asterisk");
             break; }
            case (symbolType::DoubleAsterisk) : {
                if(indent) s.append("\n"+indtd);
                s.append("DoubleAsterisk");
             break; }
            case (symbolType::Slash) : {
                if(indent) s.append("\n"+indtd);
                s.append("Slash");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
    void visit_equi(const equi_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        s.append("[");
        for (size_t i=0; i<x.n_set_list; i++) {
            self().visit_expr(*x.m_set_list[i]);
            if (i < x.n_set_list-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_kw_argstar(const kw_argstar_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_arg);
        s.append(" ");
        if (x.m_value) {
            self().visit_expr(*x.m_value);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_argstar(const argstar_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (x.m_value) {
            self().visit_expr(*x.m_value);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_arg(const arg_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_arg);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_fnarg(const fnarg_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (x.m_start) {
            self().visit_expr(*x.m_start);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_end) {
            self().visit_expr(*x.m_end);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_step) {
            self().visit_expr(*x.m_step);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_coarrayarg(const coarrayarg_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (x.m_start) {
            self().visit_expr(*x.m_start);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_end) {
            self().visit_expr(*x.m_end);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_step) {
            self().visit_expr(*x.m_step);
        } else {
            s.append("()");
        }
        s.append(" ");
        visit_codimension_typeType(x.m_star);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_keyword(const keyword_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_arg);
        s.append(" ");
        self().visit_expr(*x.m_value);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_struct_member(const struct_member_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_name);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_fnarg(x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_Bind(const Bind_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("Bind");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
            if (i < x.n_args-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
            if (i < x.n_kwargs-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ArrayIndex(const ArrayIndex_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ArrayIndex");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_left) {
            self().visit_expr(*x.m_left);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_right) {
            self().visit_expr(*x.m_right);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_step) {
            self().visit_expr(*x.m_step);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_CaseStmt(const CaseStmt_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("CaseStmt");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_test; i++) {
            self().visit_case_cond(*x.m_test[i]);
            if (i < x.n_test-1) s.append(" ");
        }
        s.append("]");
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_CaseStmt_Default(const CaseStmt_Default_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("CaseStmt_Default");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_CaseCondExpr(const CaseCondExpr_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("CaseCondExpr");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_cond);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_CaseCondRange(const CaseCondRange_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("CaseCondRange");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_start) {
            self().visit_expr(*x.m_start);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_end) {
            self().visit_expr(*x.m_end);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_RankExpr(const RankExpr_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("RankExpr");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        self().visit_expr(*x.m_value);
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_RankStar(const RankStar_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("RankStar");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_RankDefault(const RankDefault_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("RankDefault");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_TypeStmtName(const TypeStmtName_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("TypeStmtName");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_name) {
            s.append(x.m_name);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_TypeStmtType(const TypeStmtType_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("TypeStmtType");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_vartype) {
            self().visit_decl_attribute(*x.m_vartype);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ClassStmt(const ClassStmt_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ClassStmt");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_id) {
            s.append(x.m_id);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ClassDefault(const ClassDefault_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ClassDefault");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_trivia) {
            self().visit_trivia(*x.m_trivia);
        } else {
            s.append("()");
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
            if (i < x.n_body-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_UseSymbol(const UseSymbol_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("UseSymbol");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_remote_sym);
        s.append(" ");
        if (x.m_local_rename) {
            s.append(x.m_local_rename);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_UseAssignment(const UseAssignment_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("UseAssignment");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_IntrinsicOperator(const IntrinsicOperator_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("IntrinsicOperator");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        visit_intrinsicopType(x.m_op);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_DefinedOperator(const DefinedOperator_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("DefinedOperator");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("\"" + std::string(x.m_opName) + "\"");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_RenameOperator(const RenameOperator_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("RenameOperator");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("\"" + std::string(x.m_local_defop) + "\"");
        s.append(" ");
        s.append("\"" + std::string(x.m_use_defop) + "\"");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_UseWrite(const UseWrite_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("UseWrite");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_id);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_UseRead(const UseRead_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("UseRead");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if(indent) s.append("\n"+indtd);
        s.append(x.m_id);
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ConcurrentControl(const ConcurrentControl_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ConcurrentControl");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        if (x.m_var) {
            s.append(x.m_var);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_start) {
            self().visit_expr(*x.m_start);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_end) {
            self().visit_expr(*x.m_end);
        } else {
            s.append("()");
        }
        s.append(" ");
        if (x.m_increment) {
            self().visit_expr(*x.m_increment);
        } else {
            s.append("()");
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
    }
    void visit_ConcurrentLocal(const ConcurrentLocal_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ConcurrentLocal");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_vars; i++) {
            s.append(x.m_vars[i]);
            if (i < x.n_vars-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ConcurrentLocalInit(const ConcurrentLocalInit_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ConcurrentLocalInit");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_vars; i++) {
            s.append(x.m_vars[i]);
            if (i < x.n_vars-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ConcurrentShared(const ConcurrentShared_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ConcurrentShared");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_vars; i++) {
            s.append(x.m_vars[i]);
            if (i < x.n_vars-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ConcurrentDefault(const ConcurrentDefault_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ConcurrentDefault");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ConcurrentReduce(const ConcurrentReduce_t &x) {
        if(indent) {
            tmp1++;
            round[tmp1] = indent_level;
            if(start_line) {
                start_line = false;
                s.append(indtd);
                inc_indent();
            } else {
                s.append("\n"+indtd);
                inc_indent();
            }
        }
        s.append("(");
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::magenta));
        }
        s.append("ConcurrentReduce");
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
        s.append(" ");
        visit_reduce_opType(x.m_op);
        s.append(" ");
        s.append("[");
        for (size_t i=0; i<x.n_vars; i++) {
            s.append(x.m_vars[i]);
            if (i < x.n_vars-1) s.append(" ");
        }
        s.append("]");
        if(indent) {
            lvl = indent_level;
            for(int times = 0; times < (lvl - round[tmp1] ); times++)
                dec_indent();
            round[tmp1] = 0; if(tmp1 > 1) tmp1--;}
        s.append(")");
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_reduce_opType(const reduce_opType &x) {
        if (use_colors) {
            s.append(color(style::bold));
            s.append(color(fg::green));
        }
        switch (x) {
            case (reduce_opType::ReduceAdd) : {
                if(indent) s.append("\n"+indtd);
                s.append("ReduceAdd");
             break; }
            case (reduce_opType::ReduceMul) : {
                if(indent) s.append("\n"+indtd);
                s.append("ReduceMul");
             break; }
            case (reduce_opType::ReduceMIN) : {
                if(indent) s.append("\n"+indtd);
                s.append("ReduceMIN");
             break; }
            case (reduce_opType::ReduceMAX) : {
                if(indent) s.append("\n"+indtd);
                s.append("ReduceMAX");
             break; }
        }
        if (use_colors) {
            s.append(color(fg::reset));
            s.append(color(style::reset));
        }
    }
};


/******************************************************************************/
// Serialization Visitor base class

template <class Derived>
class SerializationBaseVisitor : public BaseVisitor<Derived>
{
private:
    Derived& self() { return static_cast<Derived&>(*this); }
public:
    void visit_TranslationUnit(const TranslationUnit_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_items);
        for (size_t i=0; i<x.n_items; i++) {
            self().write_int8(x.m_items[i]->type);
            self().visit_ast(*x.m_items[i]);
        }
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Module(const Module_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_name);
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_use);
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
        }
        self().write_int64(x.n_implicit);
        for (size_t i=0; i<x.n_implicit; i++) {
            self().visit_implicit_statement(*x.m_implicit[i]);
        }
        self().write_int64(x.n_decl);
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
        }
        self().write_int64(x.n_contains);
        for (size_t i=0; i<x.n_contains; i++) {
            self().visit_program_unit(*x.m_contains[i]);
        }
    }
    void visit_Submodule(const Submodule_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_id);
        if (x.m_parent_name) {
            self().write_bool(true);
            self().write_string(x.m_parent_name);
        } else {
            self().write_bool(false);
        }
        self().write_string(x.m_name);
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_use);
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
        }
        self().write_int64(x.n_implicit);
        for (size_t i=0; i<x.n_implicit; i++) {
            self().visit_implicit_statement(*x.m_implicit[i]);
        }
        self().write_int64(x.n_decl);
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
        }
        self().write_int64(x.n_contains);
        for (size_t i=0; i<x.n_contains; i++) {
            self().visit_program_unit(*x.m_contains[i]);
        }
    }
    void visit_BlockData(const BlockData_t &x) {
        self().write_int8(x.base.type);
        if (x.m_name) {
            self().write_bool(true);
            self().write_string(x.m_name);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_use);
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
        }
        self().write_int64(x.n_implicit);
        for (size_t i=0; i<x.n_implicit; i++) {
            self().visit_implicit_statement(*x.m_implicit[i]);
        }
        self().write_int64(x.n_decl);
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
        }
    }
    void visit_Program(const Program_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_name);
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_use);
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
        }
        self().write_int64(x.n_implicit);
        for (size_t i=0; i<x.n_implicit; i++) {
            self().visit_implicit_statement(*x.m_implicit[i]);
        }
        self().write_int64(x.n_decl);
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        self().write_int64(x.n_contains);
        for (size_t i=0; i<x.n_contains; i++) {
            self().visit_program_unit(*x.m_contains[i]);
        }
    }
    void visit_Subroutine(const Subroutine_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_name);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_arg(x.m_args[i]);
        }
        self().write_int64(x.n_attributes);
        for (size_t i=0; i<x.n_attributes; i++) {
            self().visit_decl_attribute(*x.m_attributes[i]);
        }
        if (x.m_bind) {
            self().write_bool(true);
            self().visit_bind(*x.m_bind);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_use);
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
        }
        self().write_int64(x.n_import);
        for (size_t i=0; i<x.n_import; i++) {
            self().visit_import_statement(*x.m_import[i]);
        }
        self().write_int64(x.n_implicit);
        for (size_t i=0; i<x.n_implicit; i++) {
            self().visit_implicit_statement(*x.m_implicit[i]);
        }
        self().write_int64(x.n_decl);
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        self().write_int64(x.n_contains);
        for (size_t i=0; i<x.n_contains; i++) {
            self().visit_program_unit(*x.m_contains[i]);
        }
    }
    void visit_Procedure(const Procedure_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_name);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_arg(x.m_args[i]);
        }
        self().write_int64(x.n_attributes);
        for (size_t i=0; i<x.n_attributes; i++) {
            self().visit_decl_attribute(*x.m_attributes[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_use);
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
        }
        self().write_int64(x.n_import);
        for (size_t i=0; i<x.n_import; i++) {
            self().visit_import_statement(*x.m_import[i]);
        }
        self().write_int64(x.n_implicit);
        for (size_t i=0; i<x.n_implicit; i++) {
            self().visit_implicit_statement(*x.m_implicit[i]);
        }
        self().write_int64(x.n_decl);
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        self().write_int64(x.n_contains);
        for (size_t i=0; i<x.n_contains; i++) {
            self().visit_program_unit(*x.m_contains[i]);
        }
    }
    void visit_Function(const Function_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_name);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_arg(x.m_args[i]);
        }
        self().write_int64(x.n_attributes);
        for (size_t i=0; i<x.n_attributes; i++) {
            self().visit_decl_attribute(*x.m_attributes[i]);
        }
        if (x.m_return_var) {
            self().write_bool(true);
            self().visit_expr(*x.m_return_var);
        } else {
            self().write_bool(false);
        }
        if (x.m_bind) {
            self().write_bool(true);
            self().visit_bind(*x.m_bind);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_use);
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
        }
        self().write_int64(x.n_import);
        for (size_t i=0; i<x.n_import; i++) {
            self().visit_import_statement(*x.m_import[i]);
        }
        self().write_int64(x.n_implicit);
        for (size_t i=0; i<x.n_implicit; i++) {
            self().visit_implicit_statement(*x.m_implicit[i]);
        }
        self().write_int64(x.n_decl);
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        self().write_int64(x.n_contains);
        for (size_t i=0; i<x.n_contains; i++) {
            self().visit_program_unit(*x.m_contains[i]);
        }
    }
    void visit_Use(const Use_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_nature);
        for (size_t i=0; i<x.n_nature; i++) {
            self().visit_decl_attribute(*x.m_nature[i]);
        }
        self().write_string(x.m_module);
        self().write_int64(x.n_symbols);
        for (size_t i=0; i<x.n_symbols; i++) {
            self().visit_use_symbol(*x.m_symbols[i]);
        }
        if (x.m_only_present) {
            self().write_bool(true);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Declaration(const Declaration_t &x) {
        self().write_int8(x.base.type);
        if (x.m_vartype) {
            self().write_bool(true);
            self().visit_decl_attribute(*x.m_vartype);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_attributes);
        for (size_t i=0; i<x.n_attributes; i++) {
            self().visit_decl_attribute(*x.m_attributes[i]);
        }
        self().write_int64(x.n_syms);
        for (size_t i=0; i<x.n_syms; i++) {
            self().visit_var_sym(x.m_syms[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Interface(const Interface_t &x) {
        self().write_int8(x.base.type);
        self().visit_interface_header(*x.m_header);
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_items);
        for (size_t i=0; i<x.n_items; i++) {
            self().visit_interface_item(*x.m_items[i]);
        }
    }
    void visit_DerivedType(const DerivedType_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_name);
        self().write_int64(x.n_namelist);
        for (size_t i=0; i<x.n_namelist; i++) {
            self().write_string(x.m_namelist[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_attrtype);
        for (size_t i=0; i<x.n_attrtype; i++) {
            self().visit_decl_attribute(*x.m_attrtype[i]);
        }
        self().write_int64(x.n_items);
        for (size_t i=0; i<x.n_items; i++) {
            self().visit_unit_decl2(*x.m_items[i]);
        }
        self().write_int64(x.n_contains);
        for (size_t i=0; i<x.n_contains; i++) {
            self().visit_procedure_decl(*x.m_contains[i]);
        }
    }
    void visit_Enum(const Enum_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_attr);
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_items);
        for (size_t i=0; i<x.n_items; i++) {
            self().visit_unit_decl2(*x.m_items[i]);
        }
    }
    void visit_InterfaceHeader(const InterfaceHeader_t &x) {
        self().write_int8(x.base.type);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_InterfaceHeaderName(const InterfaceHeaderName_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_name);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_InterfaceHeaderAssignment(const InterfaceHeaderAssignment_t &x) {
        self().write_int8(x.base.type);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_InterfaceHeaderOperator(const InterfaceHeaderOperator_t &x) {
        self().write_int8(x.base.type);
        visit_intrinsicopType(x.m_op);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_InterfaceHeaderDefinedOperator(const InterfaceHeaderDefinedOperator_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_operator_name);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AbstractInterfaceHeader(const AbstractInterfaceHeader_t &x) {
        self().write_int8(x.base.type);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_InterfaceHeaderWrite(const InterfaceHeaderWrite_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_id);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_InterfaceHeaderRead(const InterfaceHeaderRead_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_id);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_InterfaceProc(const InterfaceProc_t &x) {
        self().write_int8(x.base.type);
        self().visit_program_unit(*x.m_proc);
    }
    void visit_InterfaceModuleProcedure(const InterfaceModuleProcedure_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_names);
        for (size_t i=0; i<x.n_names; i++) {
            self().write_string(x.m_names[i]);
        }
        self().write_int64(x.n_attributes);
        for (size_t i=0; i<x.n_attributes; i++) {
            self().visit_decl_attribute(*x.m_attributes[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Import(const Import_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_symbols);
        for (size_t i=0; i<x.n_symbols; i++) {
            self().write_string(x.m_symbols[i]);
        }
        visit_import_modifierType(x.m_mod);
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_import_modifierType(const import_modifierType &x) {
        self().write_int8(x);
    }
    void visit_ImplicitNone(const ImplicitNone_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_specs);
        for (size_t i=0; i<x.n_specs; i++) {
            self().visit_implicit_none_spec(*x.m_specs[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Implicit(const Implicit_t &x) {
        self().write_int8(x.base.type);
        self().visit_decl_attribute(*x.m_type);
        self().write_int64(x.n_kind);
        for (size_t i=0; i<x.n_kind; i++) {
            self().visit_letter_spec(*x.m_kind[i]);
        }
        self().write_int64(x.n_specs);
        for (size_t i=0; i<x.n_specs; i++) {
            self().visit_letter_spec(*x.m_specs[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_ImplicitNoneExternal(const ImplicitNoneExternal_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_dummy);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ImplicitNoneType(const ImplicitNoneType_t &x) {
        self().write_int8(x.base.type);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_LetterSpec(const LetterSpec_t &x) {
        self().write_int8(x.base.type);
        if (x.m_start) {
            self().write_bool(true);
            self().write_string(x.m_start);
        } else {
            self().write_bool(false);
        }
        self().write_string(x.m_end);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Allocate(const Allocate_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_fnarg(x.m_args[i]);
        }
        self().write_int64(x.n_keywords);
        for (size_t i=0; i<x.n_keywords; i++) {
            self().visit_keyword(x.m_keywords[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Assign(const Assign_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().write_int64(x.m_assign_label);
        self().write_string(x.m_variable);
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Assignment(const Assignment_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().visit_expr(*x.m_target);
        self().visit_expr(*x.m_value);
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Associate(const Associate_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().visit_expr(*x.m_target);
        self().visit_expr(*x.m_value);
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Backspace(const Backspace_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        self().write_int64(x.n_kwargs);
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Close(const Close_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        self().write_int64(x.n_kwargs);
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Continue(const Continue_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Cycle(const Cycle_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_stmt_name) {
            self().write_bool(true);
            self().write_string(x.m_stmt_name);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Deallocate(const Deallocate_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_fnarg(x.m_args[i]);
        }
        self().write_int64(x.n_keywords);
        for (size_t i=0; i<x.n_keywords; i++) {
            self().visit_keyword(x.m_keywords[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Endfile(const Endfile_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        self().write_int64(x.n_kwargs);
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Entry(const Entry_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().write_string(x.m_name);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_arg(x.m_args[i]);
        }
        if (x.m_return_var) {
            self().write_bool(true);
            self().visit_expr(*x.m_return_var);
        } else {
            self().write_bool(false);
        }
        if (x.m_bind) {
            self().write_bool(true);
            self().visit_bind(*x.m_bind);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_ErrorStop(const ErrorStop_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_code) {
            self().write_bool(true);
            self().visit_expr(*x.m_code);
        } else {
            self().write_bool(false);
        }
        if (x.m_quiet) {
            self().write_bool(true);
            self().visit_expr(*x.m_quiet);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_EventPost(const EventPost_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().visit_expr(*x.m_variable);
        self().write_int64(x.n_stat);
        for (size_t i=0; i<x.n_stat; i++) {
            self().visit_event_attribute(*x.m_stat[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_EventWait(const EventWait_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().visit_expr(*x.m_variable);
        self().write_int64(x.n_spec);
        for (size_t i=0; i<x.n_spec; i++) {
            self().visit_event_attribute(*x.m_spec[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Exit(const Exit_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_stmt_name) {
            self().write_bool(true);
            self().write_string(x.m_stmt_name);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Flush(const Flush_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        self().write_int64(x.n_kwargs);
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_ForAllSingle(const ForAllSingle_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_stmt_name) {
            self().write_bool(true);
            self().write_string(x.m_stmt_name);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_control);
        for (size_t i=0; i<x.n_control; i++) {
            self().visit_concurrent_control(*x.m_control[i]);
        }
        if (x.m_mask) {
            self().write_bool(true);
            self().visit_expr(*x.m_mask);
        } else {
            self().write_bool(false);
        }
        self().visit_stmt(*x.m_assign);
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Format(const Format_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().write_string(x.m_fmt);
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_FormTeam(const FormTeam_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().visit_expr(*x.m_team_number);
        self().write_string(x.m_team_var);
        self().write_int64(x.n_sync_stat);
        for (size_t i=0; i<x.n_sync_stat; i++) {
            self().visit_event_attribute(*x.m_sync_stat[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_GoTo(const GoTo_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_int_var) {
            self().write_bool(true);
            self().write_string(x.m_int_var);
        } else {
            self().write_bool(false);
        }
        if (x.m_goto_label) {
            self().write_bool(true);
            self().visit_expr(*x.m_goto_label);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_labels);
        for (size_t i=0; i<x.n_labels; i++) {
            self().visit_expr(*x.m_labels[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Inquire(const Inquire_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        self().write_int64(x.n_kwargs);
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
        }
        self().write_int64(x.n_values);
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Nullify(const Nullify_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        self().write_int64(x.n_kwargs);
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Open(const Open_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        self().write_int64(x.n_kwargs);
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Return(const Return_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_value) {
            self().write_bool(true);
            self().visit_expr(*x.m_value);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Print(const Print_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_fmt) {
            self().write_bool(true);
            self().visit_expr(*x.m_fmt);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_values);
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Read(const Read_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_format) {
            self().write_bool(true);
            self().visit_expr(*x.m_format);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_argstar(x.m_args[i]);
        }
        self().write_int64(x.n_kwargs);
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_kw_argstar(x.m_kwargs[i]);
        }
        self().write_int64(x.n_values);
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Rewind(const Rewind_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        self().write_int64(x.n_kwargs);
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Stop(const Stop_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_code) {
            self().write_bool(true);
            self().visit_expr(*x.m_code);
        } else {
            self().write_bool(false);
        }
        if (x.m_quiet) {
            self().write_bool(true);
            self().visit_expr(*x.m_quiet);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_SubroutineCall(const SubroutineCall_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().write_string(x.m_name);
        self().write_int64(x.n_member);
        for (size_t i=0; i<x.n_member; i++) {
            self().visit_struct_member(x.m_member[i]);
        }
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_fnarg(x.m_args[i]);
        }
        self().write_int64(x.n_keywords);
        for (size_t i=0; i<x.n_keywords; i++) {
            self().visit_keyword(x.m_keywords[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_SyncAll(const SyncAll_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().write_int64(x.n_stat);
        for (size_t i=0; i<x.n_stat; i++) {
            self().visit_event_attribute(*x.m_stat[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_SyncImages(const SyncImages_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_image_set) {
            self().write_bool(true);
            self().visit_expr(*x.m_image_set);
        } else {
            self().write_bool(false);
        }
        visit_symbolType(x.m_sym);
        self().write_int64(x.n_stat);
        for (size_t i=0; i<x.n_stat; i++) {
            self().visit_event_attribute(*x.m_stat[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_SyncMemory(const SyncMemory_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().write_int64(x.n_stat);
        for (size_t i=0; i<x.n_stat; i++) {
            self().visit_event_attribute(*x.m_stat[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_SyncTeam(const SyncTeam_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().visit_expr(*x.m_value);
        self().write_int64(x.n_stat);
        for (size_t i=0; i<x.n_stat; i++) {
            self().visit_event_attribute(*x.m_stat[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Write(const Write_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_argstar(x.m_args[i]);
        }
        self().write_int64(x.n_kwargs);
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_kw_argstar(x.m_kwargs[i]);
        }
        self().write_int64(x.n_values);
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_AssociateBlock(const AssociateBlock_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_stmt_name) {
            self().write_bool(true);
            self().write_string(x.m_stmt_name);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_syms);
        for (size_t i=0; i<x.n_syms; i++) {
            self().visit_var_sym(x.m_syms[i]);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        if (x.m_t_inside) {
            self().write_bool(true);
            self().visit_trivia(*x.m_t_inside);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Block(const Block_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_stmt_name) {
            self().write_bool(true);
            self().write_string(x.m_stmt_name);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_use);
        for (size_t i=0; i<x.n_use; i++) {
            self().visit_unit_decl1(*x.m_use[i]);
        }
        self().write_int64(x.n_import);
        for (size_t i=0; i<x.n_import; i++) {
            self().visit_import_statement(*x.m_import[i]);
        }
        self().write_int64(x.n_decl);
        for (size_t i=0; i<x.n_decl; i++) {
            self().visit_unit_decl2(*x.m_decl[i]);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        if (x.m_t_inside) {
            self().write_bool(true);
            self().visit_trivia(*x.m_t_inside);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_ChangeTeam(const ChangeTeam_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_stmt_name) {
            self().write_bool(true);
            self().write_string(x.m_stmt_name);
        } else {
            self().write_bool(false);
        }
        self().visit_expr(*x.m_team_value);
        self().write_int64(x.n_coarray_assoc);
        for (size_t i=0; i<x.n_coarray_assoc; i++) {
            self().visit_team_attribute(*x.m_coarray_assoc[i]);
        }
        self().write_int64(x.n_sync);
        for (size_t i=0; i<x.n_sync; i++) {
            self().visit_event_attribute(*x.m_sync[i]);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        if (x.m_t_inside) {
            self().write_bool(true);
            self().visit_trivia(*x.m_t_inside);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_sync_stat);
        for (size_t i=0; i<x.n_sync_stat; i++) {
            self().visit_event_attribute(*x.m_sync_stat[i]);
        }
    }
    void visit_Critical(const Critical_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_stmt_name) {
            self().write_bool(true);
            self().write_string(x.m_stmt_name);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_sync_stat);
        for (size_t i=0; i<x.n_sync_stat; i++) {
            self().visit_event_attribute(*x.m_sync_stat[i]);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        if (x.m_t_inside) {
            self().write_bool(true);
            self().visit_trivia(*x.m_t_inside);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_DoConcurrentLoop(const DoConcurrentLoop_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_stmt_name) {
            self().write_bool(true);
            self().write_string(x.m_stmt_name);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_control);
        for (size_t i=0; i<x.n_control; i++) {
            self().visit_concurrent_control(*x.m_control[i]);
        }
        if (x.m_mask) {
            self().write_bool(true);
            self().visit_expr(*x.m_mask);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_locality);
        for (size_t i=0; i<x.n_locality; i++) {
            self().visit_concurrent_locality(*x.m_locality[i]);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        if (x.m_t_inside) {
            self().write_bool(true);
            self().visit_trivia(*x.m_t_inside);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_DoLoop(const DoLoop_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_stmt_name) {
            self().write_bool(true);
            self().write_string(x.m_stmt_name);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.m_do_label);
        if (x.m_var) {
            self().write_bool(true);
            self().write_string(x.m_var);
        } else {
            self().write_bool(false);
        }
        if (x.m_start) {
            self().write_bool(true);
            self().visit_expr(*x.m_start);
        } else {
            self().write_bool(false);
        }
        if (x.m_end) {
            self().write_bool(true);
            self().visit_expr(*x.m_end);
        } else {
            self().write_bool(false);
        }
        if (x.m_increment) {
            self().write_bool(true);
            self().visit_expr(*x.m_increment);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        if (x.m_t_inside) {
            self().write_bool(true);
            self().visit_trivia(*x.m_t_inside);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_ForAll(const ForAll_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_stmt_name) {
            self().write_bool(true);
            self().write_string(x.m_stmt_name);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_control);
        for (size_t i=0; i<x.n_control; i++) {
            self().visit_concurrent_control(*x.m_control[i]);
        }
        if (x.m_mask) {
            self().write_bool(true);
            self().visit_expr(*x.m_mask);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_locality);
        for (size_t i=0; i<x.n_locality; i++) {
            self().visit_concurrent_locality(*x.m_locality[i]);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        if (x.m_t_inside) {
            self().write_bool(true);
            self().visit_trivia(*x.m_t_inside);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_If(const If_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_stmt_name) {
            self().write_bool(true);
            self().write_string(x.m_stmt_name);
        } else {
            self().write_bool(false);
        }
        self().visit_expr(*x.m_test);
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        self().write_int64(x.n_orelse);
        for (size_t i=0; i<x.n_orelse; i++) {
            self().visit_stmt(*x.m_orelse[i]);
        }
        if (x.m_if_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_if_trivia);
        } else {
            self().write_bool(false);
        }
        if (x.m_else_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_else_trivia);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_IfArithmetic(const IfArithmetic_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_stmt_name) {
            self().write_bool(true);
            self().write_string(x.m_stmt_name);
        } else {
            self().write_bool(false);
        }
        self().visit_expr(*x.m_test);
        self().write_int64(x.m_lt_label);
        self().write_int64(x.m_eq_label);
        self().write_int64(x.m_gt_label);
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Select(const Select_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_stmt_name) {
            self().write_bool(true);
            self().write_string(x.m_stmt_name);
        } else {
            self().write_bool(false);
        }
        self().visit_expr(*x.m_test);
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_case_stmt(*x.m_body[i]);
        }
        if (x.m_t_inside) {
            self().write_bool(true);
            self().visit_trivia(*x.m_t_inside);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_SelectRank(const SelectRank_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_stmt_name) {
            self().write_bool(true);
            self().write_string(x.m_stmt_name);
        } else {
            self().write_bool(false);
        }
        if (x.m_assoc_name) {
            self().write_bool(true);
            self().write_string(x.m_assoc_name);
        } else {
            self().write_bool(false);
        }
        self().visit_expr(*x.m_selector);
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_rank_stmt(*x.m_body[i]);
        }
        if (x.m_t_inside) {
            self().write_bool(true);
            self().visit_trivia(*x.m_t_inside);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_SelectType(const SelectType_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_stmt_name) {
            self().write_bool(true);
            self().write_string(x.m_stmt_name);
        } else {
            self().write_bool(false);
        }
        if (x.m_assoc_name) {
            self().write_bool(true);
            self().write_string(x.m_assoc_name);
        } else {
            self().write_bool(false);
        }
        self().visit_expr(*x.m_selector);
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_type_stmt(*x.m_body[i]);
        }
        if (x.m_t_inside) {
            self().write_bool(true);
            self().visit_trivia(*x.m_t_inside);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Where(const Where_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_stmt_name) {
            self().write_bool(true);
            self().write_string(x.m_stmt_name);
        } else {
            self().write_bool(false);
        }
        self().visit_expr(*x.m_test);
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        self().write_int64(x.n_orelse);
        for (size_t i=0; i<x.n_orelse; i++) {
            self().visit_stmt(*x.m_orelse[i]);
        }
        if (x.m_t_inside) {
            self().write_bool(true);
            self().visit_trivia(*x.m_t_inside);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_WhileLoop(const WhileLoop_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_label);
        if (x.m_stmt_name) {
            self().write_bool(true);
            self().write_string(x.m_stmt_name);
        } else {
            self().write_bool(false);
        }
        self().visit_expr(*x.m_test);
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
        if (x.m_t_inside) {
            self().write_bool(true);
            self().visit_trivia(*x.m_t_inside);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_BoolOp(const BoolOp_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_left);
        visit_boolopType(x.m_op);
        self().visit_expr(*x.m_right);
    }
    void visit_BinOp(const BinOp_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_left);
        visit_operatorType(x.m_op);
        self().visit_expr(*x.m_right);
    }
    void visit_DefBinOp(const DefBinOp_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_left);
        self().write_string(x.m_op);
        self().visit_expr(*x.m_right);
    }
    void visit_StrOp(const StrOp_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_left);
        visit_stroperatorType(x.m_op);
        self().visit_expr(*x.m_right);
    }
    void visit_UnaryOp(const UnaryOp_t &x) {
        self().write_int8(x.base.type);
        visit_unaryopType(x.m_op);
        self().visit_expr(*x.m_operand);
    }
    void visit_DefUnaryOp(const DefUnaryOp_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_op);
        self().visit_expr(*x.m_operand);
    }
    void visit_Compare(const Compare_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_left);
        visit_cmpopType(x.m_op);
        self().visit_expr(*x.m_right);
    }
    void visit_FuncCallOrArray(const FuncCallOrArray_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_func);
        self().write_int64(x.n_member);
        for (size_t i=0; i<x.n_member; i++) {
            self().visit_struct_member(x.m_member[i]);
        }
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_fnarg(x.m_args[i]);
        }
        self().write_int64(x.n_keywords);
        for (size_t i=0; i<x.n_keywords; i++) {
            self().visit_keyword(x.m_keywords[i]);
        }
        self().write_int64(x.n_subargs);
        for (size_t i=0; i<x.n_subargs; i++) {
            self().visit_fnarg(x.m_subargs[i]);
        }
    }
    void visit_CoarrayRef(const CoarrayRef_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_name);
        self().write_int64(x.n_member);
        for (size_t i=0; i<x.n_member; i++) {
            self().visit_struct_member(x.m_member[i]);
        }
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_fnarg(x.m_args[i]);
        }
        self().write_int64(x.n_fnkw);
        for (size_t i=0; i<x.n_fnkw; i++) {
            self().visit_keyword(x.m_fnkw[i]);
        }
        self().write_int64(x.n_coargs);
        for (size_t i=0; i<x.n_coargs; i++) {
            self().visit_coarrayarg(x.m_coargs[i]);
        }
        self().write_int64(x.n_cokw);
        for (size_t i=0; i<x.n_cokw; i++) {
            self().visit_keyword(x.m_cokw[i]);
        }
    }
    void visit_ArrayInitializer(const ArrayInitializer_t &x) {
        self().write_int8(x.base.type);
        if (x.m_vartype) {
            self().write_bool(true);
            self().visit_decl_attribute(*x.m_vartype);
        } else {
            self().write_bool(false);
        }
        if (x.m_classtype) {
            self().write_bool(true);
            self().write_string(x.m_classtype);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
    }
    void visit_ImpliedDoLoop(const ImpliedDoLoop_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_values);
        for (size_t i=0; i<x.n_values; i++) {
            self().visit_expr(*x.m_values[i]);
        }
        self().write_string(x.m_var);
        self().visit_expr(*x.m_start);
        self().visit_expr(*x.m_end);
        if (x.m_increment) {
            self().write_bool(true);
            self().visit_expr(*x.m_increment);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Num(const Num_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.m_n);
        if (x.m_kind) {
            self().write_bool(true);
            self().write_string(x.m_kind);
        } else {
            self().write_bool(false);
        }
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Real(const Real_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_n);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Complex(const Complex_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_re);
        self().visit_expr(*x.m_im);
    }
    void visit_String(const String_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_s);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Substring(const Substring_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_s);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_fnarg(x.m_args[i]);
        }
    }
    void visit_BOZ(const BOZ_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_s);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Name(const Name_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_id);
        self().write_int64(x.n_member);
        for (size_t i=0; i<x.n_member; i++) {
            self().visit_struct_member(x.m_member[i]);
        }
    }
    void visit_Logical(const Logical_t &x) {
        self().write_int8(x.base.type);
        if (x.m_value) {
            self().write_bool(true);
        } else {
            self().write_bool(false);
        }
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_DataImpliedDo(const DataImpliedDo_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_object_list);
        for (size_t i=0; i<x.n_object_list; i++) {
            self().visit_expr(*x.m_object_list[i]);
        }
        if (x.m_type) {
            self().write_bool(true);
            self().visit_decl_attribute(*x.m_type);
        } else {
            self().write_bool(false);
        }
        self().write_string(x.m_var);
        self().visit_expr(*x.m_start);
        self().visit_expr(*x.m_end);
        if (x.m_increment) {
            self().write_bool(true);
            self().visit_expr(*x.m_increment);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Parenthesis(const Parenthesis_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_operand);
    }
    void visit_TriviaNode(const TriviaNode_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_inside);
        for (size_t i=0; i<x.n_inside; i++) {
            self().visit_trivia_node(*x.m_inside[i]);
        }
        self().write_int64(x.n_after);
        for (size_t i=0; i<x.n_after; i++) {
            self().visit_trivia_node(*x.m_after[i]);
        }
    }
    void visit_Comment(const Comment_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_comment);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_EOLComment(const EOLComment_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_comment);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_EndOfLine(const EndOfLine_t &x) {
        self().write_int8(x.base.type);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_Semicolon(const Semicolon_t &x) {
        self().write_int8(x.base.type);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_boolopType(const boolopType &x) {
        self().write_int8(x);
    }
    void visit_operatorType(const operatorType &x) {
        self().write_int8(x);
    }
    void visit_stroperatorType(const stroperatorType &x) {
        self().write_int8(x);
    }
    void visit_unaryopType(const unaryopType &x) {
        self().write_int8(x);
    }
    void visit_cmpopType(const cmpopType &x) {
        self().write_int8(x);
    }
    void visit_intrinsicopType(const intrinsicopType &x) {
        self().write_int8(x);
    }
    void visit_DerivedTypeProc(const DerivedTypeProc_t &x) {
        self().write_int8(x.base.type);
        if (x.m_name) {
            self().write_bool(true);
            self().write_string(x.m_name);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_attr);
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
        }
        self().write_int64(x.n_symbols);
        for (size_t i=0; i<x.n_symbols; i++) {
            self().visit_use_symbol(*x.m_symbols[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_GenericOperator(const GenericOperator_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_attr);
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
        }
        visit_intrinsicopType(x.m_op);
        self().write_int64(x.n_names);
        for (size_t i=0; i<x.n_names; i++) {
            self().write_string(x.m_names[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_GenericDefinedOperator(const GenericDefinedOperator_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_attr);
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
        }
        self().write_string(x.m_optype);
        self().write_int64(x.n_names);
        for (size_t i=0; i<x.n_names; i++) {
            self().write_string(x.m_names[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_GenericAssignment(const GenericAssignment_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_attr);
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
        }
        self().write_int64(x.n_names);
        for (size_t i=0; i<x.n_names; i++) {
            self().write_string(x.m_names[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_GenericName(const GenericName_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_attr);
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
        }
        self().write_string(x.m_name);
        self().write_int64(x.n_names);
        for (size_t i=0; i<x.n_names; i++) {
            self().write_string(x.m_names[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_GenericWrite(const GenericWrite_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_attr);
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
        }
        self().write_string(x.m_id);
        self().write_int64(x.n_names);
        for (size_t i=0; i<x.n_names; i++) {
            self().write_string(x.m_names[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_GenericRead(const GenericRead_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_attr);
        for (size_t i=0; i<x.n_attr; i++) {
            self().visit_decl_attribute(*x.m_attr[i]);
        }
        self().write_string(x.m_id);
        self().write_int64(x.n_names);
        for (size_t i=0; i<x.n_names; i++) {
            self().write_string(x.m_names[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_FinalName(const FinalName_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_name);
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_Private(const Private_t &x) {
        self().write_int8(x.base.type);
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
    }
    void visit_AttrBind(const AttrBind_t &x) {
        self().write_int8(x.base.type);
        self().visit_bind(*x.m_bind);
    }
    void visit_AttrData(const AttrData_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_object);
        for (size_t i=0; i<x.n_object; i++) {
            self().visit_expr(*x.m_object[i]);
        }
        self().write_int64(x.n_value);
        for (size_t i=0; i<x.n_value; i++) {
            self().visit_expr(*x.m_value[i]);
        }
    }
    void visit_AttrDimension(const AttrDimension_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_dim);
        for (size_t i=0; i<x.n_dim; i++) {
            self().visit_dimension(x.m_dim[i]);
        }
    }
    void visit_AttrCodimension(const AttrCodimension_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_codim);
        for (size_t i=0; i<x.n_codim; i++) {
            self().visit_codimension(x.m_codim[i]);
        }
    }
    void visit_AttrEquivalence(const AttrEquivalence_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_equi(x.m_args[i]);
        }
    }
    void visit_AttrExtends(const AttrExtends_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_name);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrIntent(const AttrIntent_t &x) {
        self().write_int8(x.base.type);
        visit_attr_intentType(x.m_intent);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrNamelist(const AttrNamelist_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_name);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrPass(const AttrPass_t &x) {
        self().write_int8(x.base.type);
        if (x.m_name) {
            self().write_bool(true);
            self().write_string(x.m_name);
        } else {
            self().write_bool(false);
        }
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_SimpleAttribute(const SimpleAttribute_t &x) {
        self().write_int8(x.base.type);
        visit_simple_attributeType(x.m_attr);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrType(const AttrType_t &x) {
        self().write_int8(x.base.type);
        visit_decl_typeType(x.m_type);
        self().write_int64(x.n_kind);
        for (size_t i=0; i<x.n_kind; i++) {
            self().visit_kind_item(x.m_kind[i]);
        }
        if (x.m_name) {
            self().write_bool(true);
            self().write_string(x.m_name);
        } else {
            self().write_bool(false);
        }
        visit_symbolType(x.m_sym);
    }
    void visit_AttrAssignment(const AttrAssignment_t &x) {
        self().write_int8(x.base.type);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrIntrinsicOperator(const AttrIntrinsicOperator_t &x) {
        self().write_int8(x.base.type);
        visit_intrinsicopType(x.m_op);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrDefinedOperator(const AttrDefinedOperator_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_op_name);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_simple_attributeType(const simple_attributeType &x) {
        self().write_int8(x);
    }
    void visit_attr_intentType(const attr_intentType &x) {
        self().write_int8(x);
    }
    void visit_decl_typeType(const decl_typeType &x) {
        self().write_int8(x);
    }
    void visit_AttrStat(const AttrStat_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_variable);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrErrmsg(const AttrErrmsg_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_variable);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_AttrNewIndex(const AttrNewIndex_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_value);
    }
    void visit_AttrEventWaitKwArg(const AttrEventWaitKwArg_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_id);
        self().visit_expr(*x.m_value);
    }
    void visit_CoarrayAssociation(const CoarrayAssociation_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_coarray);
        self().visit_expr(*x.m_selector);
    }
    void visit_var_sym(const var_sym_t &x) {
        if (x.m_name) {
            self().write_bool(true);
            self().write_string(x.m_name);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_dim);
        for (size_t i=0; i<x.n_dim; i++) {
            self().visit_dimension(x.m_dim[i]);
        }
        self().write_int64(x.n_codim);
        for (size_t i=0; i<x.n_codim; i++) {
            self().visit_codimension(x.m_codim[i]);
        }
        if (x.m_initializer) {
            self().write_bool(true);
            self().visit_expr(*x.m_initializer);
        } else {
            self().write_bool(false);
        }
        visit_symbolType(x.m_sym);
        if (x.m_spec) {
            self().write_bool(true);
            self().visit_decl_attribute(*x.m_spec);
        } else {
            self().write_bool(false);
        }
    }
    void visit_kind_item(const kind_item_t &x) {
        if (x.m_id) {
            self().write_bool(true);
            self().write_string(x.m_id);
        } else {
            self().write_bool(false);
        }
        if (x.m_value) {
            self().write_bool(true);
            self().visit_expr(*x.m_value);
        } else {
            self().write_bool(false);
        }
        visit_kind_item_typeType(x.m_type);
    }
    void visit_kind_item_typeType(const kind_item_typeType &x) {
        self().write_int8(x);
    }
    void visit_dimension(const dimension_t &x) {
        if (x.m_start) {
            self().write_bool(true);
            self().visit_expr(*x.m_start);
        } else {
            self().write_bool(false);
        }
        if (x.m_end) {
            self().write_bool(true);
            self().visit_expr(*x.m_end);
        } else {
            self().write_bool(false);
        }
        visit_dimension_typeType(x.m_end_star);
    }
    void visit_dimension_typeType(const dimension_typeType &x) {
        self().write_int8(x);
    }
    void visit_codimension(const codimension_t &x) {
        if (x.m_start) {
            self().write_bool(true);
            self().visit_expr(*x.m_start);
        } else {
            self().write_bool(false);
        }
        if (x.m_end) {
            self().write_bool(true);
            self().visit_expr(*x.m_end);
        } else {
            self().write_bool(false);
        }
        visit_codimension_typeType(x.m_end_star);
    }
    void visit_codimension_typeType(const codimension_typeType &x) {
        self().write_int8(x);
    }
    void visit_symbolType(const symbolType &x) {
        self().write_int8(x);
    }
    void visit_equi(const equi_t &x) {
        self().write_int64(x.n_set_list);
        for (size_t i=0; i<x.n_set_list; i++) {
            self().visit_expr(*x.m_set_list[i]);
        }
    }
    void visit_kw_argstar(const kw_argstar_t &x) {
        self().write_string(x.m_arg);
        if (x.m_value) {
            self().write_bool(true);
            self().visit_expr(*x.m_value);
        } else {
            self().write_bool(false);
        }
    }
    void visit_argstar(const argstar_t &x) {
        if (x.m_value) {
            self().write_bool(true);
            self().visit_expr(*x.m_value);
        } else {
            self().write_bool(false);
        }
    }
    void visit_arg(const arg_t &x) {
        self().write_string(x.m_arg);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_fnarg(const fnarg_t &x) {
        if (x.m_start) {
            self().write_bool(true);
            self().visit_expr(*x.m_start);
        } else {
            self().write_bool(false);
        }
        if (x.m_end) {
            self().write_bool(true);
            self().visit_expr(*x.m_end);
        } else {
            self().write_bool(false);
        }
        if (x.m_step) {
            self().write_bool(true);
            self().visit_expr(*x.m_step);
        } else {
            self().write_bool(false);
        }
    }
    void visit_coarrayarg(const coarrayarg_t &x) {
        if (x.m_start) {
            self().write_bool(true);
            self().visit_expr(*x.m_start);
        } else {
            self().write_bool(false);
        }
        if (x.m_end) {
            self().write_bool(true);
            self().visit_expr(*x.m_end);
        } else {
            self().write_bool(false);
        }
        if (x.m_step) {
            self().write_bool(true);
            self().visit_expr(*x.m_step);
        } else {
            self().write_bool(false);
        }
        visit_codimension_typeType(x.m_star);
    }
    void visit_keyword(const keyword_t &x) {
        self().write_string(x.m_arg);
        self().visit_expr(*x.m_value);
    }
    void visit_struct_member(const struct_member_t &x) {
        self().write_string(x.m_name);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_fnarg(x.m_args[i]);
        }
    }
    void visit_Bind(const Bind_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_args);
        for (size_t i=0; i<x.n_args; i++) {
            self().visit_expr(*x.m_args[i]);
        }
        self().write_int64(x.n_kwargs);
        for (size_t i=0; i<x.n_kwargs; i++) {
            self().visit_keyword(x.m_kwargs[i]);
        }
    }
    void visit_ArrayIndex(const ArrayIndex_t &x) {
        self().write_int8(x.base.type);
        if (x.m_left) {
            self().write_bool(true);
            self().visit_expr(*x.m_left);
        } else {
            self().write_bool(false);
        }
        if (x.m_right) {
            self().write_bool(true);
            self().visit_expr(*x.m_right);
        } else {
            self().write_bool(false);
        }
        if (x.m_step) {
            self().write_bool(true);
            self().visit_expr(*x.m_step);
        } else {
            self().write_bool(false);
        }
    }
    void visit_CaseStmt(const CaseStmt_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_test);
        for (size_t i=0; i<x.n_test; i++) {
            self().visit_case_cond(*x.m_test[i]);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_CaseStmt_Default(const CaseStmt_Default_t &x) {
        self().write_int8(x.base.type);
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_CaseCondExpr(const CaseCondExpr_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_cond);
    }
    void visit_CaseCondRange(const CaseCondRange_t &x) {
        self().write_int8(x.base.type);
        if (x.m_start) {
            self().write_bool(true);
            self().visit_expr(*x.m_start);
        } else {
            self().write_bool(false);
        }
        if (x.m_end) {
            self().write_bool(true);
            self().visit_expr(*x.m_end);
        } else {
            self().write_bool(false);
        }
    }
    void visit_RankExpr(const RankExpr_t &x) {
        self().write_int8(x.base.type);
        self().visit_expr(*x.m_value);
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_RankStar(const RankStar_t &x) {
        self().write_int8(x.base.type);
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_RankDefault(const RankDefault_t &x) {
        self().write_int8(x.base.type);
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_TypeStmtName(const TypeStmtName_t &x) {
        self().write_int8(x.base.type);
        if (x.m_name) {
            self().write_bool(true);
            self().write_string(x.m_name);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_TypeStmtType(const TypeStmtType_t &x) {
        self().write_int8(x.base.type);
        if (x.m_vartype) {
            self().write_bool(true);
            self().visit_decl_attribute(*x.m_vartype);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_ClassStmt(const ClassStmt_t &x) {
        self().write_int8(x.base.type);
        if (x.m_id) {
            self().write_bool(true);
            self().write_string(x.m_id);
        } else {
            self().write_bool(false);
        }
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_ClassDefault(const ClassDefault_t &x) {
        self().write_int8(x.base.type);
        if (x.m_trivia) {
            self().write_bool(true);
            self().visit_trivia(*x.m_trivia);
        } else {
            self().write_bool(false);
        }
        self().write_int64(x.n_body);
        for (size_t i=0; i<x.n_body; i++) {
            self().visit_stmt(*x.m_body[i]);
        }
    }
    void visit_UseSymbol(const UseSymbol_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_remote_sym);
        if (x.m_local_rename) {
            self().write_bool(true);
            self().write_string(x.m_local_rename);
        } else {
            self().write_bool(false);
        }
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_UseAssignment(const UseAssignment_t &x) {
        self().write_int8(x.base.type);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_IntrinsicOperator(const IntrinsicOperator_t &x) {
        self().write_int8(x.base.type);
        visit_intrinsicopType(x.m_op);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_DefinedOperator(const DefinedOperator_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_opName);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_RenameOperator(const RenameOperator_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_local_defop);
        self().write_string(x.m_use_defop);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_UseWrite(const UseWrite_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_id);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_UseRead(const UseRead_t &x) {
        self().write_int8(x.base.type);
        self().write_string(x.m_id);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ConcurrentControl(const ConcurrentControl_t &x) {
        self().write_int8(x.base.type);
        if (x.m_var) {
            self().write_bool(true);
            self().write_string(x.m_var);
        } else {
            self().write_bool(false);
        }
        if (x.m_start) {
            self().write_bool(true);
            self().visit_expr(*x.m_start);
        } else {
            self().write_bool(false);
        }
        if (x.m_end) {
            self().write_bool(true);
            self().visit_expr(*x.m_end);
        } else {
            self().write_bool(false);
        }
        if (x.m_increment) {
            self().write_bool(true);
            self().visit_expr(*x.m_increment);
        } else {
            self().write_bool(false);
        }
    }
    void visit_ConcurrentLocal(const ConcurrentLocal_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_vars);
        for (size_t i=0; i<x.n_vars; i++) {
            self().write_string(x.m_vars[i]);
        }
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ConcurrentLocalInit(const ConcurrentLocalInit_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_vars);
        for (size_t i=0; i<x.n_vars; i++) {
            self().write_string(x.m_vars[i]);
        }
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ConcurrentShared(const ConcurrentShared_t &x) {
        self().write_int8(x.base.type);
        self().write_int64(x.n_vars);
        for (size_t i=0; i<x.n_vars; i++) {
            self().write_string(x.m_vars[i]);
        }
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ConcurrentDefault(const ConcurrentDefault_t &x) {
        self().write_int8(x.base.type);
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_ConcurrentReduce(const ConcurrentReduce_t &x) {
        self().write_int8(x.base.type);
        visit_reduce_opType(x.m_op);
        self().write_int64(x.n_vars);
        for (size_t i=0; i<x.n_vars; i++) {
            self().write_string(x.m_vars[i]);
        }
        if ((bool&)x) { } // Suppress unused warning
    }
    void visit_reduce_opType(const reduce_opType &x) {
        self().write_int8(x);
    }
};


/******************************************************************************/
// Deserialization Visitor base class

template <class Derived>
class DeserializationBaseVisitor : public BaseVisitor<Derived>
{
private:
    Derived& self() { return static_cast<Derived&>(*this); }
public:
    Allocator &al;
    bool load_symtab_id;
    std::map<uint64_t,SymbolTable*> id_symtab_map;
    DeserializationBaseVisitor(Allocator &al, bool load_symtab_id) : al{al}, load_symtab_id{load_symtab_id} {}
    ast_t* deserialize_node() {
        uint8_t t = self().read_int8();
        AST::astType ty = static_cast<AST::astType>(t);
        switch (ty) {
            case (AST::astType::unit) : return self().deserialize_unit();
            case (AST::astType::mod) : return self().deserialize_mod();
            case (AST::astType::program_unit) : return self().deserialize_program_unit();
            case (AST::astType::unit_decl1) : return self().deserialize_unit_decl1();
            case (AST::astType::unit_decl2) : return self().deserialize_unit_decl2();
            case (AST::astType::interface_header) : return self().deserialize_interface_header();
            case (AST::astType::interface_item) : return self().deserialize_interface_item();
            case (AST::astType::import_statement) : return self().deserialize_import_statement();
            case (AST::astType::implicit_statement) : return self().deserialize_implicit_statement();
            case (AST::astType::implicit_none_spec) : return self().deserialize_implicit_none_spec();
            case (AST::astType::letter_spec) : return self().deserialize_letter_spec();
            case (AST::astType::stmt) : return self().deserialize_stmt();
            case (AST::astType::expr) : return self().deserialize_expr();
            case (AST::astType::trivia) : return self().deserialize_trivia();
            case (AST::astType::trivia_node) : return self().deserialize_trivia_node();
            case (AST::astType::procedure_decl) : return self().deserialize_procedure_decl();
            case (AST::astType::decl_attribute) : return self().deserialize_decl_attribute();
            case (AST::astType::event_attribute) : return self().deserialize_event_attribute();
            case (AST::astType::team_attribute) : return self().deserialize_team_attribute();
            case (AST::astType::bind) : return self().deserialize_bind();
            case (AST::astType::array_index) : return self().deserialize_array_index();
            case (AST::astType::case_stmt) : return self().deserialize_case_stmt();
            case (AST::astType::case_cond) : return self().deserialize_case_cond();
            case (AST::astType::rank_stmt) : return self().deserialize_rank_stmt();
            case (AST::astType::type_stmt) : return self().deserialize_type_stmt();
            case (AST::astType::use_symbol) : return self().deserialize_use_symbol();
            case (AST::astType::concurrent_control) : return self().deserialize_concurrent_control();
            case (AST::astType::concurrent_locality) : return self().deserialize_concurrent_locality();
            default : throw LFortranException("Unknown type in deserialize_node()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_TranslationUnit() {
        size_t n_items; // Sequence
        n_items = self().read_int64();
        Vec<ast_t*> v_items;
        v_items.reserve(al, n_items);
        for (size_t i=0; i<n_items; i++) {
            v_items.push_back(al, self().deserialize_node());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_TranslationUnit_t(al, loc, v_items.p, v_items.n);
    }
    ast_t* deserialize_unit() {
        uint8_t t = self().read_int8();
        AST::unitType ty = static_cast<AST::unitType>(t);
        switch (ty) {
            case (AST::unitType::TranslationUnit) : return self().deserialize_TranslationUnit();
            default : throw LFortranException("Unknown type in deserialize_unit()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_Module() {
        size_t n_use; // Sequence
        size_t n_implicit; // Sequence
        size_t n_decl; // Sequence
        size_t n_contains; // Sequence
        char *m_name;
        m_name = self().read_cstring();
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        n_use = self().read_int64();
        Vec<unit_decl1_t*> v_use;
        v_use.reserve(al, n_use);
        for (size_t i=0; i<n_use; i++) {
            v_use.push_back(al, AST::down_cast<AST::unit_decl1_t>(self().deserialize_unit_decl1()));
        }
        n_implicit = self().read_int64();
        Vec<implicit_statement_t*> v_implicit;
        v_implicit.reserve(al, n_implicit);
        for (size_t i=0; i<n_implicit; i++) {
            v_implicit.push_back(al, AST::down_cast<AST::implicit_statement_t>(self().deserialize_implicit_statement()));
        }
        n_decl = self().read_int64();
        Vec<unit_decl2_t*> v_decl;
        v_decl.reserve(al, n_decl);
        for (size_t i=0; i<n_decl; i++) {
            v_decl.push_back(al, AST::down_cast<AST::unit_decl2_t>(self().deserialize_unit_decl2()));
        }
        n_contains = self().read_int64();
        Vec<program_unit_t*> v_contains;
        v_contains.reserve(al, n_contains);
        for (size_t i=0; i<n_contains; i++) {
            v_contains.push_back(al, AST::down_cast<AST::program_unit_t>(self().deserialize_program_unit()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Module_t(al, loc, m_name, m_trivia, v_use.p, v_use.n, v_implicit.p, v_implicit.n, v_decl.p, v_decl.n, v_contains.p, v_contains.n);
    }
    ast_t* deserialize_Submodule() {
        size_t n_use; // Sequence
        size_t n_implicit; // Sequence
        size_t n_decl; // Sequence
        size_t n_contains; // Sequence
        char *m_id;
        m_id = self().read_cstring();
        char *m_parent_name;
        bool m_parent_name_present = self().read_bool();
        if (m_parent_name_present) {
        m_parent_name = self().read_cstring();
        } else {
        m_parent_name = nullptr;
        }
        char *m_name;
        m_name = self().read_cstring();
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        n_use = self().read_int64();
        Vec<unit_decl1_t*> v_use;
        v_use.reserve(al, n_use);
        for (size_t i=0; i<n_use; i++) {
            v_use.push_back(al, AST::down_cast<AST::unit_decl1_t>(self().deserialize_unit_decl1()));
        }
        n_implicit = self().read_int64();
        Vec<implicit_statement_t*> v_implicit;
        v_implicit.reserve(al, n_implicit);
        for (size_t i=0; i<n_implicit; i++) {
            v_implicit.push_back(al, AST::down_cast<AST::implicit_statement_t>(self().deserialize_implicit_statement()));
        }
        n_decl = self().read_int64();
        Vec<unit_decl2_t*> v_decl;
        v_decl.reserve(al, n_decl);
        for (size_t i=0; i<n_decl; i++) {
            v_decl.push_back(al, AST::down_cast<AST::unit_decl2_t>(self().deserialize_unit_decl2()));
        }
        n_contains = self().read_int64();
        Vec<program_unit_t*> v_contains;
        v_contains.reserve(al, n_contains);
        for (size_t i=0; i<n_contains; i++) {
            v_contains.push_back(al, AST::down_cast<AST::program_unit_t>(self().deserialize_program_unit()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Submodule_t(al, loc, m_id, m_parent_name, m_name, m_trivia, v_use.p, v_use.n, v_implicit.p, v_implicit.n, v_decl.p, v_decl.n, v_contains.p, v_contains.n);
    }
    ast_t* deserialize_BlockData() {
        size_t n_use; // Sequence
        size_t n_implicit; // Sequence
        size_t n_decl; // Sequence
        char *m_name;
        bool m_name_present = self().read_bool();
        if (m_name_present) {
        m_name = self().read_cstring();
        } else {
        m_name = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        n_use = self().read_int64();
        Vec<unit_decl1_t*> v_use;
        v_use.reserve(al, n_use);
        for (size_t i=0; i<n_use; i++) {
            v_use.push_back(al, AST::down_cast<AST::unit_decl1_t>(self().deserialize_unit_decl1()));
        }
        n_implicit = self().read_int64();
        Vec<implicit_statement_t*> v_implicit;
        v_implicit.reserve(al, n_implicit);
        for (size_t i=0; i<n_implicit; i++) {
            v_implicit.push_back(al, AST::down_cast<AST::implicit_statement_t>(self().deserialize_implicit_statement()));
        }
        n_decl = self().read_int64();
        Vec<unit_decl2_t*> v_decl;
        v_decl.reserve(al, n_decl);
        for (size_t i=0; i<n_decl; i++) {
            v_decl.push_back(al, AST::down_cast<AST::unit_decl2_t>(self().deserialize_unit_decl2()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_BlockData_t(al, loc, m_name, m_trivia, v_use.p, v_use.n, v_implicit.p, v_implicit.n, v_decl.p, v_decl.n);
    }
    ast_t* deserialize_Program() {
        size_t n_use; // Sequence
        size_t n_implicit; // Sequence
        size_t n_decl; // Sequence
        size_t n_body; // Sequence
        size_t n_contains; // Sequence
        char *m_name;
        m_name = self().read_cstring();
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        n_use = self().read_int64();
        Vec<unit_decl1_t*> v_use;
        v_use.reserve(al, n_use);
        for (size_t i=0; i<n_use; i++) {
            v_use.push_back(al, AST::down_cast<AST::unit_decl1_t>(self().deserialize_unit_decl1()));
        }
        n_implicit = self().read_int64();
        Vec<implicit_statement_t*> v_implicit;
        v_implicit.reserve(al, n_implicit);
        for (size_t i=0; i<n_implicit; i++) {
            v_implicit.push_back(al, AST::down_cast<AST::implicit_statement_t>(self().deserialize_implicit_statement()));
        }
        n_decl = self().read_int64();
        Vec<unit_decl2_t*> v_decl;
        v_decl.reserve(al, n_decl);
        for (size_t i=0; i<n_decl; i++) {
            v_decl.push_back(al, AST::down_cast<AST::unit_decl2_t>(self().deserialize_unit_decl2()));
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        n_contains = self().read_int64();
        Vec<program_unit_t*> v_contains;
        v_contains.reserve(al, n_contains);
        for (size_t i=0; i<n_contains; i++) {
            v_contains.push_back(al, AST::down_cast<AST::program_unit_t>(self().deserialize_program_unit()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Program_t(al, loc, m_name, m_trivia, v_use.p, v_use.n, v_implicit.p, v_implicit.n, v_decl.p, v_decl.n, v_body.p, v_body.n, v_contains.p, v_contains.n);
    }
    ast_t* deserialize_mod() {
        uint8_t t = self().read_int8();
        AST::modType ty = static_cast<AST::modType>(t);
        switch (ty) {
            case (AST::modType::Module) : return self().deserialize_Module();
            case (AST::modType::Submodule) : return self().deserialize_Submodule();
            case (AST::modType::BlockData) : return self().deserialize_BlockData();
            case (AST::modType::Program) : return self().deserialize_Program();
            default : throw LFortranException("Unknown type in deserialize_mod()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_Subroutine() {
        size_t n_args; // Sequence
        size_t n_attributes; // Sequence
        size_t n_use; // Sequence
        size_t n_import; // Sequence
        size_t n_implicit; // Sequence
        size_t n_decl; // Sequence
        size_t n_body; // Sequence
        size_t n_contains; // Sequence
        char *m_name;
        m_name = self().read_cstring();
        n_args = self().read_int64();
        Vec<arg_t> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, self().deserialize_arg());
        }
        n_attributes = self().read_int64();
        Vec<decl_attribute_t*> v_attributes;
        v_attributes.reserve(al, n_attributes);
        for (size_t i=0; i<n_attributes; i++) {
            v_attributes.push_back(al, AST::down_cast<AST::decl_attribute_t>(self().deserialize_decl_attribute()));
        }
        AST::bind_t *m_bind;
        if (self().read_bool()) {
        m_bind = AST::down_cast<AST::bind_t>(self().deserialize_bind());
        } else {
        m_bind = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        n_use = self().read_int64();
        Vec<unit_decl1_t*> v_use;
        v_use.reserve(al, n_use);
        for (size_t i=0; i<n_use; i++) {
            v_use.push_back(al, AST::down_cast<AST::unit_decl1_t>(self().deserialize_unit_decl1()));
        }
        n_import = self().read_int64();
        Vec<import_statement_t*> v_import;
        v_import.reserve(al, n_import);
        for (size_t i=0; i<n_import; i++) {
            v_import.push_back(al, AST::down_cast<AST::import_statement_t>(self().deserialize_import_statement()));
        }
        n_implicit = self().read_int64();
        Vec<implicit_statement_t*> v_implicit;
        v_implicit.reserve(al, n_implicit);
        for (size_t i=0; i<n_implicit; i++) {
            v_implicit.push_back(al, AST::down_cast<AST::implicit_statement_t>(self().deserialize_implicit_statement()));
        }
        n_decl = self().read_int64();
        Vec<unit_decl2_t*> v_decl;
        v_decl.reserve(al, n_decl);
        for (size_t i=0; i<n_decl; i++) {
            v_decl.push_back(al, AST::down_cast<AST::unit_decl2_t>(self().deserialize_unit_decl2()));
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        n_contains = self().read_int64();
        Vec<program_unit_t*> v_contains;
        v_contains.reserve(al, n_contains);
        for (size_t i=0; i<n_contains; i++) {
            v_contains.push_back(al, AST::down_cast<AST::program_unit_t>(self().deserialize_program_unit()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Subroutine_t(al, loc, m_name, v_args.p, v_args.n, v_attributes.p, v_attributes.n, m_bind, m_trivia, v_use.p, v_use.n, v_import.p, v_import.n, v_implicit.p, v_implicit.n, v_decl.p, v_decl.n, v_body.p, v_body.n, v_contains.p, v_contains.n);
    }
    ast_t* deserialize_Procedure() {
        size_t n_args; // Sequence
        size_t n_attributes; // Sequence
        size_t n_use; // Sequence
        size_t n_import; // Sequence
        size_t n_implicit; // Sequence
        size_t n_decl; // Sequence
        size_t n_body; // Sequence
        size_t n_contains; // Sequence
        char *m_name;
        m_name = self().read_cstring();
        n_args = self().read_int64();
        Vec<arg_t> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, self().deserialize_arg());
        }
        n_attributes = self().read_int64();
        Vec<decl_attribute_t*> v_attributes;
        v_attributes.reserve(al, n_attributes);
        for (size_t i=0; i<n_attributes; i++) {
            v_attributes.push_back(al, AST::down_cast<AST::decl_attribute_t>(self().deserialize_decl_attribute()));
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        n_use = self().read_int64();
        Vec<unit_decl1_t*> v_use;
        v_use.reserve(al, n_use);
        for (size_t i=0; i<n_use; i++) {
            v_use.push_back(al, AST::down_cast<AST::unit_decl1_t>(self().deserialize_unit_decl1()));
        }
        n_import = self().read_int64();
        Vec<import_statement_t*> v_import;
        v_import.reserve(al, n_import);
        for (size_t i=0; i<n_import; i++) {
            v_import.push_back(al, AST::down_cast<AST::import_statement_t>(self().deserialize_import_statement()));
        }
        n_implicit = self().read_int64();
        Vec<implicit_statement_t*> v_implicit;
        v_implicit.reserve(al, n_implicit);
        for (size_t i=0; i<n_implicit; i++) {
            v_implicit.push_back(al, AST::down_cast<AST::implicit_statement_t>(self().deserialize_implicit_statement()));
        }
        n_decl = self().read_int64();
        Vec<unit_decl2_t*> v_decl;
        v_decl.reserve(al, n_decl);
        for (size_t i=0; i<n_decl; i++) {
            v_decl.push_back(al, AST::down_cast<AST::unit_decl2_t>(self().deserialize_unit_decl2()));
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        n_contains = self().read_int64();
        Vec<program_unit_t*> v_contains;
        v_contains.reserve(al, n_contains);
        for (size_t i=0; i<n_contains; i++) {
            v_contains.push_back(al, AST::down_cast<AST::program_unit_t>(self().deserialize_program_unit()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Procedure_t(al, loc, m_name, v_args.p, v_args.n, v_attributes.p, v_attributes.n, m_trivia, v_use.p, v_use.n, v_import.p, v_import.n, v_implicit.p, v_implicit.n, v_decl.p, v_decl.n, v_body.p, v_body.n, v_contains.p, v_contains.n);
    }
    ast_t* deserialize_Function() {
        size_t n_args; // Sequence
        size_t n_attributes; // Sequence
        size_t n_use; // Sequence
        size_t n_import; // Sequence
        size_t n_implicit; // Sequence
        size_t n_decl; // Sequence
        size_t n_body; // Sequence
        size_t n_contains; // Sequence
        char *m_name;
        m_name = self().read_cstring();
        n_args = self().read_int64();
        Vec<arg_t> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, self().deserialize_arg());
        }
        n_attributes = self().read_int64();
        Vec<decl_attribute_t*> v_attributes;
        v_attributes.reserve(al, n_attributes);
        for (size_t i=0; i<n_attributes; i++) {
            v_attributes.push_back(al, AST::down_cast<AST::decl_attribute_t>(self().deserialize_decl_attribute()));
        }
        AST::expr_t *m_return_var;
        if (self().read_bool()) {
        m_return_var = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_return_var = nullptr;
        }
        AST::bind_t *m_bind;
        if (self().read_bool()) {
        m_bind = AST::down_cast<AST::bind_t>(self().deserialize_bind());
        } else {
        m_bind = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        n_use = self().read_int64();
        Vec<unit_decl1_t*> v_use;
        v_use.reserve(al, n_use);
        for (size_t i=0; i<n_use; i++) {
            v_use.push_back(al, AST::down_cast<AST::unit_decl1_t>(self().deserialize_unit_decl1()));
        }
        n_import = self().read_int64();
        Vec<import_statement_t*> v_import;
        v_import.reserve(al, n_import);
        for (size_t i=0; i<n_import; i++) {
            v_import.push_back(al, AST::down_cast<AST::import_statement_t>(self().deserialize_import_statement()));
        }
        n_implicit = self().read_int64();
        Vec<implicit_statement_t*> v_implicit;
        v_implicit.reserve(al, n_implicit);
        for (size_t i=0; i<n_implicit; i++) {
            v_implicit.push_back(al, AST::down_cast<AST::implicit_statement_t>(self().deserialize_implicit_statement()));
        }
        n_decl = self().read_int64();
        Vec<unit_decl2_t*> v_decl;
        v_decl.reserve(al, n_decl);
        for (size_t i=0; i<n_decl; i++) {
            v_decl.push_back(al, AST::down_cast<AST::unit_decl2_t>(self().deserialize_unit_decl2()));
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        n_contains = self().read_int64();
        Vec<program_unit_t*> v_contains;
        v_contains.reserve(al, n_contains);
        for (size_t i=0; i<n_contains; i++) {
            v_contains.push_back(al, AST::down_cast<AST::program_unit_t>(self().deserialize_program_unit()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Function_t(al, loc, m_name, v_args.p, v_args.n, v_attributes.p, v_attributes.n, m_return_var, m_bind, m_trivia, v_use.p, v_use.n, v_import.p, v_import.n, v_implicit.p, v_implicit.n, v_decl.p, v_decl.n, v_body.p, v_body.n, v_contains.p, v_contains.n);
    }
    ast_t* deserialize_program_unit() {
        uint8_t t = self().read_int8();
        AST::program_unitType ty = static_cast<AST::program_unitType>(t);
        switch (ty) {
            case (AST::program_unitType::Subroutine) : return self().deserialize_Subroutine();
            case (AST::program_unitType::Procedure) : return self().deserialize_Procedure();
            case (AST::program_unitType::Function) : return self().deserialize_Function();
            default : throw LFortranException("Unknown type in deserialize_program_unit()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_Use() {
        size_t n_nature; // Sequence
        size_t n_symbols; // Sequence
        n_nature = self().read_int64();
        Vec<decl_attribute_t*> v_nature;
        v_nature.reserve(al, n_nature);
        for (size_t i=0; i<n_nature; i++) {
            v_nature.push_back(al, AST::down_cast<AST::decl_attribute_t>(self().deserialize_decl_attribute()));
        }
        char *m_module;
        m_module = self().read_cstring();
        n_symbols = self().read_int64();
        Vec<use_symbol_t*> v_symbols;
        v_symbols.reserve(al, n_symbols);
        for (size_t i=0; i<n_symbols; i++) {
            v_symbols.push_back(al, AST::down_cast<AST::use_symbol_t>(self().deserialize_use_symbol()));
        }
        bool m_only_present = self().read_bool();
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Use_t(al, loc, v_nature.p, v_nature.n, m_module, v_symbols.p, v_symbols.n, m_only_present, m_trivia);
    }
    ast_t* deserialize_unit_decl1() {
        uint8_t t = self().read_int8();
        AST::unit_decl1Type ty = static_cast<AST::unit_decl1Type>(t);
        switch (ty) {
            case (AST::unit_decl1Type::Use) : return self().deserialize_Use();
            default : throw LFortranException("Unknown type in deserialize_unit_decl1()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_Declaration() {
        size_t n_attributes; // Sequence
        size_t n_syms; // Sequence
        AST::decl_attribute_t *m_vartype;
        if (self().read_bool()) {
        m_vartype = AST::down_cast<AST::decl_attribute_t>(self().deserialize_decl_attribute());
        } else {
        m_vartype = nullptr;
        }
        n_attributes = self().read_int64();
        Vec<decl_attribute_t*> v_attributes;
        v_attributes.reserve(al, n_attributes);
        for (size_t i=0; i<n_attributes; i++) {
            v_attributes.push_back(al, AST::down_cast<AST::decl_attribute_t>(self().deserialize_decl_attribute()));
        }
        n_syms = self().read_int64();
        Vec<var_sym_t> v_syms;
        v_syms.reserve(al, n_syms);
        for (size_t i=0; i<n_syms; i++) {
            v_syms.push_back(al, self().deserialize_var_sym());
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Declaration_t(al, loc, m_vartype, v_attributes.p, v_attributes.n, v_syms.p, v_syms.n, m_trivia);
    }
    ast_t* deserialize_Interface() {
        size_t n_items; // Sequence
        AST::interface_header_t *m_header;
        m_header = AST::down_cast<AST::interface_header_t>(self().deserialize_interface_header());
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        n_items = self().read_int64();
        Vec<interface_item_t*> v_items;
        v_items.reserve(al, n_items);
        for (size_t i=0; i<n_items; i++) {
            v_items.push_back(al, AST::down_cast<AST::interface_item_t>(self().deserialize_interface_item()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Interface_t(al, loc, m_header, m_trivia, v_items.p, v_items.n);
    }
    ast_t* deserialize_DerivedType() {
        size_t n_namelist; // Sequence
        size_t n_attrtype; // Sequence
        size_t n_items; // Sequence
        size_t n_contains; // Sequence
        char *m_name;
        m_name = self().read_cstring();
        n_namelist = self().read_int64();
        Vec<char*> v_namelist;
        v_namelist.reserve(al, n_namelist);
        for (size_t i=0; i<n_namelist; i++) {
            v_namelist.push_back(al, self().read_cstring());
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        n_attrtype = self().read_int64();
        Vec<decl_attribute_t*> v_attrtype;
        v_attrtype.reserve(al, n_attrtype);
        for (size_t i=0; i<n_attrtype; i++) {
            v_attrtype.push_back(al, AST::down_cast<AST::decl_attribute_t>(self().deserialize_decl_attribute()));
        }
        n_items = self().read_int64();
        Vec<unit_decl2_t*> v_items;
        v_items.reserve(al, n_items);
        for (size_t i=0; i<n_items; i++) {
            v_items.push_back(al, AST::down_cast<AST::unit_decl2_t>(self().deserialize_unit_decl2()));
        }
        n_contains = self().read_int64();
        Vec<procedure_decl_t*> v_contains;
        v_contains.reserve(al, n_contains);
        for (size_t i=0; i<n_contains; i++) {
            v_contains.push_back(al, AST::down_cast<AST::procedure_decl_t>(self().deserialize_procedure_decl()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_DerivedType_t(al, loc, m_name, v_namelist.p, v_namelist.n, m_trivia, v_attrtype.p, v_attrtype.n, v_items.p, v_items.n, v_contains.p, v_contains.n);
    }
    ast_t* deserialize_Enum() {
        size_t n_attr; // Sequence
        size_t n_items; // Sequence
        n_attr = self().read_int64();
        Vec<decl_attribute_t*> v_attr;
        v_attr.reserve(al, n_attr);
        for (size_t i=0; i<n_attr; i++) {
            v_attr.push_back(al, AST::down_cast<AST::decl_attribute_t>(self().deserialize_decl_attribute()));
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        n_items = self().read_int64();
        Vec<unit_decl2_t*> v_items;
        v_items.reserve(al, n_items);
        for (size_t i=0; i<n_items; i++) {
            v_items.push_back(al, AST::down_cast<AST::unit_decl2_t>(self().deserialize_unit_decl2()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Enum_t(al, loc, v_attr.p, v_attr.n, m_trivia, v_items.p, v_items.n);
    }
    ast_t* deserialize_unit_decl2() {
        uint8_t t = self().read_int8();
        AST::unit_decl2Type ty = static_cast<AST::unit_decl2Type>(t);
        switch (ty) {
            case (AST::unit_decl2Type::Declaration) : return self().deserialize_Declaration();
            case (AST::unit_decl2Type::Interface) : return self().deserialize_Interface();
            case (AST::unit_decl2Type::DerivedType) : return self().deserialize_DerivedType();
            case (AST::unit_decl2Type::Enum) : return self().deserialize_Enum();
            default : throw LFortranException("Unknown type in deserialize_unit_decl2()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_InterfaceHeader() {
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_InterfaceHeader_t(al, loc);
    }
    ast_t* deserialize_InterfaceHeaderName() {
        char *m_name;
        m_name = self().read_cstring();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_InterfaceHeaderName_t(al, loc, m_name);
    }
    ast_t* deserialize_InterfaceHeaderAssignment() {
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_InterfaceHeaderAssignment_t(al, loc);
    }
    ast_t* deserialize_InterfaceHeaderOperator() {
        AST::intrinsicopType m_op = self().deserialize_intrinsicop();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_InterfaceHeaderOperator_t(al, loc, m_op);
    }
    ast_t* deserialize_InterfaceHeaderDefinedOperator() {
        char *m_operator_name;
        m_operator_name = self().read_cstring();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_InterfaceHeaderDefinedOperator_t(al, loc, m_operator_name);
    }
    ast_t* deserialize_AbstractInterfaceHeader() {
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_AbstractInterfaceHeader_t(al, loc);
    }
    ast_t* deserialize_InterfaceHeaderWrite() {
        char *m_id;
        m_id = self().read_cstring();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_InterfaceHeaderWrite_t(al, loc, m_id);
    }
    ast_t* deserialize_InterfaceHeaderRead() {
        char *m_id;
        m_id = self().read_cstring();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_InterfaceHeaderRead_t(al, loc, m_id);
    }
    ast_t* deserialize_interface_header() {
        uint8_t t = self().read_int8();
        AST::interface_headerType ty = static_cast<AST::interface_headerType>(t);
        switch (ty) {
            case (AST::interface_headerType::InterfaceHeader) : return self().deserialize_InterfaceHeader();
            case (AST::interface_headerType::InterfaceHeaderName) : return self().deserialize_InterfaceHeaderName();
            case (AST::interface_headerType::InterfaceHeaderAssignment) : return self().deserialize_InterfaceHeaderAssignment();
            case (AST::interface_headerType::InterfaceHeaderOperator) : return self().deserialize_InterfaceHeaderOperator();
            case (AST::interface_headerType::InterfaceHeaderDefinedOperator) : return self().deserialize_InterfaceHeaderDefinedOperator();
            case (AST::interface_headerType::AbstractInterfaceHeader) : return self().deserialize_AbstractInterfaceHeader();
            case (AST::interface_headerType::InterfaceHeaderWrite) : return self().deserialize_InterfaceHeaderWrite();
            case (AST::interface_headerType::InterfaceHeaderRead) : return self().deserialize_InterfaceHeaderRead();
            default : throw LFortranException("Unknown type in deserialize_interface_header()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_InterfaceProc() {
        AST::program_unit_t *m_proc;
        m_proc = AST::down_cast<AST::program_unit_t>(self().deserialize_program_unit());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_InterfaceProc_t(al, loc, m_proc);
    }
    ast_t* deserialize_InterfaceModuleProcedure() {
        size_t n_names; // Sequence
        size_t n_attributes; // Sequence
        n_names = self().read_int64();
        Vec<char*> v_names;
        v_names.reserve(al, n_names);
        for (size_t i=0; i<n_names; i++) {
            v_names.push_back(al, self().read_cstring());
        }
        n_attributes = self().read_int64();
        Vec<decl_attribute_t*> v_attributes;
        v_attributes.reserve(al, n_attributes);
        for (size_t i=0; i<n_attributes; i++) {
            v_attributes.push_back(al, AST::down_cast<AST::decl_attribute_t>(self().deserialize_decl_attribute()));
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_InterfaceModuleProcedure_t(al, loc, v_names.p, v_names.n, v_attributes.p, v_attributes.n, m_trivia);
    }
    ast_t* deserialize_interface_item() {
        uint8_t t = self().read_int8();
        AST::interface_itemType ty = static_cast<AST::interface_itemType>(t);
        switch (ty) {
            case (AST::interface_itemType::InterfaceProc) : return self().deserialize_InterfaceProc();
            case (AST::interface_itemType::InterfaceModuleProcedure) : return self().deserialize_InterfaceModuleProcedure();
            default : throw LFortranException("Unknown type in deserialize_interface_item()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_Import() {
        size_t n_symbols; // Sequence
        n_symbols = self().read_int64();
        Vec<char*> v_symbols;
        v_symbols.reserve(al, n_symbols);
        for (size_t i=0; i<n_symbols; i++) {
            v_symbols.push_back(al, self().read_cstring());
        }
        AST::import_modifierType m_mod = self().deserialize_import_modifier();
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Import_t(al, loc, v_symbols.p, v_symbols.n, m_mod, m_trivia);
    }
    ast_t* deserialize_import_statement() {
        uint8_t t = self().read_int8();
        AST::import_statementType ty = static_cast<AST::import_statementType>(t);
        switch (ty) {
            case (AST::import_statementType::Import) : return self().deserialize_Import();
            default : throw LFortranException("Unknown type in deserialize_import_statement()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    import_modifierType deserialize_import_modifier() {
        uint8_t t = self().read_int8();
        import_modifierType ty = static_cast<import_modifierType>(t);
        return ty;
    }
    ast_t* deserialize_ImplicitNone() {
        size_t n_specs; // Sequence
        n_specs = self().read_int64();
        Vec<implicit_none_spec_t*> v_specs;
        v_specs.reserve(al, n_specs);
        for (size_t i=0; i<n_specs; i++) {
            v_specs.push_back(al, AST::down_cast<AST::implicit_none_spec_t>(self().deserialize_implicit_none_spec()));
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_ImplicitNone_t(al, loc, v_specs.p, v_specs.n, m_trivia);
    }
    ast_t* deserialize_Implicit() {
        size_t n_kind; // Sequence
        size_t n_specs; // Sequence
        AST::decl_attribute_t *m_type;
        m_type = AST::down_cast<AST::decl_attribute_t>(self().deserialize_decl_attribute());
        n_kind = self().read_int64();
        Vec<letter_spec_t*> v_kind;
        v_kind.reserve(al, n_kind);
        for (size_t i=0; i<n_kind; i++) {
            v_kind.push_back(al, AST::down_cast<AST::letter_spec_t>(self().deserialize_letter_spec()));
        }
        n_specs = self().read_int64();
        Vec<letter_spec_t*> v_specs;
        v_specs.reserve(al, n_specs);
        for (size_t i=0; i<n_specs; i++) {
            v_specs.push_back(al, AST::down_cast<AST::letter_spec_t>(self().deserialize_letter_spec()));
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Implicit_t(al, loc, m_type, v_kind.p, v_kind.n, v_specs.p, v_specs.n, m_trivia);
    }
    ast_t* deserialize_implicit_statement() {
        uint8_t t = self().read_int8();
        AST::implicit_statementType ty = static_cast<AST::implicit_statementType>(t);
        switch (ty) {
            case (AST::implicit_statementType::ImplicitNone) : return self().deserialize_ImplicitNone();
            case (AST::implicit_statementType::Implicit) : return self().deserialize_Implicit();
            default : throw LFortranException("Unknown type in deserialize_implicit_statement()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_ImplicitNoneExternal() {
        int64_t m_dummy = self().read_int64();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_ImplicitNoneExternal_t(al, loc, m_dummy);
    }
    ast_t* deserialize_ImplicitNoneType() {
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_ImplicitNoneType_t(al, loc);
    }
    ast_t* deserialize_implicit_none_spec() {
        uint8_t t = self().read_int8();
        AST::implicit_none_specType ty = static_cast<AST::implicit_none_specType>(t);
        switch (ty) {
            case (AST::implicit_none_specType::ImplicitNoneExternal) : return self().deserialize_ImplicitNoneExternal();
            case (AST::implicit_none_specType::ImplicitNoneType) : return self().deserialize_ImplicitNoneType();
            default : throw LFortranException("Unknown type in deserialize_implicit_none_spec()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_LetterSpec() {
        char *m_start;
        bool m_start_present = self().read_bool();
        if (m_start_present) {
        m_start = self().read_cstring();
        } else {
        m_start = nullptr;
        }
        char *m_end;
        m_end = self().read_cstring();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_LetterSpec_t(al, loc, m_start, m_end);
    }
    ast_t* deserialize_letter_spec() {
        uint8_t t = self().read_int8();
        AST::letter_specType ty = static_cast<AST::letter_specType>(t);
        switch (ty) {
            case (AST::letter_specType::LetterSpec) : return self().deserialize_LetterSpec();
            default : throw LFortranException("Unknown type in deserialize_letter_spec()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_Allocate() {
        size_t n_args; // Sequence
        size_t n_keywords; // Sequence
        int64_t m_label = self().read_int64();
        n_args = self().read_int64();
        Vec<fnarg_t> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, self().deserialize_fnarg());
        }
        n_keywords = self().read_int64();
        Vec<keyword_t> v_keywords;
        v_keywords.reserve(al, n_keywords);
        for (size_t i=0; i<n_keywords; i++) {
            v_keywords.push_back(al, self().deserialize_keyword());
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Allocate_t(al, loc, m_label, v_args.p, v_args.n, v_keywords.p, v_keywords.n, m_trivia);
    }
    ast_t* deserialize_Assign() {
        int64_t m_label = self().read_int64();
        int64_t m_assign_label = self().read_int64();
        char *m_variable;
        m_variable = self().read_cstring();
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Assign_t(al, loc, m_label, m_assign_label, m_variable, m_trivia);
    }
    ast_t* deserialize_Assignment() {
        int64_t m_label = self().read_int64();
        AST::expr_t *m_target;
        m_target = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        AST::expr_t *m_value;
        m_value = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Assignment_t(al, loc, m_label, m_target, m_value, m_trivia);
    }
    ast_t* deserialize_Associate() {
        int64_t m_label = self().read_int64();
        AST::expr_t *m_target;
        m_target = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        AST::expr_t *m_value;
        m_value = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Associate_t(al, loc, m_label, m_target, m_value, m_trivia);
    }
    ast_t* deserialize_Backspace() {
        size_t n_args; // Sequence
        size_t n_kwargs; // Sequence
        int64_t m_label = self().read_int64();
        n_args = self().read_int64();
        Vec<expr_t*> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, AST::down_cast<AST::expr_t>(self().deserialize_expr()));
        }
        n_kwargs = self().read_int64();
        Vec<keyword_t> v_kwargs;
        v_kwargs.reserve(al, n_kwargs);
        for (size_t i=0; i<n_kwargs; i++) {
            v_kwargs.push_back(al, self().deserialize_keyword());
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Backspace_t(al, loc, m_label, v_args.p, v_args.n, v_kwargs.p, v_kwargs.n, m_trivia);
    }
    ast_t* deserialize_Close() {
        size_t n_args; // Sequence
        size_t n_kwargs; // Sequence
        int64_t m_label = self().read_int64();
        n_args = self().read_int64();
        Vec<expr_t*> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, AST::down_cast<AST::expr_t>(self().deserialize_expr()));
        }
        n_kwargs = self().read_int64();
        Vec<keyword_t> v_kwargs;
        v_kwargs.reserve(al, n_kwargs);
        for (size_t i=0; i<n_kwargs; i++) {
            v_kwargs.push_back(al, self().deserialize_keyword());
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Close_t(al, loc, m_label, v_args.p, v_args.n, v_kwargs.p, v_kwargs.n, m_trivia);
    }
    ast_t* deserialize_Continue() {
        int64_t m_label = self().read_int64();
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Continue_t(al, loc, m_label, m_trivia);
    }
    ast_t* deserialize_Cycle() {
        int64_t m_label = self().read_int64();
        char *m_stmt_name;
        bool m_stmt_name_present = self().read_bool();
        if (m_stmt_name_present) {
        m_stmt_name = self().read_cstring();
        } else {
        m_stmt_name = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Cycle_t(al, loc, m_label, m_stmt_name, m_trivia);
    }
    ast_t* deserialize_Deallocate() {
        size_t n_args; // Sequence
        size_t n_keywords; // Sequence
        int64_t m_label = self().read_int64();
        n_args = self().read_int64();
        Vec<fnarg_t> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, self().deserialize_fnarg());
        }
        n_keywords = self().read_int64();
        Vec<keyword_t> v_keywords;
        v_keywords.reserve(al, n_keywords);
        for (size_t i=0; i<n_keywords; i++) {
            v_keywords.push_back(al, self().deserialize_keyword());
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Deallocate_t(al, loc, m_label, v_args.p, v_args.n, v_keywords.p, v_keywords.n, m_trivia);
    }
    ast_t* deserialize_Endfile() {
        size_t n_args; // Sequence
        size_t n_kwargs; // Sequence
        int64_t m_label = self().read_int64();
        n_args = self().read_int64();
        Vec<expr_t*> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, AST::down_cast<AST::expr_t>(self().deserialize_expr()));
        }
        n_kwargs = self().read_int64();
        Vec<keyword_t> v_kwargs;
        v_kwargs.reserve(al, n_kwargs);
        for (size_t i=0; i<n_kwargs; i++) {
            v_kwargs.push_back(al, self().deserialize_keyword());
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Endfile_t(al, loc, m_label, v_args.p, v_args.n, v_kwargs.p, v_kwargs.n, m_trivia);
    }
    ast_t* deserialize_Entry() {
        size_t n_args; // Sequence
        int64_t m_label = self().read_int64();
        char *m_name;
        m_name = self().read_cstring();
        n_args = self().read_int64();
        Vec<arg_t> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, self().deserialize_arg());
        }
        AST::expr_t *m_return_var;
        if (self().read_bool()) {
        m_return_var = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_return_var = nullptr;
        }
        AST::bind_t *m_bind;
        if (self().read_bool()) {
        m_bind = AST::down_cast<AST::bind_t>(self().deserialize_bind());
        } else {
        m_bind = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Entry_t(al, loc, m_label, m_name, v_args.p, v_args.n, m_return_var, m_bind, m_trivia);
    }
    ast_t* deserialize_ErrorStop() {
        int64_t m_label = self().read_int64();
        AST::expr_t *m_code;
        if (self().read_bool()) {
        m_code = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_code = nullptr;
        }
        AST::expr_t *m_quiet;
        if (self().read_bool()) {
        m_quiet = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_quiet = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_ErrorStop_t(al, loc, m_label, m_code, m_quiet, m_trivia);
    }
    ast_t* deserialize_EventPost() {
        size_t n_stat; // Sequence
        int64_t m_label = self().read_int64();
        AST::expr_t *m_variable;
        m_variable = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        n_stat = self().read_int64();
        Vec<event_attribute_t*> v_stat;
        v_stat.reserve(al, n_stat);
        for (size_t i=0; i<n_stat; i++) {
            v_stat.push_back(al, AST::down_cast<AST::event_attribute_t>(self().deserialize_event_attribute()));
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_EventPost_t(al, loc, m_label, m_variable, v_stat.p, v_stat.n, m_trivia);
    }
    ast_t* deserialize_EventWait() {
        size_t n_spec; // Sequence
        int64_t m_label = self().read_int64();
        AST::expr_t *m_variable;
        m_variable = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        n_spec = self().read_int64();
        Vec<event_attribute_t*> v_spec;
        v_spec.reserve(al, n_spec);
        for (size_t i=0; i<n_spec; i++) {
            v_spec.push_back(al, AST::down_cast<AST::event_attribute_t>(self().deserialize_event_attribute()));
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_EventWait_t(al, loc, m_label, m_variable, v_spec.p, v_spec.n, m_trivia);
    }
    ast_t* deserialize_Exit() {
        int64_t m_label = self().read_int64();
        char *m_stmt_name;
        bool m_stmt_name_present = self().read_bool();
        if (m_stmt_name_present) {
        m_stmt_name = self().read_cstring();
        } else {
        m_stmt_name = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Exit_t(al, loc, m_label, m_stmt_name, m_trivia);
    }
    ast_t* deserialize_Flush() {
        size_t n_args; // Sequence
        size_t n_kwargs; // Sequence
        int64_t m_label = self().read_int64();
        n_args = self().read_int64();
        Vec<expr_t*> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, AST::down_cast<AST::expr_t>(self().deserialize_expr()));
        }
        n_kwargs = self().read_int64();
        Vec<keyword_t> v_kwargs;
        v_kwargs.reserve(al, n_kwargs);
        for (size_t i=0; i<n_kwargs; i++) {
            v_kwargs.push_back(al, self().deserialize_keyword());
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Flush_t(al, loc, m_label, v_args.p, v_args.n, v_kwargs.p, v_kwargs.n, m_trivia);
    }
    ast_t* deserialize_ForAllSingle() {
        size_t n_control; // Sequence
        int64_t m_label = self().read_int64();
        char *m_stmt_name;
        bool m_stmt_name_present = self().read_bool();
        if (m_stmt_name_present) {
        m_stmt_name = self().read_cstring();
        } else {
        m_stmt_name = nullptr;
        }
        n_control = self().read_int64();
        Vec<concurrent_control_t*> v_control;
        v_control.reserve(al, n_control);
        for (size_t i=0; i<n_control; i++) {
            v_control.push_back(al, AST::down_cast<AST::concurrent_control_t>(self().deserialize_concurrent_control()));
        }
        AST::expr_t *m_mask;
        if (self().read_bool()) {
        m_mask = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_mask = nullptr;
        }
        AST::stmt_t *m_assign;
        m_assign = AST::down_cast<AST::stmt_t>(self().deserialize_stmt());
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_ForAllSingle_t(al, loc, m_label, m_stmt_name, v_control.p, v_control.n, m_mask, m_assign, m_trivia);
    }
    ast_t* deserialize_Format() {
        int64_t m_label = self().read_int64();
        char *m_fmt;
        m_fmt = self().read_cstring();
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Format_t(al, loc, m_label, m_fmt, m_trivia);
    }
    ast_t* deserialize_FormTeam() {
        size_t n_sync_stat; // Sequence
        int64_t m_label = self().read_int64();
        AST::expr_t *m_team_number;
        m_team_number = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        char *m_team_var;
        m_team_var = self().read_cstring();
        n_sync_stat = self().read_int64();
        Vec<event_attribute_t*> v_sync_stat;
        v_sync_stat.reserve(al, n_sync_stat);
        for (size_t i=0; i<n_sync_stat; i++) {
            v_sync_stat.push_back(al, AST::down_cast<AST::event_attribute_t>(self().deserialize_event_attribute()));
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_FormTeam_t(al, loc, m_label, m_team_number, m_team_var, v_sync_stat.p, v_sync_stat.n, m_trivia);
    }
    ast_t* deserialize_GoTo() {
        size_t n_labels; // Sequence
        int64_t m_label = self().read_int64();
        char *m_int_var;
        bool m_int_var_present = self().read_bool();
        if (m_int_var_present) {
        m_int_var = self().read_cstring();
        } else {
        m_int_var = nullptr;
        }
        AST::expr_t *m_goto_label;
        if (self().read_bool()) {
        m_goto_label = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_goto_label = nullptr;
        }
        n_labels = self().read_int64();
        Vec<expr_t*> v_labels;
        v_labels.reserve(al, n_labels);
        for (size_t i=0; i<n_labels; i++) {
            v_labels.push_back(al, AST::down_cast<AST::expr_t>(self().deserialize_expr()));
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_GoTo_t(al, loc, m_label, m_int_var, m_goto_label, v_labels.p, v_labels.n, m_trivia);
    }
    ast_t* deserialize_Inquire() {
        size_t n_args; // Sequence
        size_t n_kwargs; // Sequence
        size_t n_values; // Sequence
        int64_t m_label = self().read_int64();
        n_args = self().read_int64();
        Vec<expr_t*> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, AST::down_cast<AST::expr_t>(self().deserialize_expr()));
        }
        n_kwargs = self().read_int64();
        Vec<keyword_t> v_kwargs;
        v_kwargs.reserve(al, n_kwargs);
        for (size_t i=0; i<n_kwargs; i++) {
            v_kwargs.push_back(al, self().deserialize_keyword());
        }
        n_values = self().read_int64();
        Vec<expr_t*> v_values;
        v_values.reserve(al, n_values);
        for (size_t i=0; i<n_values; i++) {
            v_values.push_back(al, AST::down_cast<AST::expr_t>(self().deserialize_expr()));
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Inquire_t(al, loc, m_label, v_args.p, v_args.n, v_kwargs.p, v_kwargs.n, v_values.p, v_values.n, m_trivia);
    }
    ast_t* deserialize_Nullify() {
        size_t n_args; // Sequence
        size_t n_kwargs; // Sequence
        int64_t m_label = self().read_int64();
        n_args = self().read_int64();
        Vec<expr_t*> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, AST::down_cast<AST::expr_t>(self().deserialize_expr()));
        }
        n_kwargs = self().read_int64();
        Vec<keyword_t> v_kwargs;
        v_kwargs.reserve(al, n_kwargs);
        for (size_t i=0; i<n_kwargs; i++) {
            v_kwargs.push_back(al, self().deserialize_keyword());
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Nullify_t(al, loc, m_label, v_args.p, v_args.n, v_kwargs.p, v_kwargs.n, m_trivia);
    }
    ast_t* deserialize_Open() {
        size_t n_args; // Sequence
        size_t n_kwargs; // Sequence
        int64_t m_label = self().read_int64();
        n_args = self().read_int64();
        Vec<expr_t*> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, AST::down_cast<AST::expr_t>(self().deserialize_expr()));
        }
        n_kwargs = self().read_int64();
        Vec<keyword_t> v_kwargs;
        v_kwargs.reserve(al, n_kwargs);
        for (size_t i=0; i<n_kwargs; i++) {
            v_kwargs.push_back(al, self().deserialize_keyword());
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Open_t(al, loc, m_label, v_args.p, v_args.n, v_kwargs.p, v_kwargs.n, m_trivia);
    }
    ast_t* deserialize_Return() {
        int64_t m_label = self().read_int64();
        AST::expr_t *m_value;
        if (self().read_bool()) {
        m_value = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_value = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Return_t(al, loc, m_label, m_value, m_trivia);
    }
    ast_t* deserialize_Print() {
        size_t n_values; // Sequence
        int64_t m_label = self().read_int64();
        AST::expr_t *m_fmt;
        if (self().read_bool()) {
        m_fmt = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_fmt = nullptr;
        }
        n_values = self().read_int64();
        Vec<expr_t*> v_values;
        v_values.reserve(al, n_values);
        for (size_t i=0; i<n_values; i++) {
            v_values.push_back(al, AST::down_cast<AST::expr_t>(self().deserialize_expr()));
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Print_t(al, loc, m_label, m_fmt, v_values.p, v_values.n, m_trivia);
    }
    ast_t* deserialize_Read() {
        size_t n_args; // Sequence
        size_t n_kwargs; // Sequence
        size_t n_values; // Sequence
        int64_t m_label = self().read_int64();
        AST::expr_t *m_format;
        if (self().read_bool()) {
        m_format = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_format = nullptr;
        }
        n_args = self().read_int64();
        Vec<argstar_t> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, self().deserialize_argstar());
        }
        n_kwargs = self().read_int64();
        Vec<kw_argstar_t> v_kwargs;
        v_kwargs.reserve(al, n_kwargs);
        for (size_t i=0; i<n_kwargs; i++) {
            v_kwargs.push_back(al, self().deserialize_kw_argstar());
        }
        n_values = self().read_int64();
        Vec<expr_t*> v_values;
        v_values.reserve(al, n_values);
        for (size_t i=0; i<n_values; i++) {
            v_values.push_back(al, AST::down_cast<AST::expr_t>(self().deserialize_expr()));
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Read_t(al, loc, m_label, m_format, v_args.p, v_args.n, v_kwargs.p, v_kwargs.n, v_values.p, v_values.n, m_trivia);
    }
    ast_t* deserialize_Rewind() {
        size_t n_args; // Sequence
        size_t n_kwargs; // Sequence
        int64_t m_label = self().read_int64();
        n_args = self().read_int64();
        Vec<expr_t*> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, AST::down_cast<AST::expr_t>(self().deserialize_expr()));
        }
        n_kwargs = self().read_int64();
        Vec<keyword_t> v_kwargs;
        v_kwargs.reserve(al, n_kwargs);
        for (size_t i=0; i<n_kwargs; i++) {
            v_kwargs.push_back(al, self().deserialize_keyword());
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Rewind_t(al, loc, m_label, v_args.p, v_args.n, v_kwargs.p, v_kwargs.n, m_trivia);
    }
    ast_t* deserialize_Stop() {
        int64_t m_label = self().read_int64();
        AST::expr_t *m_code;
        if (self().read_bool()) {
        m_code = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_code = nullptr;
        }
        AST::expr_t *m_quiet;
        if (self().read_bool()) {
        m_quiet = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_quiet = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Stop_t(al, loc, m_label, m_code, m_quiet, m_trivia);
    }
    ast_t* deserialize_SubroutineCall() {
        size_t n_member; // Sequence
        size_t n_args; // Sequence
        size_t n_keywords; // Sequence
        int64_t m_label = self().read_int64();
        char *m_name;
        m_name = self().read_cstring();
        n_member = self().read_int64();
        Vec<struct_member_t> v_member;
        v_member.reserve(al, n_member);
        for (size_t i=0; i<n_member; i++) {
            v_member.push_back(al, self().deserialize_struct_member());
        }
        n_args = self().read_int64();
        Vec<fnarg_t> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, self().deserialize_fnarg());
        }
        n_keywords = self().read_int64();
        Vec<keyword_t> v_keywords;
        v_keywords.reserve(al, n_keywords);
        for (size_t i=0; i<n_keywords; i++) {
            v_keywords.push_back(al, self().deserialize_keyword());
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_SubroutineCall_t(al, loc, m_label, m_name, v_member.p, v_member.n, v_args.p, v_args.n, v_keywords.p, v_keywords.n, m_trivia);
    }
    ast_t* deserialize_SyncAll() {
        size_t n_stat; // Sequence
        int64_t m_label = self().read_int64();
        n_stat = self().read_int64();
        Vec<event_attribute_t*> v_stat;
        v_stat.reserve(al, n_stat);
        for (size_t i=0; i<n_stat; i++) {
            v_stat.push_back(al, AST::down_cast<AST::event_attribute_t>(self().deserialize_event_attribute()));
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_SyncAll_t(al, loc, m_label, v_stat.p, v_stat.n, m_trivia);
    }
    ast_t* deserialize_SyncImages() {
        size_t n_stat; // Sequence
        int64_t m_label = self().read_int64();
        AST::expr_t *m_image_set;
        if (self().read_bool()) {
        m_image_set = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_image_set = nullptr;
        }
        AST::symbolType m_sym = self().deserialize_symbol();
        n_stat = self().read_int64();
        Vec<event_attribute_t*> v_stat;
        v_stat.reserve(al, n_stat);
        for (size_t i=0; i<n_stat; i++) {
            v_stat.push_back(al, AST::down_cast<AST::event_attribute_t>(self().deserialize_event_attribute()));
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_SyncImages_t(al, loc, m_label, m_image_set, m_sym, v_stat.p, v_stat.n, m_trivia);
    }
    ast_t* deserialize_SyncMemory() {
        size_t n_stat; // Sequence
        int64_t m_label = self().read_int64();
        n_stat = self().read_int64();
        Vec<event_attribute_t*> v_stat;
        v_stat.reserve(al, n_stat);
        for (size_t i=0; i<n_stat; i++) {
            v_stat.push_back(al, AST::down_cast<AST::event_attribute_t>(self().deserialize_event_attribute()));
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_SyncMemory_t(al, loc, m_label, v_stat.p, v_stat.n, m_trivia);
    }
    ast_t* deserialize_SyncTeam() {
        size_t n_stat; // Sequence
        int64_t m_label = self().read_int64();
        AST::expr_t *m_value;
        m_value = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        n_stat = self().read_int64();
        Vec<event_attribute_t*> v_stat;
        v_stat.reserve(al, n_stat);
        for (size_t i=0; i<n_stat; i++) {
            v_stat.push_back(al, AST::down_cast<AST::event_attribute_t>(self().deserialize_event_attribute()));
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_SyncTeam_t(al, loc, m_label, m_value, v_stat.p, v_stat.n, m_trivia);
    }
    ast_t* deserialize_Write() {
        size_t n_args; // Sequence
        size_t n_kwargs; // Sequence
        size_t n_values; // Sequence
        int64_t m_label = self().read_int64();
        n_args = self().read_int64();
        Vec<argstar_t> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, self().deserialize_argstar());
        }
        n_kwargs = self().read_int64();
        Vec<kw_argstar_t> v_kwargs;
        v_kwargs.reserve(al, n_kwargs);
        for (size_t i=0; i<n_kwargs; i++) {
            v_kwargs.push_back(al, self().deserialize_kw_argstar());
        }
        n_values = self().read_int64();
        Vec<expr_t*> v_values;
        v_values.reserve(al, n_values);
        for (size_t i=0; i<n_values; i++) {
            v_values.push_back(al, AST::down_cast<AST::expr_t>(self().deserialize_expr()));
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Write_t(al, loc, m_label, v_args.p, v_args.n, v_kwargs.p, v_kwargs.n, v_values.p, v_values.n, m_trivia);
    }
    ast_t* deserialize_AssociateBlock() {
        size_t n_syms; // Sequence
        size_t n_body; // Sequence
        int64_t m_label = self().read_int64();
        char *m_stmt_name;
        bool m_stmt_name_present = self().read_bool();
        if (m_stmt_name_present) {
        m_stmt_name = self().read_cstring();
        } else {
        m_stmt_name = nullptr;
        }
        n_syms = self().read_int64();
        Vec<var_sym_t> v_syms;
        v_syms.reserve(al, n_syms);
        for (size_t i=0; i<n_syms; i++) {
            v_syms.push_back(al, self().deserialize_var_sym());
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        AST::trivia_t *m_t_inside;
        if (self().read_bool()) {
        m_t_inside = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_t_inside = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_AssociateBlock_t(al, loc, m_label, m_stmt_name, v_syms.p, v_syms.n, v_body.p, v_body.n, m_t_inside, m_trivia);
    }
    ast_t* deserialize_Block() {
        size_t n_use; // Sequence
        size_t n_import; // Sequence
        size_t n_decl; // Sequence
        size_t n_body; // Sequence
        int64_t m_label = self().read_int64();
        char *m_stmt_name;
        bool m_stmt_name_present = self().read_bool();
        if (m_stmt_name_present) {
        m_stmt_name = self().read_cstring();
        } else {
        m_stmt_name = nullptr;
        }
        n_use = self().read_int64();
        Vec<unit_decl1_t*> v_use;
        v_use.reserve(al, n_use);
        for (size_t i=0; i<n_use; i++) {
            v_use.push_back(al, AST::down_cast<AST::unit_decl1_t>(self().deserialize_unit_decl1()));
        }
        n_import = self().read_int64();
        Vec<import_statement_t*> v_import;
        v_import.reserve(al, n_import);
        for (size_t i=0; i<n_import; i++) {
            v_import.push_back(al, AST::down_cast<AST::import_statement_t>(self().deserialize_import_statement()));
        }
        n_decl = self().read_int64();
        Vec<unit_decl2_t*> v_decl;
        v_decl.reserve(al, n_decl);
        for (size_t i=0; i<n_decl; i++) {
            v_decl.push_back(al, AST::down_cast<AST::unit_decl2_t>(self().deserialize_unit_decl2()));
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        AST::trivia_t *m_t_inside;
        if (self().read_bool()) {
        m_t_inside = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_t_inside = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Block_t(al, loc, m_label, m_stmt_name, v_use.p, v_use.n, v_import.p, v_import.n, v_decl.p, v_decl.n, v_body.p, v_body.n, m_t_inside, m_trivia);
    }
    ast_t* deserialize_ChangeTeam() {
        size_t n_coarray_assoc; // Sequence
        size_t n_sync; // Sequence
        size_t n_body; // Sequence
        size_t n_sync_stat; // Sequence
        int64_t m_label = self().read_int64();
        char *m_stmt_name;
        bool m_stmt_name_present = self().read_bool();
        if (m_stmt_name_present) {
        m_stmt_name = self().read_cstring();
        } else {
        m_stmt_name = nullptr;
        }
        AST::expr_t *m_team_value;
        m_team_value = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        n_coarray_assoc = self().read_int64();
        Vec<team_attribute_t*> v_coarray_assoc;
        v_coarray_assoc.reserve(al, n_coarray_assoc);
        for (size_t i=0; i<n_coarray_assoc; i++) {
            v_coarray_assoc.push_back(al, AST::down_cast<AST::team_attribute_t>(self().deserialize_team_attribute()));
        }
        n_sync = self().read_int64();
        Vec<event_attribute_t*> v_sync;
        v_sync.reserve(al, n_sync);
        for (size_t i=0; i<n_sync; i++) {
            v_sync.push_back(al, AST::down_cast<AST::event_attribute_t>(self().deserialize_event_attribute()));
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        AST::trivia_t *m_t_inside;
        if (self().read_bool()) {
        m_t_inside = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_t_inside = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        n_sync_stat = self().read_int64();
        Vec<event_attribute_t*> v_sync_stat;
        v_sync_stat.reserve(al, n_sync_stat);
        for (size_t i=0; i<n_sync_stat; i++) {
            v_sync_stat.push_back(al, AST::down_cast<AST::event_attribute_t>(self().deserialize_event_attribute()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_ChangeTeam_t(al, loc, m_label, m_stmt_name, m_team_value, v_coarray_assoc.p, v_coarray_assoc.n, v_sync.p, v_sync.n, v_body.p, v_body.n, m_t_inside, m_trivia, v_sync_stat.p, v_sync_stat.n);
    }
    ast_t* deserialize_Critical() {
        size_t n_sync_stat; // Sequence
        size_t n_body; // Sequence
        int64_t m_label = self().read_int64();
        char *m_stmt_name;
        bool m_stmt_name_present = self().read_bool();
        if (m_stmt_name_present) {
        m_stmt_name = self().read_cstring();
        } else {
        m_stmt_name = nullptr;
        }
        n_sync_stat = self().read_int64();
        Vec<event_attribute_t*> v_sync_stat;
        v_sync_stat.reserve(al, n_sync_stat);
        for (size_t i=0; i<n_sync_stat; i++) {
            v_sync_stat.push_back(al, AST::down_cast<AST::event_attribute_t>(self().deserialize_event_attribute()));
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        AST::trivia_t *m_t_inside;
        if (self().read_bool()) {
        m_t_inside = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_t_inside = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Critical_t(al, loc, m_label, m_stmt_name, v_sync_stat.p, v_sync_stat.n, v_body.p, v_body.n, m_t_inside, m_trivia);
    }
    ast_t* deserialize_DoConcurrentLoop() {
        size_t n_control; // Sequence
        size_t n_locality; // Sequence
        size_t n_body; // Sequence
        int64_t m_label = self().read_int64();
        char *m_stmt_name;
        bool m_stmt_name_present = self().read_bool();
        if (m_stmt_name_present) {
        m_stmt_name = self().read_cstring();
        } else {
        m_stmt_name = nullptr;
        }
        n_control = self().read_int64();
        Vec<concurrent_control_t*> v_control;
        v_control.reserve(al, n_control);
        for (size_t i=0; i<n_control; i++) {
            v_control.push_back(al, AST::down_cast<AST::concurrent_control_t>(self().deserialize_concurrent_control()));
        }
        AST::expr_t *m_mask;
        if (self().read_bool()) {
        m_mask = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_mask = nullptr;
        }
        n_locality = self().read_int64();
        Vec<concurrent_locality_t*> v_locality;
        v_locality.reserve(al, n_locality);
        for (size_t i=0; i<n_locality; i++) {
            v_locality.push_back(al, AST::down_cast<AST::concurrent_locality_t>(self().deserialize_concurrent_locality()));
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        AST::trivia_t *m_t_inside;
        if (self().read_bool()) {
        m_t_inside = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_t_inside = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_DoConcurrentLoop_t(al, loc, m_label, m_stmt_name, v_control.p, v_control.n, m_mask, v_locality.p, v_locality.n, v_body.p, v_body.n, m_t_inside, m_trivia);
    }
    ast_t* deserialize_DoLoop() {
        size_t n_body; // Sequence
        int64_t m_label = self().read_int64();
        char *m_stmt_name;
        bool m_stmt_name_present = self().read_bool();
        if (m_stmt_name_present) {
        m_stmt_name = self().read_cstring();
        } else {
        m_stmt_name = nullptr;
        }
        int64_t m_do_label = self().read_int64();
        char *m_var;
        bool m_var_present = self().read_bool();
        if (m_var_present) {
        m_var = self().read_cstring();
        } else {
        m_var = nullptr;
        }
        AST::expr_t *m_start;
        if (self().read_bool()) {
        m_start = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_start = nullptr;
        }
        AST::expr_t *m_end;
        if (self().read_bool()) {
        m_end = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_end = nullptr;
        }
        AST::expr_t *m_increment;
        if (self().read_bool()) {
        m_increment = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_increment = nullptr;
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        AST::trivia_t *m_t_inside;
        if (self().read_bool()) {
        m_t_inside = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_t_inside = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_DoLoop_t(al, loc, m_label, m_stmt_name, m_do_label, m_var, m_start, m_end, m_increment, v_body.p, v_body.n, m_t_inside, m_trivia);
    }
    ast_t* deserialize_ForAll() {
        size_t n_control; // Sequence
        size_t n_locality; // Sequence
        size_t n_body; // Sequence
        int64_t m_label = self().read_int64();
        char *m_stmt_name;
        bool m_stmt_name_present = self().read_bool();
        if (m_stmt_name_present) {
        m_stmt_name = self().read_cstring();
        } else {
        m_stmt_name = nullptr;
        }
        n_control = self().read_int64();
        Vec<concurrent_control_t*> v_control;
        v_control.reserve(al, n_control);
        for (size_t i=0; i<n_control; i++) {
            v_control.push_back(al, AST::down_cast<AST::concurrent_control_t>(self().deserialize_concurrent_control()));
        }
        AST::expr_t *m_mask;
        if (self().read_bool()) {
        m_mask = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_mask = nullptr;
        }
        n_locality = self().read_int64();
        Vec<concurrent_locality_t*> v_locality;
        v_locality.reserve(al, n_locality);
        for (size_t i=0; i<n_locality; i++) {
            v_locality.push_back(al, AST::down_cast<AST::concurrent_locality_t>(self().deserialize_concurrent_locality()));
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        AST::trivia_t *m_t_inside;
        if (self().read_bool()) {
        m_t_inside = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_t_inside = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_ForAll_t(al, loc, m_label, m_stmt_name, v_control.p, v_control.n, m_mask, v_locality.p, v_locality.n, v_body.p, v_body.n, m_t_inside, m_trivia);
    }
    ast_t* deserialize_If() {
        size_t n_body; // Sequence
        size_t n_orelse; // Sequence
        int64_t m_label = self().read_int64();
        char *m_stmt_name;
        bool m_stmt_name_present = self().read_bool();
        if (m_stmt_name_present) {
        m_stmt_name = self().read_cstring();
        } else {
        m_stmt_name = nullptr;
        }
        AST::expr_t *m_test;
        m_test = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        n_orelse = self().read_int64();
        Vec<stmt_t*> v_orelse;
        v_orelse.reserve(al, n_orelse);
        for (size_t i=0; i<n_orelse; i++) {
            v_orelse.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        AST::trivia_t *m_if_trivia;
        if (self().read_bool()) {
        m_if_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_if_trivia = nullptr;
        }
        AST::trivia_t *m_else_trivia;
        if (self().read_bool()) {
        m_else_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_else_trivia = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_If_t(al, loc, m_label, m_stmt_name, m_test, v_body.p, v_body.n, v_orelse.p, v_orelse.n, m_if_trivia, m_else_trivia, m_trivia);
    }
    ast_t* deserialize_IfArithmetic() {
        int64_t m_label = self().read_int64();
        char *m_stmt_name;
        bool m_stmt_name_present = self().read_bool();
        if (m_stmt_name_present) {
        m_stmt_name = self().read_cstring();
        } else {
        m_stmt_name = nullptr;
        }
        AST::expr_t *m_test;
        m_test = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        int64_t m_lt_label = self().read_int64();
        int64_t m_eq_label = self().read_int64();
        int64_t m_gt_label = self().read_int64();
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_IfArithmetic_t(al, loc, m_label, m_stmt_name, m_test, m_lt_label, m_eq_label, m_gt_label, m_trivia);
    }
    ast_t* deserialize_Select() {
        size_t n_body; // Sequence
        int64_t m_label = self().read_int64();
        char *m_stmt_name;
        bool m_stmt_name_present = self().read_bool();
        if (m_stmt_name_present) {
        m_stmt_name = self().read_cstring();
        } else {
        m_stmt_name = nullptr;
        }
        AST::expr_t *m_test;
        m_test = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        n_body = self().read_int64();
        Vec<case_stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::case_stmt_t>(self().deserialize_case_stmt()));
        }
        AST::trivia_t *m_t_inside;
        if (self().read_bool()) {
        m_t_inside = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_t_inside = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Select_t(al, loc, m_label, m_stmt_name, m_test, v_body.p, v_body.n, m_t_inside, m_trivia);
    }
    ast_t* deserialize_SelectRank() {
        size_t n_body; // Sequence
        int64_t m_label = self().read_int64();
        char *m_stmt_name;
        bool m_stmt_name_present = self().read_bool();
        if (m_stmt_name_present) {
        m_stmt_name = self().read_cstring();
        } else {
        m_stmt_name = nullptr;
        }
        char *m_assoc_name;
        bool m_assoc_name_present = self().read_bool();
        if (m_assoc_name_present) {
        m_assoc_name = self().read_cstring();
        } else {
        m_assoc_name = nullptr;
        }
        AST::expr_t *m_selector;
        m_selector = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        n_body = self().read_int64();
        Vec<rank_stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::rank_stmt_t>(self().deserialize_rank_stmt()));
        }
        AST::trivia_t *m_t_inside;
        if (self().read_bool()) {
        m_t_inside = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_t_inside = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_SelectRank_t(al, loc, m_label, m_stmt_name, m_assoc_name, m_selector, v_body.p, v_body.n, m_t_inside, m_trivia);
    }
    ast_t* deserialize_SelectType() {
        size_t n_body; // Sequence
        int64_t m_label = self().read_int64();
        char *m_stmt_name;
        bool m_stmt_name_present = self().read_bool();
        if (m_stmt_name_present) {
        m_stmt_name = self().read_cstring();
        } else {
        m_stmt_name = nullptr;
        }
        char *m_assoc_name;
        bool m_assoc_name_present = self().read_bool();
        if (m_assoc_name_present) {
        m_assoc_name = self().read_cstring();
        } else {
        m_assoc_name = nullptr;
        }
        AST::expr_t *m_selector;
        m_selector = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        n_body = self().read_int64();
        Vec<type_stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::type_stmt_t>(self().deserialize_type_stmt()));
        }
        AST::trivia_t *m_t_inside;
        if (self().read_bool()) {
        m_t_inside = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_t_inside = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_SelectType_t(al, loc, m_label, m_stmt_name, m_assoc_name, m_selector, v_body.p, v_body.n, m_t_inside, m_trivia);
    }
    ast_t* deserialize_Where() {
        size_t n_body; // Sequence
        size_t n_orelse; // Sequence
        int64_t m_label = self().read_int64();
        char *m_stmt_name;
        bool m_stmt_name_present = self().read_bool();
        if (m_stmt_name_present) {
        m_stmt_name = self().read_cstring();
        } else {
        m_stmt_name = nullptr;
        }
        AST::expr_t *m_test;
        m_test = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        n_orelse = self().read_int64();
        Vec<stmt_t*> v_orelse;
        v_orelse.reserve(al, n_orelse);
        for (size_t i=0; i<n_orelse; i++) {
            v_orelse.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        AST::trivia_t *m_t_inside;
        if (self().read_bool()) {
        m_t_inside = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_t_inside = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Where_t(al, loc, m_label, m_stmt_name, m_test, v_body.p, v_body.n, v_orelse.p, v_orelse.n, m_t_inside, m_trivia);
    }
    ast_t* deserialize_WhileLoop() {
        size_t n_body; // Sequence
        int64_t m_label = self().read_int64();
        char *m_stmt_name;
        bool m_stmt_name_present = self().read_bool();
        if (m_stmt_name_present) {
        m_stmt_name = self().read_cstring();
        } else {
        m_stmt_name = nullptr;
        }
        AST::expr_t *m_test;
        m_test = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        AST::trivia_t *m_t_inside;
        if (self().read_bool()) {
        m_t_inside = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_t_inside = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_WhileLoop_t(al, loc, m_label, m_stmt_name, m_test, v_body.p, v_body.n, m_t_inside, m_trivia);
    }
    ast_t* deserialize_stmt() {
        uint8_t t = self().read_int8();
        AST::stmtType ty = static_cast<AST::stmtType>(t);
        switch (ty) {
            case (AST::stmtType::Allocate) : return self().deserialize_Allocate();
            case (AST::stmtType::Assign) : return self().deserialize_Assign();
            case (AST::stmtType::Assignment) : return self().deserialize_Assignment();
            case (AST::stmtType::Associate) : return self().deserialize_Associate();
            case (AST::stmtType::Backspace) : return self().deserialize_Backspace();
            case (AST::stmtType::Close) : return self().deserialize_Close();
            case (AST::stmtType::Continue) : return self().deserialize_Continue();
            case (AST::stmtType::Cycle) : return self().deserialize_Cycle();
            case (AST::stmtType::Deallocate) : return self().deserialize_Deallocate();
            case (AST::stmtType::Endfile) : return self().deserialize_Endfile();
            case (AST::stmtType::Entry) : return self().deserialize_Entry();
            case (AST::stmtType::ErrorStop) : return self().deserialize_ErrorStop();
            case (AST::stmtType::EventPost) : return self().deserialize_EventPost();
            case (AST::stmtType::EventWait) : return self().deserialize_EventWait();
            case (AST::stmtType::Exit) : return self().deserialize_Exit();
            case (AST::stmtType::Flush) : return self().deserialize_Flush();
            case (AST::stmtType::ForAllSingle) : return self().deserialize_ForAllSingle();
            case (AST::stmtType::Format) : return self().deserialize_Format();
            case (AST::stmtType::FormTeam) : return self().deserialize_FormTeam();
            case (AST::stmtType::GoTo) : return self().deserialize_GoTo();
            case (AST::stmtType::Inquire) : return self().deserialize_Inquire();
            case (AST::stmtType::Nullify) : return self().deserialize_Nullify();
            case (AST::stmtType::Open) : return self().deserialize_Open();
            case (AST::stmtType::Return) : return self().deserialize_Return();
            case (AST::stmtType::Print) : return self().deserialize_Print();
            case (AST::stmtType::Read) : return self().deserialize_Read();
            case (AST::stmtType::Rewind) : return self().deserialize_Rewind();
            case (AST::stmtType::Stop) : return self().deserialize_Stop();
            case (AST::stmtType::SubroutineCall) : return self().deserialize_SubroutineCall();
            case (AST::stmtType::SyncAll) : return self().deserialize_SyncAll();
            case (AST::stmtType::SyncImages) : return self().deserialize_SyncImages();
            case (AST::stmtType::SyncMemory) : return self().deserialize_SyncMemory();
            case (AST::stmtType::SyncTeam) : return self().deserialize_SyncTeam();
            case (AST::stmtType::Write) : return self().deserialize_Write();
            case (AST::stmtType::AssociateBlock) : return self().deserialize_AssociateBlock();
            case (AST::stmtType::Block) : return self().deserialize_Block();
            case (AST::stmtType::ChangeTeam) : return self().deserialize_ChangeTeam();
            case (AST::stmtType::Critical) : return self().deserialize_Critical();
            case (AST::stmtType::DoConcurrentLoop) : return self().deserialize_DoConcurrentLoop();
            case (AST::stmtType::DoLoop) : return self().deserialize_DoLoop();
            case (AST::stmtType::ForAll) : return self().deserialize_ForAll();
            case (AST::stmtType::If) : return self().deserialize_If();
            case (AST::stmtType::IfArithmetic) : return self().deserialize_IfArithmetic();
            case (AST::stmtType::Select) : return self().deserialize_Select();
            case (AST::stmtType::SelectRank) : return self().deserialize_SelectRank();
            case (AST::stmtType::SelectType) : return self().deserialize_SelectType();
            case (AST::stmtType::Where) : return self().deserialize_Where();
            case (AST::stmtType::WhileLoop) : return self().deserialize_WhileLoop();
            default : throw LFortranException("Unknown type in deserialize_stmt()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_BoolOp() {
        AST::expr_t *m_left;
        m_left = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        AST::boolopType m_op = self().deserialize_boolop();
        AST::expr_t *m_right;
        m_right = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_BoolOp_t(al, loc, m_left, m_op, m_right);
    }
    ast_t* deserialize_BinOp() {
        AST::expr_t *m_left;
        m_left = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        AST::operatorType m_op = self().deserialize_operator();
        AST::expr_t *m_right;
        m_right = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_BinOp_t(al, loc, m_left, m_op, m_right);
    }
    ast_t* deserialize_DefBinOp() {
        AST::expr_t *m_left;
        m_left = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        char *m_op;
        m_op = self().read_cstring();
        AST::expr_t *m_right;
        m_right = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_DefBinOp_t(al, loc, m_left, m_op, m_right);
    }
    ast_t* deserialize_StrOp() {
        AST::expr_t *m_left;
        m_left = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        AST::stroperatorType m_op = self().deserialize_stroperator();
        AST::expr_t *m_right;
        m_right = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_StrOp_t(al, loc, m_left, m_op, m_right);
    }
    ast_t* deserialize_UnaryOp() {
        AST::unaryopType m_op = self().deserialize_unaryop();
        AST::expr_t *m_operand;
        m_operand = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_UnaryOp_t(al, loc, m_op, m_operand);
    }
    ast_t* deserialize_DefUnaryOp() {
        char *m_op;
        m_op = self().read_cstring();
        AST::expr_t *m_operand;
        m_operand = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_DefUnaryOp_t(al, loc, m_op, m_operand);
    }
    ast_t* deserialize_Compare() {
        AST::expr_t *m_left;
        m_left = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        AST::cmpopType m_op = self().deserialize_cmpop();
        AST::expr_t *m_right;
        m_right = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Compare_t(al, loc, m_left, m_op, m_right);
    }
    ast_t* deserialize_FuncCallOrArray() {
        size_t n_member; // Sequence
        size_t n_args; // Sequence
        size_t n_keywords; // Sequence
        size_t n_subargs; // Sequence
        char *m_func;
        m_func = self().read_cstring();
        n_member = self().read_int64();
        Vec<struct_member_t> v_member;
        v_member.reserve(al, n_member);
        for (size_t i=0; i<n_member; i++) {
            v_member.push_back(al, self().deserialize_struct_member());
        }
        n_args = self().read_int64();
        Vec<fnarg_t> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, self().deserialize_fnarg());
        }
        n_keywords = self().read_int64();
        Vec<keyword_t> v_keywords;
        v_keywords.reserve(al, n_keywords);
        for (size_t i=0; i<n_keywords; i++) {
            v_keywords.push_back(al, self().deserialize_keyword());
        }
        n_subargs = self().read_int64();
        Vec<fnarg_t> v_subargs;
        v_subargs.reserve(al, n_subargs);
        for (size_t i=0; i<n_subargs; i++) {
            v_subargs.push_back(al, self().deserialize_fnarg());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_FuncCallOrArray_t(al, loc, m_func, v_member.p, v_member.n, v_args.p, v_args.n, v_keywords.p, v_keywords.n, v_subargs.p, v_subargs.n);
    }
    ast_t* deserialize_CoarrayRef() {
        size_t n_member; // Sequence
        size_t n_args; // Sequence
        size_t n_fnkw; // Sequence
        size_t n_coargs; // Sequence
        size_t n_cokw; // Sequence
        char *m_name;
        m_name = self().read_cstring();
        n_member = self().read_int64();
        Vec<struct_member_t> v_member;
        v_member.reserve(al, n_member);
        for (size_t i=0; i<n_member; i++) {
            v_member.push_back(al, self().deserialize_struct_member());
        }
        n_args = self().read_int64();
        Vec<fnarg_t> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, self().deserialize_fnarg());
        }
        n_fnkw = self().read_int64();
        Vec<keyword_t> v_fnkw;
        v_fnkw.reserve(al, n_fnkw);
        for (size_t i=0; i<n_fnkw; i++) {
            v_fnkw.push_back(al, self().deserialize_keyword());
        }
        n_coargs = self().read_int64();
        Vec<coarrayarg_t> v_coargs;
        v_coargs.reserve(al, n_coargs);
        for (size_t i=0; i<n_coargs; i++) {
            v_coargs.push_back(al, self().deserialize_coarrayarg());
        }
        n_cokw = self().read_int64();
        Vec<keyword_t> v_cokw;
        v_cokw.reserve(al, n_cokw);
        for (size_t i=0; i<n_cokw; i++) {
            v_cokw.push_back(al, self().deserialize_keyword());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_CoarrayRef_t(al, loc, m_name, v_member.p, v_member.n, v_args.p, v_args.n, v_fnkw.p, v_fnkw.n, v_coargs.p, v_coargs.n, v_cokw.p, v_cokw.n);
    }
    ast_t* deserialize_ArrayInitializer() {
        size_t n_args; // Sequence
        AST::decl_attribute_t *m_vartype;
        if (self().read_bool()) {
        m_vartype = AST::down_cast<AST::decl_attribute_t>(self().deserialize_decl_attribute());
        } else {
        m_vartype = nullptr;
        }
        char *m_classtype;
        bool m_classtype_present = self().read_bool();
        if (m_classtype_present) {
        m_classtype = self().read_cstring();
        } else {
        m_classtype = nullptr;
        }
        n_args = self().read_int64();
        Vec<expr_t*> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, AST::down_cast<AST::expr_t>(self().deserialize_expr()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_ArrayInitializer_t(al, loc, m_vartype, m_classtype, v_args.p, v_args.n);
    }
    ast_t* deserialize_ImpliedDoLoop() {
        size_t n_values; // Sequence
        n_values = self().read_int64();
        Vec<expr_t*> v_values;
        v_values.reserve(al, n_values);
        for (size_t i=0; i<n_values; i++) {
            v_values.push_back(al, AST::down_cast<AST::expr_t>(self().deserialize_expr()));
        }
        char *m_var;
        m_var = self().read_cstring();
        AST::expr_t *m_start;
        m_start = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        AST::expr_t *m_end;
        m_end = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        AST::expr_t *m_increment;
        if (self().read_bool()) {
        m_increment = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_increment = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_ImpliedDoLoop_t(al, loc, v_values.p, v_values.n, m_var, m_start, m_end, m_increment);
    }
    ast_t* deserialize_Num() {
        int64_t m_n = self().read_int64();
        char *m_kind;
        bool m_kind_present = self().read_bool();
        if (m_kind_present) {
        m_kind = self().read_cstring();
        } else {
        m_kind = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Num_t(al, loc, m_n, m_kind);
    }
    ast_t* deserialize_Real() {
        char *m_n;
        m_n = self().read_cstring();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Real_t(al, loc, m_n);
    }
    ast_t* deserialize_Complex() {
        AST::expr_t *m_re;
        m_re = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        AST::expr_t *m_im;
        m_im = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Complex_t(al, loc, m_re, m_im);
    }
    ast_t* deserialize_String() {
        char *m_s;
        m_s = self().read_cstring();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_String_t(al, loc, m_s);
    }
    ast_t* deserialize_Substring() {
        size_t n_args; // Sequence
        char *m_s;
        m_s = self().read_cstring();
        n_args = self().read_int64();
        Vec<fnarg_t> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, self().deserialize_fnarg());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Substring_t(al, loc, m_s, v_args.p, v_args.n);
    }
    ast_t* deserialize_BOZ() {
        char *m_s;
        m_s = self().read_cstring();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_BOZ_t(al, loc, m_s);
    }
    ast_t* deserialize_Name() {
        size_t n_member; // Sequence
        char *m_id;
        m_id = self().read_cstring();
        n_member = self().read_int64();
        Vec<struct_member_t> v_member;
        v_member.reserve(al, n_member);
        for (size_t i=0; i<n_member; i++) {
            v_member.push_back(al, self().deserialize_struct_member());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Name_t(al, loc, m_id, v_member.p, v_member.n);
    }
    ast_t* deserialize_Logical() {
        bool m_value = self().read_bool();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Logical_t(al, loc, m_value);
    }
    ast_t* deserialize_DataImpliedDo() {
        size_t n_object_list; // Sequence
        n_object_list = self().read_int64();
        Vec<expr_t*> v_object_list;
        v_object_list.reserve(al, n_object_list);
        for (size_t i=0; i<n_object_list; i++) {
            v_object_list.push_back(al, AST::down_cast<AST::expr_t>(self().deserialize_expr()));
        }
        AST::decl_attribute_t *m_type;
        if (self().read_bool()) {
        m_type = AST::down_cast<AST::decl_attribute_t>(self().deserialize_decl_attribute());
        } else {
        m_type = nullptr;
        }
        char *m_var;
        m_var = self().read_cstring();
        AST::expr_t *m_start;
        m_start = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        AST::expr_t *m_end;
        m_end = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        AST::expr_t *m_increment;
        if (self().read_bool()) {
        m_increment = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_increment = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_DataImpliedDo_t(al, loc, v_object_list.p, v_object_list.n, m_type, m_var, m_start, m_end, m_increment);
    }
    ast_t* deserialize_Parenthesis() {
        AST::expr_t *m_operand;
        m_operand = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Parenthesis_t(al, loc, m_operand);
    }
    ast_t* deserialize_expr() {
        uint8_t t = self().read_int8();
        AST::exprType ty = static_cast<AST::exprType>(t);
        switch (ty) {
            case (AST::exprType::BoolOp) : return self().deserialize_BoolOp();
            case (AST::exprType::BinOp) : return self().deserialize_BinOp();
            case (AST::exprType::DefBinOp) : return self().deserialize_DefBinOp();
            case (AST::exprType::StrOp) : return self().deserialize_StrOp();
            case (AST::exprType::UnaryOp) : return self().deserialize_UnaryOp();
            case (AST::exprType::DefUnaryOp) : return self().deserialize_DefUnaryOp();
            case (AST::exprType::Compare) : return self().deserialize_Compare();
            case (AST::exprType::FuncCallOrArray) : return self().deserialize_FuncCallOrArray();
            case (AST::exprType::CoarrayRef) : return self().deserialize_CoarrayRef();
            case (AST::exprType::ArrayInitializer) : return self().deserialize_ArrayInitializer();
            case (AST::exprType::ImpliedDoLoop) : return self().deserialize_ImpliedDoLoop();
            case (AST::exprType::Num) : return self().deserialize_Num();
            case (AST::exprType::Real) : return self().deserialize_Real();
            case (AST::exprType::Complex) : return self().deserialize_Complex();
            case (AST::exprType::String) : return self().deserialize_String();
            case (AST::exprType::Substring) : return self().deserialize_Substring();
            case (AST::exprType::BOZ) : return self().deserialize_BOZ();
            case (AST::exprType::Name) : return self().deserialize_Name();
            case (AST::exprType::Logical) : return self().deserialize_Logical();
            case (AST::exprType::DataImpliedDo) : return self().deserialize_DataImpliedDo();
            case (AST::exprType::Parenthesis) : return self().deserialize_Parenthesis();
            default : throw LFortranException("Unknown type in deserialize_expr()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_TriviaNode() {
        size_t n_inside; // Sequence
        size_t n_after; // Sequence
        n_inside = self().read_int64();
        Vec<trivia_node_t*> v_inside;
        v_inside.reserve(al, n_inside);
        for (size_t i=0; i<n_inside; i++) {
            v_inside.push_back(al, AST::down_cast<AST::trivia_node_t>(self().deserialize_trivia_node()));
        }
        n_after = self().read_int64();
        Vec<trivia_node_t*> v_after;
        v_after.reserve(al, n_after);
        for (size_t i=0; i<n_after; i++) {
            v_after.push_back(al, AST::down_cast<AST::trivia_node_t>(self().deserialize_trivia_node()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_TriviaNode_t(al, loc, v_inside.p, v_inside.n, v_after.p, v_after.n);
    }
    ast_t* deserialize_trivia() {
        uint8_t t = self().read_int8();
        AST::triviaType ty = static_cast<AST::triviaType>(t);
        switch (ty) {
            case (AST::triviaType::TriviaNode) : return self().deserialize_TriviaNode();
            default : throw LFortranException("Unknown type in deserialize_trivia()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_Comment() {
        char *m_comment;
        m_comment = self().read_cstring();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Comment_t(al, loc, m_comment);
    }
    ast_t* deserialize_EOLComment() {
        char *m_comment;
        m_comment = self().read_cstring();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_EOLComment_t(al, loc, m_comment);
    }
    ast_t* deserialize_EndOfLine() {
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_EndOfLine_t(al, loc);
    }
    ast_t* deserialize_Semicolon() {
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Semicolon_t(al, loc);
    }
    ast_t* deserialize_trivia_node() {
        uint8_t t = self().read_int8();
        AST::trivia_nodeType ty = static_cast<AST::trivia_nodeType>(t);
        switch (ty) {
            case (AST::trivia_nodeType::Comment) : return self().deserialize_Comment();
            case (AST::trivia_nodeType::EOLComment) : return self().deserialize_EOLComment();
            case (AST::trivia_nodeType::EndOfLine) : return self().deserialize_EndOfLine();
            case (AST::trivia_nodeType::Semicolon) : return self().deserialize_Semicolon();
            default : throw LFortranException("Unknown type in deserialize_trivia_node()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    boolopType deserialize_boolop() {
        uint8_t t = self().read_int8();
        boolopType ty = static_cast<boolopType>(t);
        return ty;
    }
    operatorType deserialize_operator() {
        uint8_t t = self().read_int8();
        operatorType ty = static_cast<operatorType>(t);
        return ty;
    }
    stroperatorType deserialize_stroperator() {
        uint8_t t = self().read_int8();
        stroperatorType ty = static_cast<stroperatorType>(t);
        return ty;
    }
    unaryopType deserialize_unaryop() {
        uint8_t t = self().read_int8();
        unaryopType ty = static_cast<unaryopType>(t);
        return ty;
    }
    cmpopType deserialize_cmpop() {
        uint8_t t = self().read_int8();
        cmpopType ty = static_cast<cmpopType>(t);
        return ty;
    }
    intrinsicopType deserialize_intrinsicop() {
        uint8_t t = self().read_int8();
        intrinsicopType ty = static_cast<intrinsicopType>(t);
        return ty;
    }
    ast_t* deserialize_DerivedTypeProc() {
        size_t n_attr; // Sequence
        size_t n_symbols; // Sequence
        char *m_name;
        bool m_name_present = self().read_bool();
        if (m_name_present) {
        m_name = self().read_cstring();
        } else {
        m_name = nullptr;
        }
        n_attr = self().read_int64();
        Vec<decl_attribute_t*> v_attr;
        v_attr.reserve(al, n_attr);
        for (size_t i=0; i<n_attr; i++) {
            v_attr.push_back(al, AST::down_cast<AST::decl_attribute_t>(self().deserialize_decl_attribute()));
        }
        n_symbols = self().read_int64();
        Vec<use_symbol_t*> v_symbols;
        v_symbols.reserve(al, n_symbols);
        for (size_t i=0; i<n_symbols; i++) {
            v_symbols.push_back(al, AST::down_cast<AST::use_symbol_t>(self().deserialize_use_symbol()));
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_DerivedTypeProc_t(al, loc, m_name, v_attr.p, v_attr.n, v_symbols.p, v_symbols.n, m_trivia);
    }
    ast_t* deserialize_GenericOperator() {
        size_t n_attr; // Sequence
        size_t n_names; // Sequence
        n_attr = self().read_int64();
        Vec<decl_attribute_t*> v_attr;
        v_attr.reserve(al, n_attr);
        for (size_t i=0; i<n_attr; i++) {
            v_attr.push_back(al, AST::down_cast<AST::decl_attribute_t>(self().deserialize_decl_attribute()));
        }
        AST::intrinsicopType m_op = self().deserialize_intrinsicop();
        n_names = self().read_int64();
        Vec<char*> v_names;
        v_names.reserve(al, n_names);
        for (size_t i=0; i<n_names; i++) {
            v_names.push_back(al, self().read_cstring());
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_GenericOperator_t(al, loc, v_attr.p, v_attr.n, m_op, v_names.p, v_names.n, m_trivia);
    }
    ast_t* deserialize_GenericDefinedOperator() {
        size_t n_attr; // Sequence
        size_t n_names; // Sequence
        n_attr = self().read_int64();
        Vec<decl_attribute_t*> v_attr;
        v_attr.reserve(al, n_attr);
        for (size_t i=0; i<n_attr; i++) {
            v_attr.push_back(al, AST::down_cast<AST::decl_attribute_t>(self().deserialize_decl_attribute()));
        }
        char *m_optype;
        m_optype = self().read_cstring();
        n_names = self().read_int64();
        Vec<char*> v_names;
        v_names.reserve(al, n_names);
        for (size_t i=0; i<n_names; i++) {
            v_names.push_back(al, self().read_cstring());
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_GenericDefinedOperator_t(al, loc, v_attr.p, v_attr.n, m_optype, v_names.p, v_names.n, m_trivia);
    }
    ast_t* deserialize_GenericAssignment() {
        size_t n_attr; // Sequence
        size_t n_names; // Sequence
        n_attr = self().read_int64();
        Vec<decl_attribute_t*> v_attr;
        v_attr.reserve(al, n_attr);
        for (size_t i=0; i<n_attr; i++) {
            v_attr.push_back(al, AST::down_cast<AST::decl_attribute_t>(self().deserialize_decl_attribute()));
        }
        n_names = self().read_int64();
        Vec<char*> v_names;
        v_names.reserve(al, n_names);
        for (size_t i=0; i<n_names; i++) {
            v_names.push_back(al, self().read_cstring());
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_GenericAssignment_t(al, loc, v_attr.p, v_attr.n, v_names.p, v_names.n, m_trivia);
    }
    ast_t* deserialize_GenericName() {
        size_t n_attr; // Sequence
        size_t n_names; // Sequence
        n_attr = self().read_int64();
        Vec<decl_attribute_t*> v_attr;
        v_attr.reserve(al, n_attr);
        for (size_t i=0; i<n_attr; i++) {
            v_attr.push_back(al, AST::down_cast<AST::decl_attribute_t>(self().deserialize_decl_attribute()));
        }
        char *m_name;
        m_name = self().read_cstring();
        n_names = self().read_int64();
        Vec<char*> v_names;
        v_names.reserve(al, n_names);
        for (size_t i=0; i<n_names; i++) {
            v_names.push_back(al, self().read_cstring());
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_GenericName_t(al, loc, v_attr.p, v_attr.n, m_name, v_names.p, v_names.n, m_trivia);
    }
    ast_t* deserialize_GenericWrite() {
        size_t n_attr; // Sequence
        size_t n_names; // Sequence
        n_attr = self().read_int64();
        Vec<decl_attribute_t*> v_attr;
        v_attr.reserve(al, n_attr);
        for (size_t i=0; i<n_attr; i++) {
            v_attr.push_back(al, AST::down_cast<AST::decl_attribute_t>(self().deserialize_decl_attribute()));
        }
        char *m_id;
        m_id = self().read_cstring();
        n_names = self().read_int64();
        Vec<char*> v_names;
        v_names.reserve(al, n_names);
        for (size_t i=0; i<n_names; i++) {
            v_names.push_back(al, self().read_cstring());
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_GenericWrite_t(al, loc, v_attr.p, v_attr.n, m_id, v_names.p, v_names.n, m_trivia);
    }
    ast_t* deserialize_GenericRead() {
        size_t n_attr; // Sequence
        size_t n_names; // Sequence
        n_attr = self().read_int64();
        Vec<decl_attribute_t*> v_attr;
        v_attr.reserve(al, n_attr);
        for (size_t i=0; i<n_attr; i++) {
            v_attr.push_back(al, AST::down_cast<AST::decl_attribute_t>(self().deserialize_decl_attribute()));
        }
        char *m_id;
        m_id = self().read_cstring();
        n_names = self().read_int64();
        Vec<char*> v_names;
        v_names.reserve(al, n_names);
        for (size_t i=0; i<n_names; i++) {
            v_names.push_back(al, self().read_cstring());
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_GenericRead_t(al, loc, v_attr.p, v_attr.n, m_id, v_names.p, v_names.n, m_trivia);
    }
    ast_t* deserialize_FinalName() {
        char *m_name;
        m_name = self().read_cstring();
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_FinalName_t(al, loc, m_name, m_trivia);
    }
    ast_t* deserialize_Private() {
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Private_t(al, loc, m_trivia);
    }
    ast_t* deserialize_procedure_decl() {
        uint8_t t = self().read_int8();
        AST::procedure_declType ty = static_cast<AST::procedure_declType>(t);
        switch (ty) {
            case (AST::procedure_declType::DerivedTypeProc) : return self().deserialize_DerivedTypeProc();
            case (AST::procedure_declType::GenericOperator) : return self().deserialize_GenericOperator();
            case (AST::procedure_declType::GenericDefinedOperator) : return self().deserialize_GenericDefinedOperator();
            case (AST::procedure_declType::GenericAssignment) : return self().deserialize_GenericAssignment();
            case (AST::procedure_declType::GenericName) : return self().deserialize_GenericName();
            case (AST::procedure_declType::GenericWrite) : return self().deserialize_GenericWrite();
            case (AST::procedure_declType::GenericRead) : return self().deserialize_GenericRead();
            case (AST::procedure_declType::FinalName) : return self().deserialize_FinalName();
            case (AST::procedure_declType::Private) : return self().deserialize_Private();
            default : throw LFortranException("Unknown type in deserialize_procedure_decl()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_AttrBind() {
        AST::bind_t *m_bind;
        m_bind = AST::down_cast<AST::bind_t>(self().deserialize_bind());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_AttrBind_t(al, loc, m_bind);
    }
    ast_t* deserialize_AttrData() {
        size_t n_object; // Sequence
        size_t n_value; // Sequence
        n_object = self().read_int64();
        Vec<expr_t*> v_object;
        v_object.reserve(al, n_object);
        for (size_t i=0; i<n_object; i++) {
            v_object.push_back(al, AST::down_cast<AST::expr_t>(self().deserialize_expr()));
        }
        n_value = self().read_int64();
        Vec<expr_t*> v_value;
        v_value.reserve(al, n_value);
        for (size_t i=0; i<n_value; i++) {
            v_value.push_back(al, AST::down_cast<AST::expr_t>(self().deserialize_expr()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_AttrData_t(al, loc, v_object.p, v_object.n, v_value.p, v_value.n);
    }
    ast_t* deserialize_AttrDimension() {
        size_t n_dim; // Sequence
        n_dim = self().read_int64();
        Vec<dimension_t> v_dim;
        v_dim.reserve(al, n_dim);
        for (size_t i=0; i<n_dim; i++) {
            v_dim.push_back(al, self().deserialize_dimension());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_AttrDimension_t(al, loc, v_dim.p, v_dim.n);
    }
    ast_t* deserialize_AttrCodimension() {
        size_t n_codim; // Sequence
        n_codim = self().read_int64();
        Vec<codimension_t> v_codim;
        v_codim.reserve(al, n_codim);
        for (size_t i=0; i<n_codim; i++) {
            v_codim.push_back(al, self().deserialize_codimension());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_AttrCodimension_t(al, loc, v_codim.p, v_codim.n);
    }
    ast_t* deserialize_AttrEquivalence() {
        size_t n_args; // Sequence
        n_args = self().read_int64();
        Vec<equi_t> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, self().deserialize_equi());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_AttrEquivalence_t(al, loc, v_args.p, v_args.n);
    }
    ast_t* deserialize_AttrExtends() {
        char *m_name;
        m_name = self().read_cstring();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_AttrExtends_t(al, loc, m_name);
    }
    ast_t* deserialize_AttrIntent() {
        AST::attr_intentType m_intent = self().deserialize_attr_intent();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_AttrIntent_t(al, loc, m_intent);
    }
    ast_t* deserialize_AttrNamelist() {
        char *m_name;
        m_name = self().read_cstring();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_AttrNamelist_t(al, loc, m_name);
    }
    ast_t* deserialize_AttrPass() {
        char *m_name;
        bool m_name_present = self().read_bool();
        if (m_name_present) {
        m_name = self().read_cstring();
        } else {
        m_name = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_AttrPass_t(al, loc, m_name);
    }
    ast_t* deserialize_SimpleAttribute() {
        AST::simple_attributeType m_attr = self().deserialize_simple_attribute();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_SimpleAttribute_t(al, loc, m_attr);
    }
    ast_t* deserialize_AttrType() {
        size_t n_kind; // Sequence
        AST::decl_typeType m_type = self().deserialize_decl_type();
        n_kind = self().read_int64();
        Vec<kind_item_t> v_kind;
        v_kind.reserve(al, n_kind);
        for (size_t i=0; i<n_kind; i++) {
            v_kind.push_back(al, self().deserialize_kind_item());
        }
        char *m_name;
        bool m_name_present = self().read_bool();
        if (m_name_present) {
        m_name = self().read_cstring();
        } else {
        m_name = nullptr;
        }
        AST::symbolType m_sym = self().deserialize_symbol();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_AttrType_t(al, loc, m_type, v_kind.p, v_kind.n, m_name, m_sym);
    }
    ast_t* deserialize_AttrAssignment() {
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_AttrAssignment_t(al, loc);
    }
    ast_t* deserialize_AttrIntrinsicOperator() {
        AST::intrinsicopType m_op = self().deserialize_intrinsicop();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_AttrIntrinsicOperator_t(al, loc, m_op);
    }
    ast_t* deserialize_AttrDefinedOperator() {
        char *m_op_name;
        m_op_name = self().read_cstring();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_AttrDefinedOperator_t(al, loc, m_op_name);
    }
    ast_t* deserialize_decl_attribute() {
        uint8_t t = self().read_int8();
        AST::decl_attributeType ty = static_cast<AST::decl_attributeType>(t);
        switch (ty) {
            case (AST::decl_attributeType::AttrBind) : return self().deserialize_AttrBind();
            case (AST::decl_attributeType::AttrData) : return self().deserialize_AttrData();
            case (AST::decl_attributeType::AttrDimension) : return self().deserialize_AttrDimension();
            case (AST::decl_attributeType::AttrCodimension) : return self().deserialize_AttrCodimension();
            case (AST::decl_attributeType::AttrEquivalence) : return self().deserialize_AttrEquivalence();
            case (AST::decl_attributeType::AttrExtends) : return self().deserialize_AttrExtends();
            case (AST::decl_attributeType::AttrIntent) : return self().deserialize_AttrIntent();
            case (AST::decl_attributeType::AttrNamelist) : return self().deserialize_AttrNamelist();
            case (AST::decl_attributeType::AttrPass) : return self().deserialize_AttrPass();
            case (AST::decl_attributeType::SimpleAttribute) : return self().deserialize_SimpleAttribute();
            case (AST::decl_attributeType::AttrType) : return self().deserialize_AttrType();
            case (AST::decl_attributeType::AttrAssignment) : return self().deserialize_AttrAssignment();
            case (AST::decl_attributeType::AttrIntrinsicOperator) : return self().deserialize_AttrIntrinsicOperator();
            case (AST::decl_attributeType::AttrDefinedOperator) : return self().deserialize_AttrDefinedOperator();
            default : throw LFortranException("Unknown type in deserialize_decl_attribute()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    simple_attributeType deserialize_simple_attribute() {
        uint8_t t = self().read_int8();
        simple_attributeType ty = static_cast<simple_attributeType>(t);
        return ty;
    }
    attr_intentType deserialize_attr_intent() {
        uint8_t t = self().read_int8();
        attr_intentType ty = static_cast<attr_intentType>(t);
        return ty;
    }
    decl_typeType deserialize_decl_type() {
        uint8_t t = self().read_int8();
        decl_typeType ty = static_cast<decl_typeType>(t);
        return ty;
    }
    ast_t* deserialize_AttrStat() {
        char *m_variable;
        m_variable = self().read_cstring();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_AttrStat_t(al, loc, m_variable);
    }
    ast_t* deserialize_AttrErrmsg() {
        char *m_variable;
        m_variable = self().read_cstring();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_AttrErrmsg_t(al, loc, m_variable);
    }
    ast_t* deserialize_AttrNewIndex() {
        AST::expr_t *m_value;
        m_value = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_AttrNewIndex_t(al, loc, m_value);
    }
    ast_t* deserialize_AttrEventWaitKwArg() {
        char *m_id;
        m_id = self().read_cstring();
        AST::expr_t *m_value;
        m_value = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_AttrEventWaitKwArg_t(al, loc, m_id, m_value);
    }
    ast_t* deserialize_event_attribute() {
        uint8_t t = self().read_int8();
        AST::event_attributeType ty = static_cast<AST::event_attributeType>(t);
        switch (ty) {
            case (AST::event_attributeType::AttrStat) : return self().deserialize_AttrStat();
            case (AST::event_attributeType::AttrErrmsg) : return self().deserialize_AttrErrmsg();
            case (AST::event_attributeType::AttrNewIndex) : return self().deserialize_AttrNewIndex();
            case (AST::event_attributeType::AttrEventWaitKwArg) : return self().deserialize_AttrEventWaitKwArg();
            default : throw LFortranException("Unknown type in deserialize_event_attribute()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_CoarrayAssociation() {
        AST::expr_t *m_coarray;
        m_coarray = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        AST::expr_t *m_selector;
        m_selector = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_CoarrayAssociation_t(al, loc, m_coarray, m_selector);
    }
    ast_t* deserialize_team_attribute() {
        uint8_t t = self().read_int8();
        AST::team_attributeType ty = static_cast<AST::team_attributeType>(t);
        switch (ty) {
            case (AST::team_attributeType::CoarrayAssociation) : return self().deserialize_CoarrayAssociation();
            default : throw LFortranException("Unknown type in deserialize_team_attribute()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    var_sym_t deserialize_var_sym() {
        var_sym_t x;
        {
            bool present=self().read_bool();
            if (present) {
                x.m_name = self().read_cstring();
            } else {
                x.m_name = nullptr;
            }
        }
        {
            uint64_t n = self().read_int64();
            Vec<dimension_t> v;
            v.reserve(al, n);
            for (uint64_t i=0; i<n; i++) {
                v.push_back(al, self().deserialize_dimension());
            }
            x.m_dim = v.p;
            x.n_dim = v.n;
        }
        {
            uint64_t n = self().read_int64();
            Vec<codimension_t> v;
            v.reserve(al, n);
            for (uint64_t i=0; i<n; i++) {
                v.push_back(al, self().deserialize_codimension());
            }
            x.m_codim = v.p;
            x.n_codim = v.n;
        }
        {
            bool present=self().read_bool();
            if (present) {
                x.m_initializer = down_cast<expr_t>(deserialize_expr());
            } else {
                x.m_initializer = nullptr;
            }
        }
        {
                x.m_sym = deserialize_symbol();
        }
        {
            bool present=self().read_bool();
            if (present) {
                x.m_spec = down_cast<decl_attribute_t>(deserialize_decl_attribute());
            } else {
                x.m_spec = nullptr;
            }
        }
        return x;
    }
    kind_item_t deserialize_kind_item() {
        kind_item_t x;
        {
            bool present=self().read_bool();
            if (present) {
                x.m_id = self().read_cstring();
            } else {
                x.m_id = nullptr;
            }
        }
        {
            bool present=self().read_bool();
            if (present) {
                x.m_value = down_cast<expr_t>(deserialize_expr());
            } else {
                x.m_value = nullptr;
            }
        }
        {
                x.m_type = deserialize_kind_item_type();
        }
        return x;
    }
    kind_item_typeType deserialize_kind_item_type() {
        uint8_t t = self().read_int8();
        kind_item_typeType ty = static_cast<kind_item_typeType>(t);
        return ty;
    }
    dimension_t deserialize_dimension() {
        dimension_t x;
        {
            bool present=self().read_bool();
            if (present) {
                x.m_start = down_cast<expr_t>(deserialize_expr());
            } else {
                x.m_start = nullptr;
            }
        }
        {
            bool present=self().read_bool();
            if (present) {
                x.m_end = down_cast<expr_t>(deserialize_expr());
            } else {
                x.m_end = nullptr;
            }
        }
        {
                x.m_end_star = deserialize_dimension_type();
        }
        return x;
    }
    dimension_typeType deserialize_dimension_type() {
        uint8_t t = self().read_int8();
        dimension_typeType ty = static_cast<dimension_typeType>(t);
        return ty;
    }
    codimension_t deserialize_codimension() {
        codimension_t x;
        {
            bool present=self().read_bool();
            if (present) {
                x.m_start = down_cast<expr_t>(deserialize_expr());
            } else {
                x.m_start = nullptr;
            }
        }
        {
            bool present=self().read_bool();
            if (present) {
                x.m_end = down_cast<expr_t>(deserialize_expr());
            } else {
                x.m_end = nullptr;
            }
        }
        {
                x.m_end_star = deserialize_codimension_type();
        }
        return x;
    }
    codimension_typeType deserialize_codimension_type() {
        uint8_t t = self().read_int8();
        codimension_typeType ty = static_cast<codimension_typeType>(t);
        return ty;
    }
    symbolType deserialize_symbol() {
        uint8_t t = self().read_int8();
        symbolType ty = static_cast<symbolType>(t);
        return ty;
    }
    equi_t deserialize_equi() {
        equi_t x;
        {
            uint64_t n = self().read_int64();
            Vec<expr_t*> v;
            v.reserve(al, n);
            for (uint64_t i=0; i<n; i++) {
                v.push_back(al, down_cast<expr_t>(self().deserialize_expr()));
            }
            x.m_set_list = v.p;
            x.n_set_list = v.n;
        }
        return x;
    }
    kw_argstar_t deserialize_kw_argstar() {
        kw_argstar_t x;
        {
                x.m_arg = self().read_cstring();
        }
        {
            bool present=self().read_bool();
            if (present) {
                x.m_value = down_cast<expr_t>(deserialize_expr());
            } else {
                x.m_value = nullptr;
            }
        }
        return x;
    }
    argstar_t deserialize_argstar() {
        argstar_t x;
        {
            bool present=self().read_bool();
            if (present) {
                x.m_value = down_cast<expr_t>(deserialize_expr());
            } else {
                x.m_value = nullptr;
            }
        }
        return x;
    }
    arg_t deserialize_arg() {
        arg_t x;
        {
                x.m_arg = self().read_cstring();
        }
        return x;
    }
    fnarg_t deserialize_fnarg() {
        fnarg_t x;
        {
            bool present=self().read_bool();
            if (present) {
                x.m_start = down_cast<expr_t>(deserialize_expr());
            } else {
                x.m_start = nullptr;
            }
        }
        {
            bool present=self().read_bool();
            if (present) {
                x.m_end = down_cast<expr_t>(deserialize_expr());
            } else {
                x.m_end = nullptr;
            }
        }
        {
            bool present=self().read_bool();
            if (present) {
                x.m_step = down_cast<expr_t>(deserialize_expr());
            } else {
                x.m_step = nullptr;
            }
        }
        return x;
    }
    coarrayarg_t deserialize_coarrayarg() {
        coarrayarg_t x;
        {
            bool present=self().read_bool();
            if (present) {
                x.m_start = down_cast<expr_t>(deserialize_expr());
            } else {
                x.m_start = nullptr;
            }
        }
        {
            bool present=self().read_bool();
            if (present) {
                x.m_end = down_cast<expr_t>(deserialize_expr());
            } else {
                x.m_end = nullptr;
            }
        }
        {
            bool present=self().read_bool();
            if (present) {
                x.m_step = down_cast<expr_t>(deserialize_expr());
            } else {
                x.m_step = nullptr;
            }
        }
        {
                x.m_star = deserialize_codimension_type();
        }
        return x;
    }
    keyword_t deserialize_keyword() {
        keyword_t x;
        {
                x.m_arg = self().read_cstring();
        }
        {
                x.m_value = down_cast<expr_t>(deserialize_expr());
        }
        return x;
    }
    struct_member_t deserialize_struct_member() {
        struct_member_t x;
        {
                x.m_name = self().read_cstring();
        }
        {
            uint64_t n = self().read_int64();
            Vec<fnarg_t> v;
            v.reserve(al, n);
            for (uint64_t i=0; i<n; i++) {
                v.push_back(al, self().deserialize_fnarg());
            }
            x.m_args = v.p;
            x.n_args = v.n;
        }
        return x;
    }
    ast_t* deserialize_Bind() {
        size_t n_args; // Sequence
        size_t n_kwargs; // Sequence
        n_args = self().read_int64();
        Vec<expr_t*> v_args;
        v_args.reserve(al, n_args);
        for (size_t i=0; i<n_args; i++) {
            v_args.push_back(al, AST::down_cast<AST::expr_t>(self().deserialize_expr()));
        }
        n_kwargs = self().read_int64();
        Vec<keyword_t> v_kwargs;
        v_kwargs.reserve(al, n_kwargs);
        for (size_t i=0; i<n_kwargs; i++) {
            v_kwargs.push_back(al, self().deserialize_keyword());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_Bind_t(al, loc, v_args.p, v_args.n, v_kwargs.p, v_kwargs.n);
    }
    ast_t* deserialize_bind() {
        uint8_t t = self().read_int8();
        AST::bindType ty = static_cast<AST::bindType>(t);
        switch (ty) {
            case (AST::bindType::Bind) : return self().deserialize_Bind();
            default : throw LFortranException("Unknown type in deserialize_bind()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_ArrayIndex() {
        AST::expr_t *m_left;
        if (self().read_bool()) {
        m_left = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_left = nullptr;
        }
        AST::expr_t *m_right;
        if (self().read_bool()) {
        m_right = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_right = nullptr;
        }
        AST::expr_t *m_step;
        if (self().read_bool()) {
        m_step = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_step = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_ArrayIndex_t(al, loc, m_left, m_right, m_step);
    }
    ast_t* deserialize_array_index() {
        uint8_t t = self().read_int8();
        AST::array_indexType ty = static_cast<AST::array_indexType>(t);
        switch (ty) {
            case (AST::array_indexType::ArrayIndex) : return self().deserialize_ArrayIndex();
            default : throw LFortranException("Unknown type in deserialize_array_index()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_CaseStmt() {
        size_t n_test; // Sequence
        size_t n_body; // Sequence
        n_test = self().read_int64();
        Vec<case_cond_t*> v_test;
        v_test.reserve(al, n_test);
        for (size_t i=0; i<n_test; i++) {
            v_test.push_back(al, AST::down_cast<AST::case_cond_t>(self().deserialize_case_cond()));
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_CaseStmt_t(al, loc, v_test.p, v_test.n, m_trivia, v_body.p, v_body.n);
    }
    ast_t* deserialize_CaseStmt_Default() {
        size_t n_body; // Sequence
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_CaseStmt_Default_t(al, loc, m_trivia, v_body.p, v_body.n);
    }
    ast_t* deserialize_case_stmt() {
        uint8_t t = self().read_int8();
        AST::case_stmtType ty = static_cast<AST::case_stmtType>(t);
        switch (ty) {
            case (AST::case_stmtType::CaseStmt) : return self().deserialize_CaseStmt();
            case (AST::case_stmtType::CaseStmt_Default) : return self().deserialize_CaseStmt_Default();
            default : throw LFortranException("Unknown type in deserialize_case_stmt()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_CaseCondExpr() {
        AST::expr_t *m_cond;
        m_cond = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_CaseCondExpr_t(al, loc, m_cond);
    }
    ast_t* deserialize_CaseCondRange() {
        AST::expr_t *m_start;
        if (self().read_bool()) {
        m_start = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_start = nullptr;
        }
        AST::expr_t *m_end;
        if (self().read_bool()) {
        m_end = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_end = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_CaseCondRange_t(al, loc, m_start, m_end);
    }
    ast_t* deserialize_case_cond() {
        uint8_t t = self().read_int8();
        AST::case_condType ty = static_cast<AST::case_condType>(t);
        switch (ty) {
            case (AST::case_condType::CaseCondExpr) : return self().deserialize_CaseCondExpr();
            case (AST::case_condType::CaseCondRange) : return self().deserialize_CaseCondRange();
            default : throw LFortranException("Unknown type in deserialize_case_cond()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_RankExpr() {
        size_t n_body; // Sequence
        AST::expr_t *m_value;
        m_value = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_RankExpr_t(al, loc, m_value, m_trivia, v_body.p, v_body.n);
    }
    ast_t* deserialize_RankStar() {
        size_t n_body; // Sequence
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_RankStar_t(al, loc, m_trivia, v_body.p, v_body.n);
    }
    ast_t* deserialize_RankDefault() {
        size_t n_body; // Sequence
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_RankDefault_t(al, loc, m_trivia, v_body.p, v_body.n);
    }
    ast_t* deserialize_rank_stmt() {
        uint8_t t = self().read_int8();
        AST::rank_stmtType ty = static_cast<AST::rank_stmtType>(t);
        switch (ty) {
            case (AST::rank_stmtType::RankExpr) : return self().deserialize_RankExpr();
            case (AST::rank_stmtType::RankStar) : return self().deserialize_RankStar();
            case (AST::rank_stmtType::RankDefault) : return self().deserialize_RankDefault();
            default : throw LFortranException("Unknown type in deserialize_rank_stmt()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_TypeStmtName() {
        size_t n_body; // Sequence
        char *m_name;
        bool m_name_present = self().read_bool();
        if (m_name_present) {
        m_name = self().read_cstring();
        } else {
        m_name = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_TypeStmtName_t(al, loc, m_name, m_trivia, v_body.p, v_body.n);
    }
    ast_t* deserialize_TypeStmtType() {
        size_t n_body; // Sequence
        AST::decl_attribute_t *m_vartype;
        if (self().read_bool()) {
        m_vartype = AST::down_cast<AST::decl_attribute_t>(self().deserialize_decl_attribute());
        } else {
        m_vartype = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_TypeStmtType_t(al, loc, m_vartype, m_trivia, v_body.p, v_body.n);
    }
    ast_t* deserialize_ClassStmt() {
        size_t n_body; // Sequence
        char *m_id;
        bool m_id_present = self().read_bool();
        if (m_id_present) {
        m_id = self().read_cstring();
        } else {
        m_id = nullptr;
        }
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_ClassStmt_t(al, loc, m_id, m_trivia, v_body.p, v_body.n);
    }
    ast_t* deserialize_ClassDefault() {
        size_t n_body; // Sequence
        AST::trivia_t *m_trivia;
        if (self().read_bool()) {
        m_trivia = AST::down_cast<AST::trivia_t>(self().deserialize_trivia());
        } else {
        m_trivia = nullptr;
        }
        n_body = self().read_int64();
        Vec<stmt_t*> v_body;
        v_body.reserve(al, n_body);
        for (size_t i=0; i<n_body; i++) {
            v_body.push_back(al, AST::down_cast<AST::stmt_t>(self().deserialize_stmt()));
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_ClassDefault_t(al, loc, m_trivia, v_body.p, v_body.n);
    }
    ast_t* deserialize_type_stmt() {
        uint8_t t = self().read_int8();
        AST::type_stmtType ty = static_cast<AST::type_stmtType>(t);
        switch (ty) {
            case (AST::type_stmtType::TypeStmtName) : return self().deserialize_TypeStmtName();
            case (AST::type_stmtType::TypeStmtType) : return self().deserialize_TypeStmtType();
            case (AST::type_stmtType::ClassStmt) : return self().deserialize_ClassStmt();
            case (AST::type_stmtType::ClassDefault) : return self().deserialize_ClassDefault();
            default : throw LFortranException("Unknown type in deserialize_type_stmt()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_UseSymbol() {
        char *m_remote_sym;
        m_remote_sym = self().read_cstring();
        char *m_local_rename;
        bool m_local_rename_present = self().read_bool();
        if (m_local_rename_present) {
        m_local_rename = self().read_cstring();
        } else {
        m_local_rename = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_UseSymbol_t(al, loc, m_remote_sym, m_local_rename);
    }
    ast_t* deserialize_UseAssignment() {
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_UseAssignment_t(al, loc);
    }
    ast_t* deserialize_IntrinsicOperator() {
        AST::intrinsicopType m_op = self().deserialize_intrinsicop();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_IntrinsicOperator_t(al, loc, m_op);
    }
    ast_t* deserialize_DefinedOperator() {
        char *m_opName;
        m_opName = self().read_cstring();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_DefinedOperator_t(al, loc, m_opName);
    }
    ast_t* deserialize_RenameOperator() {
        char *m_local_defop;
        m_local_defop = self().read_cstring();
        char *m_use_defop;
        m_use_defop = self().read_cstring();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_RenameOperator_t(al, loc, m_local_defop, m_use_defop);
    }
    ast_t* deserialize_UseWrite() {
        char *m_id;
        m_id = self().read_cstring();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_UseWrite_t(al, loc, m_id);
    }
    ast_t* deserialize_UseRead() {
        char *m_id;
        m_id = self().read_cstring();
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_UseRead_t(al, loc, m_id);
    }
    ast_t* deserialize_use_symbol() {
        uint8_t t = self().read_int8();
        AST::use_symbolType ty = static_cast<AST::use_symbolType>(t);
        switch (ty) {
            case (AST::use_symbolType::UseSymbol) : return self().deserialize_UseSymbol();
            case (AST::use_symbolType::UseAssignment) : return self().deserialize_UseAssignment();
            case (AST::use_symbolType::IntrinsicOperator) : return self().deserialize_IntrinsicOperator();
            case (AST::use_symbolType::DefinedOperator) : return self().deserialize_DefinedOperator();
            case (AST::use_symbolType::RenameOperator) : return self().deserialize_RenameOperator();
            case (AST::use_symbolType::UseWrite) : return self().deserialize_UseWrite();
            case (AST::use_symbolType::UseRead) : return self().deserialize_UseRead();
            default : throw LFortranException("Unknown type in deserialize_use_symbol()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_ConcurrentControl() {
        char *m_var;
        bool m_var_present = self().read_bool();
        if (m_var_present) {
        m_var = self().read_cstring();
        } else {
        m_var = nullptr;
        }
        AST::expr_t *m_start;
        if (self().read_bool()) {
        m_start = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_start = nullptr;
        }
        AST::expr_t *m_end;
        if (self().read_bool()) {
        m_end = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_end = nullptr;
        }
        AST::expr_t *m_increment;
        if (self().read_bool()) {
        m_increment = AST::down_cast<AST::expr_t>(self().deserialize_expr());
        } else {
        m_increment = nullptr;
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_ConcurrentControl_t(al, loc, m_var, m_start, m_end, m_increment);
    }
    ast_t* deserialize_concurrent_control() {
        uint8_t t = self().read_int8();
        AST::concurrent_controlType ty = static_cast<AST::concurrent_controlType>(t);
        switch (ty) {
            case (AST::concurrent_controlType::ConcurrentControl) : return self().deserialize_ConcurrentControl();
            default : throw LFortranException("Unknown type in deserialize_concurrent_control()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    ast_t* deserialize_ConcurrentLocal() {
        size_t n_vars; // Sequence
        n_vars = self().read_int64();
        Vec<char*> v_vars;
        v_vars.reserve(al, n_vars);
        for (size_t i=0; i<n_vars; i++) {
            v_vars.push_back(al, self().read_cstring());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_ConcurrentLocal_t(al, loc, v_vars.p, v_vars.n);
    }
    ast_t* deserialize_ConcurrentLocalInit() {
        size_t n_vars; // Sequence
        n_vars = self().read_int64();
        Vec<char*> v_vars;
        v_vars.reserve(al, n_vars);
        for (size_t i=0; i<n_vars; i++) {
            v_vars.push_back(al, self().read_cstring());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_ConcurrentLocalInit_t(al, loc, v_vars.p, v_vars.n);
    }
    ast_t* deserialize_ConcurrentShared() {
        size_t n_vars; // Sequence
        n_vars = self().read_int64();
        Vec<char*> v_vars;
        v_vars.reserve(al, n_vars);
        for (size_t i=0; i<n_vars; i++) {
            v_vars.push_back(al, self().read_cstring());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_ConcurrentShared_t(al, loc, v_vars.p, v_vars.n);
    }
    ast_t* deserialize_ConcurrentDefault() {
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_ConcurrentDefault_t(al, loc);
    }
    ast_t* deserialize_ConcurrentReduce() {
        size_t n_vars; // Sequence
        AST::reduce_opType m_op = self().deserialize_reduce_op();
        n_vars = self().read_int64();
        Vec<char*> v_vars;
        v_vars.reserve(al, n_vars);
        for (size_t i=0; i<n_vars; i++) {
            v_vars.push_back(al, self().read_cstring());
        }
        Location loc;
        // FIXME: read loc from the stream
        loc.first=0; loc.last=0;
        return AST::make_ConcurrentReduce_t(al, loc, m_op, v_vars.p, v_vars.n);
    }
    ast_t* deserialize_concurrent_locality() {
        uint8_t t = self().read_int8();
        AST::concurrent_localityType ty = static_cast<AST::concurrent_localityType>(t);
        switch (ty) {
            case (AST::concurrent_localityType::ConcurrentLocal) : return self().deserialize_ConcurrentLocal();
            case (AST::concurrent_localityType::ConcurrentLocalInit) : return self().deserialize_ConcurrentLocalInit();
            case (AST::concurrent_localityType::ConcurrentShared) : return self().deserialize_ConcurrentShared();
            case (AST::concurrent_localityType::ConcurrentDefault) : return self().deserialize_ConcurrentDefault();
            case (AST::concurrent_localityType::ConcurrentReduce) : return self().deserialize_ConcurrentReduce();
            default : throw LFortranException("Unknown type in deserialize_concurrent_locality()");
        }
        throw LFortranException("Switch statement above was not exhaustive.");
    }
    reduce_opType deserialize_reduce_op() {
        uint8_t t = self().read_int8();
        reduce_opType ty = static_cast<reduce_opType>(t);
        return ty;
    }
};


} // namespace LFortran::AST

#endif // LFORTRAN_AST_H
