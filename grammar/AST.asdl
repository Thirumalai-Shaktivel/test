-- This is an Abstract Syntax Description Lanuguage (ASDL) that describes the
-- Fortran's Abstract Syntax Tree (AST). See [1] for a short background
-- information and motivation and see the paper [2] for a detailed motivation,
-- explanation and specification of the language. See [3] for further examples
-- of ASDL usage in a real compiler.
--
-- [1] https://eli.thegreenplace.net/2014/06/04/using-asdl-to-describe-asts-in-compilers/
-- [2] Wang, D. C., Appel, A. W., Korn, J. L., & Serra, C. S. (1997). The Zephyr Abstract Syntax Description Language. USENIX Conference on Domain-Specific Languages, (October), 213â€“228.
-- [3] https://arxiv.org/abs/cs/9810013
--
-- ASDL's builtin types are:
--   * identifier
--   * int (signed integers of infinite precision)
--   * string
-- We extend these by:
--   * node (any ASDL node)
--   * bool
--
-- Specific tools may choose to produce language interfaces that represent
-- these types and the ASDL tree in a language specific way (e.g. use finite
-- precision integers and signal an error otherwise).
--
-- At the AST level we strictly only represent local syntax (no semantics). That
-- way each syntax construct is parsed locally, no need to do any non-local
-- lookups to figure out what AST node to construct. That is the job of the AST
-- to ASR conversion to do non-local lookups to figure out what is what (i.e.,
-- disambiguate) and report any errors.

module AST {

unit
    = TranslationUnit(node* items)

mod
    = Module(identifier name, unit_decl1* use, unit_decl2* decl,
        program_unit* contains)
    | Submodule(identifier id,identifier name, unit_decl1* use, unit_decl2* decl,
        program_unit* contains)
    | Program(identifier name, unit_decl1* use, unit_decl2* decl,
        stmt* body, program_unit* contains)

program_unit
    = Subroutine(identifier name, arg* args, unit_decl1* use, unit_decl2* decl,
        stmt* body, program_unit* contains)
    | Procedure(identifier name, arg* args, unit_decl1* use, unit_decl2* decl,
            stmt* body, program_unit* contains)
    | Function(identifier name, arg* args, string? return_type,
            expr? return_var, tbind? bind, unit_decl1* use, unit_decl2* decl,
            stmt* body, program_unit* contains)

unit_decl1
    = Use(identifier module, use_symbol* symbols)

unit_decl2
    = Declaration(decl* vars)
    | ParameterStatement(parameter_item* items)
    | Private(identifier* vars)
    | Public(identifier* vars)
    | Interface(interface_header header, interface_item* items)
    | DerivedType(identifier name, unit_decl2* items)

interface_header
    = InterfaceHeader1()
    | InterfaceHeader2(identifier name)
    | InterfaceHeader3()
    | InterfaceHeader4()
    | InterfaceHeader5()

interface_item
    = InterfaceProc(program_unit proc)
    | InterfaceModuleProcedure(identifier* names)

stmt
    = Assignment(expr target, expr value)
    | Associate(expr target, expr value)
    | SubroutineCall(identifier name, fnarg* args, keyword* keywords)
    | Allocate(fnarg* args, keyword* keywords)
    | Deallocate(fnarg* args)
    | Format(int n, string fmt)
    | BuiltinCall(identifier name, expr* args)
    | If(expr test, stmt* body, stmt* orelse)
    | Where(expr test, stmt* body, stmt* orelse)
    | Stop(expr? code)
    | ErrorStop(expr? code)
    | DoLoop(identifier? var, expr? start, expr? end, expr? increment,
            stmt* body)
    | DoConcurrentLoop(concurrent_control *control, expr? mask,
        concurrent_locality* locality, stmt* body)
    | Select(expr test, case_stmt* body, stmt* default)
    | Cycle()
    | Exit()
    | Return()
    | WhileLoop(expr test, stmt* body)
    | Print(string? fmt, expr* values)
    | Write(argstar* args, kw_argstar* kwargs, expr* values)
    | Read(argstar* args, kw_argstar* kwargs, expr* values)
    | Open(expr* args, keyword* kwargs)
    | Close(expr* args, keyword* kwargs)

expr
    = BoolOp(expr left, boolop op, expr right)
    | BinOp(expr left, operator op, expr right)
    | StrOp(expr left, stroperator op, expr right)
    | UnaryOp(unaryop op, expr operand)
    | Compare(expr left, cmpop op, expr right)
    | FuncCall(identifier func, fnarg* args, keyword* keywords)
    | FuncCallOrArray(identifier func, struct_member* member,
        fnarg* args, keyword* keywords)
    | Array(identifier name, array_index* args)
    | ArrayInitializer(expr* args)
    | ImpliedDoLoop(expr* values, identifier var, expr start, expr end,
        expr? increment)
    | Num(int n)
    | Real(string n)
    | Complex(expr re, expr im)
    | Str(string s)
    | Name(identifier id, struct_member* member)
    | Logical(bool value)

boolop = And | Or | Eqv | NEqv

operator = Add | Sub | Mul | Div | Pow

stroperator = Concat

unaryop = Invert | Not | UAdd | USub

cmpop = Eq | NotEq | Lt | LtE | Gt | GtE

decl = (identifier? sym, string? sym_type, string? derived_type_name,
    kind_item* kind, dimension* dims, attribute *attrs, expr? initializer,
    identifier* namelist
    )

kind_item = (identifier? id, expr? value, kind_item_type type)

kind_item_type = Star | Colon | Value

parameter_item = (identifier name, expr value)

dimension = (expr? start, expr? end)

attribute = Attribute(identifier name, attribute_arg *args, dimension* dims)

attribute_arg = (identifier arg)

fn_mod = FnMod(string s)

-- Null for `expr` means it's a star
kw_argstar = (identifier arg, expr? value)
argstar = (expr? value)

arg = (identifier arg)


-- Encoding of array elements and sections in fnarg:
--           start      end     step
-- element:
-- X(i)       ()         i       ()
-- section:
-- X(:)       ()         ()      1
-- X(a:)      a          ()      1
-- X(:b)      ()         b       1
-- X(a:b)     a          b       1
-- X(::c)     ()         ()      c
-- X(a::c)    a          ()      c
-- X(:b:c)    ()         b       c
-- X(a:b:c)   a          b       c
--
fnarg = (expr? start, expr? end, expr? step)

keyword = (identifier arg, expr value)

struct_member = (identifier name, fnarg* args)

tbind = Bind(keyword* args)

array_index = ArrayIndex(expr? left, expr? right, expr? step)

case_stmt = CaseStmt(expr* test, stmt* body) | CaseStmt_Range(expr? start, expr? end, stmt* body)

use_symbol = UseSymbol(identifier sym, identifier? rename)

concurrent_control = ConcurrentControl(identifier? var, expr? start, expr? end, expr? increment)

concurrent_locality
    = ConcurrentLocal(identifier *vars)
    | ConcurrentLocalInit(identifier *vars)
    | ConcurrentShared(identifier *vars)
    | ConcurrentDefault()
    | ConcurrentReduce(reduce_op op, identifier *vars)

reduce_op = ReduceAdd | ReduceMul | ReduceMIN | ReduceMAX

}
