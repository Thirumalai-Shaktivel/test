; ModuleID = 'LFortran'
source_filename = "LFortran"

%array = type { i32*, i32, [1 x %dimension_descriptor], i1 }
%dimension_descriptor = type { i32, i32, i32, i32 }
%array.0 = type { float*, i32, [1 x %dimension_descriptor], i1 }
%size_arg = type { %dimension_descriptor*, i32 }
%complex_4 = type { float, float }
%complex_8 = type { double, double }
%array.1 = type { [6 x i32], i32, [1 x %dimension_descriptor], i1 }

@"~fmaresult@11" = global float 0.000000e+00
@"~fmaresult@5" = global double 0.000000e+00
@"~fmaresult@7" = global double 0.000000e+00
@"~fmaresult@9" = global float 0.000000e+00
@0 = private unnamed_addr constant [12 x i8] c"ERROR STOP\0A\00", align 1
@1 = private unnamed_addr constant [12 x i8] c"ERROR STOP\0A\00", align 1

define void @fmar32(float* %a, float* %b, float* %c, float* %d) {
.entry:
  %0 = load float, float* %a, align 4
  %1 = load float, float* %b, align 4
  %2 = load float, float* %c, align 4
  %3 = fmul float %1, %2
  %4 = fadd float %0, %3
  store float %4, float* %d, align 4
  br label %return

return:                                           ; preds = %.entry
  ret void
}

define void @fmar64(double* %a, double* %b, double* %c, double* %d) {
.entry:
  %0 = load double, double* %a, align 8
  %1 = load double, double* %b, align 8
  %2 = load double, double* %c, align 8
  %3 = fmul double %1, %2
  %4 = fadd double %0, %3
  store double %4, double* %d, align 8
  br label %return

return:                                           ; preds = %.entry
  ret void
}

define float @__lfortran_evaluate_1() {
.entry:
  %__lfortran_evaluate_11 = alloca float, align 4
  %__lfortran_evaluate_12 = alloca float, align 4
  %__lfortran_evaluate_13 = alloca float, align 4
  %__lfortran_evaluate_14 = alloca float, align 4
  %__lfortran_evaluate_15 = alloca float, align 4
  %__lfortran_evaluate_16 = alloca float, align 4
  %"~fma_arg@0" = alloca float, align 4
  %"~fma_arg@1" = alloca float, align 4
  %"~fma_arg@2" = alloca float, align 4
  %"~fmaresult@3" = alloca float, align 4
  store float 5.000000e+00, float* %__lfortran_evaluate_11, align 4
  store float 8.000000e+00, float* %__lfortran_evaluate_12, align 4
  store float 1.600000e+01, float* %__lfortran_evaluate_13, align 4
  store float 5.000000e+00, float* %"~fma_arg@0", align 4
  store float 3.000000e+00, float* %"~fma_arg@1", align 4
  store float 2.000000e+00, float* %"~fma_arg@2", align 4
  call void @fmar32(float* %"~fma_arg@0", float* %"~fma_arg@1", float* %"~fma_arg@2", float* %"~fmaresult@3")
  %0 = load float, float* %"~fmaresult@3", align 4
  store float %0, float* %__lfortran_evaluate_14, align 4
  store float 2.000000e+00, float* %__lfortran_evaluate_15, align 4
  store float 6.400000e+01, float* %__lfortran_evaluate_16, align 4
  br label %return

return:                                           ; preds = %.entry
  %1 = load float, float* %__lfortran_evaluate_16, align 4
  ret float %1
}

declare i8* @__module_lfortran_intrinsic_builtin_achar(i32*, i32*)

declare i1 @__module_lfortran_intrinsic_builtin_allocated(%array*)

declare i32 @__module_lfortran_intrinsic_builtin_bit_size(i32*)

declare i8* @__module_lfortran_intrinsic_builtin_char(i32*)

declare i32 @__module_lfortran_intrinsic_builtin_iachar(i8**, i32*)

declare i32 @__module_lfortran_intrinsic_builtin_int(%array.0*, i32*)

define i32 @__module_lfortran_intrinsic_builtin_lbound(%dimension_descriptor** %x, i32* %dim) {
.entry:
  %lbound = alloca i32, align 4
  %0 = load %dimension_descriptor*, %dimension_descriptor** %x, align 8
  %1 = load i32, i32* %dim, align 4
  %2 = sub i32 %1, 1
  %3 = getelementptr inbounds %dimension_descriptor, %dimension_descriptor* %0, i32 %2
  %4 = getelementptr %dimension_descriptor, %dimension_descriptor* %3, i32 0, i32 1
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %lbound, align 4
  br label %return

return:                                           ; preds = %.entry
  %6 = load i32, i32* %lbound, align 4
  ret i32 %6
}

declare i32 @__module_lfortran_intrinsic_builtin_len(i8**, i32*)

declare i32 @__module_lfortran_intrinsic_builtin_max(i32*, i32*)

declare i32 @__module_lfortran_intrinsic_builtin_maxval(%array*)

declare i32 @__module_lfortran_intrinsic_builtin_merge(%array*, %array*, i1*)

declare i32 @__module_lfortran_intrinsic_builtin_min(i32*, i32*)

declare i32 @__module_lfortran_intrinsic_builtin_minval(%array*)

declare i1 @__module_lfortran_intrinsic_builtin_present(i32*)

declare float @__module_lfortran_intrinsic_builtin_real(%array*, i32*)

declare i32 @__module_lfortran_intrinsic_builtin_shape(%array*)

define i32 @__module_lfortran_intrinsic_builtin_size(%size_arg* %x) {
.entry:
  %size = alloca i32, align 4
  %0 = getelementptr %size_arg, %size_arg* %x, i32 0, i32 0
  %1 = load %dimension_descriptor*, %dimension_descriptor** %0, align 8
  %2 = getelementptr %size_arg, %size_arg* %x, i32 0, i32 1
  %3 = load i32, i32* %2, align 4
  store i32 1, i32* %size, align 4
  %4 = alloca i32, align 4
  store i32 0, i32* %4, align 4
  br label %loop.head

loop.head:                                        ; preds = %loop.body, %.entry
  %5 = load i32, i32* %4, align 4
  %6 = icmp slt i32 %5, %3
  br i1 %6, label %loop.body, label %loop.end

loop.body:                                        ; preds = %loop.head
  %7 = load i32, i32* %4, align 4
  %8 = load i32, i32* %size, align 4
  %9 = getelementptr inbounds %dimension_descriptor, %dimension_descriptor* %1, i32 %7
  %10 = getelementptr %dimension_descriptor, %dimension_descriptor* %9, i32 0, i32 3
  %11 = load i32, i32* %10, align 4
  %12 = mul i32 %8, %11
  store i32 %12, i32* %size, align 4
  %13 = add i32 %7, 1
  store i32 %13, i32* %4, align 4
  br label %loop.head

loop.end:                                         ; preds = %loop.head
  br label %return

return:                                           ; preds = %loop.end
  %14 = load i32, i32* %size, align 4
  ret i32 %14
}

declare i32 @__module_lfortran_intrinsic_builtin_sum(%array*)

declare float @__module_lfortran_intrinsic_builtin_tiny(%array*)

define i32 @__module_lfortran_intrinsic_builtin_ubound(%dimension_descriptor** %x, i32* %dim) {
.entry:
  %ubound = alloca i32, align 4
  %0 = load %dimension_descriptor*, %dimension_descriptor** %x, align 8
  %1 = load i32, i32* %dim, align 4
  %2 = sub i32 %1, 1
  %3 = getelementptr inbounds %dimension_descriptor, %dimension_descriptor* %0, i32 %2
  %4 = getelementptr %dimension_descriptor, %dimension_descriptor* %3, i32 0, i32 2
  %5 = load i32, i32* %4, align 4
  store i32 %5, i32* %ubound, align 4
  br label %return

return:                                           ; preds = %.entry
  %6 = load i32, i32* %ubound, align 4
  ret i32 %6
}

define float @__module_lfortran_intrinsic_math2_cabs(%complex_4* %x) {
.entry:
  %r = alloca float, align 4
  store float 1.000000e+00, float* %r, align 4
  br label %return

return:                                           ; preds = %.entry
  %0 = load float, float* %r, align 4
  ret float %0
}

define double @__module_lfortran_intrinsic_math2_dabs(double* %x) {
.entry:
  %r = alloca double, align 8
  %0 = load double, double* %x, align 8
  %1 = fcmp uge double %0, 0.000000e+00
  br i1 %1, label %then, label %else

then:                                             ; preds = %.entry
  %2 = load double, double* %x, align 8
  store double %2, double* %r, align 8
  br label %ifcont

else:                                             ; preds = %.entry
  %3 = load double, double* %x, align 8
  %4 = fsub double 0.000000e+00, %3
  store double %4, double* %r, align 8
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  br label %return

return:                                           ; preds = %ifcont
  %5 = load double, double* %r, align 8
  ret double %5
}

define double @__module_lfortran_intrinsic_math2_daimag(%complex_8* %x) {
.entry:
  %r = alloca double, align 8
  store double 3.000000e+00, double* %r, align 8
  br label %return

return:                                           ; preds = %.entry
  %0 = load double, double* %r, align 8
  ret double %0
}

define i32 @__module_lfortran_intrinsic_math2_dceiling(double* %x) {
.entry:
  %r = alloca i32, align 4
  %0 = call i32 @__module_lfortran_intrinsic_math2_dfloor(double* %x)
  store i32 %0, i32* %r, align 4
  %1 = load i32, i32* %r, align 4
  %2 = sitofp i32 %1 to double
  %3 = load double, double* %x, align 8
  %4 = fsub double %2, %3
  %5 = fcmp une double %4, 0.000000e+00
  br i1 %5, label %then, label %else

then:                                             ; preds = %.entry
  %6 = load i32, i32* %r, align 4
  %7 = add i32 %6, 1
  store i32 %7, i32* %r, align 4
  br label %ifcont

else:                                             ; preds = %.entry
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  br label %return

return:                                           ; preds = %ifcont
  %8 = load i32, i32* %r, align 4
  ret i32 %8
}

define i32 @__module_lfortran_intrinsic_math2_dfloor(double* %x) {
.entry:
  %r = alloca i32, align 4
  %0 = load double, double* %x, align 8
  %1 = fcmp uge double %0, 0.000000e+00
  br i1 %1, label %then, label %else

then:                                             ; preds = %.entry
  %2 = load double, double* %x, align 8
  %3 = fptosi double %2 to i32
  store i32 %3, i32* %r, align 4
  br label %ifcont

else:                                             ; preds = %.entry
  %4 = load double, double* %x, align 8
  %5 = fsub double %4, 1.000000e+00
  %6 = fptosi double %5 to i32
  store i32 %6, i32* %r, align 4
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  br label %return

return:                                           ; preds = %ifcont
  %7 = load i32, i32* %r, align 4
  ret i32 %7
}

define double @__module_lfortran_intrinsic_math2_dmax(double* %x, double* %y) {
.entry:
  %r = alloca double, align 8
  %0 = load double, double* %x, align 8
  %1 = load double, double* %y, align 8
  %2 = fcmp ugt double %0, %1
  br i1 %2, label %then, label %else

then:                                             ; preds = %.entry
  %3 = load double, double* %x, align 8
  store double %3, double* %r, align 8
  br label %ifcont

else:                                             ; preds = %.entry
  %4 = load double, double* %y, align 8
  store double %4, double* %r, align 8
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  br label %return

return:                                           ; preds = %ifcont
  %5 = load double, double* %r, align 8
  ret double %5
}

define double @__module_lfortran_intrinsic_math2_dmin(double* %x, double* %y) {
.entry:
  %r = alloca double, align 8
  %0 = load double, double* %x, align 8
  %1 = load double, double* %y, align 8
  %2 = fcmp ult double %0, %1
  br i1 %2, label %then, label %else

then:                                             ; preds = %.entry
  %3 = load double, double* %x, align 8
  store double %3, double* %r, align 8
  br label %ifcont

else:                                             ; preds = %.entry
  %4 = load double, double* %y, align 8
  store double %4, double* %r, align 8
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  br label %return

return:                                           ; preds = %ifcont
  %5 = load double, double* %r, align 8
  ret double %5
}

define double @__module_lfortran_intrinsic_math2_dmod(double* %x, double* %y) {
.entry:
  %call_arg_value = alloca double, align 8
  %r = alloca double, align 8
  %"~fma_arg@4" = alloca double, align 8
  %0 = load double, double* %x, align 8
  %1 = load double, double* %y, align 8
  %2 = fdiv double %0, %1
  store double %2, double* %call_arg_value, align 8
  %3 = call i32 @__module_lfortran_intrinsic_math2_dfloor(double* %call_arg_value)
  %4 = sitofp i32 %3 to double
  %5 = fsub double 0.000000e+00, %4
  store double %5, double* %"~fma_arg@4", align 8
  call void @fmar64(double* %x, double* %"~fma_arg@4", double* %y, double* @"~fmaresult@5")
  %6 = load double, double* @"~fmaresult@5", align 8
  store double %6, double* %r, align 8
  %7 = load double, double* %x, align 8
  %8 = fcmp ult double %7, 0.000000e+00
  %9 = load double, double* %y, align 8
  %10 = fcmp ult double %9, 0.000000e+00
  %11 = and i1 %8, %10
  br i1 %11, label %then, label %else

then:                                             ; preds = %.entry
  br label %return

unreachable_after_return:                         ; No predecessors!
  br label %ifcont

else:                                             ; preds = %.entry
  br label %ifcont

ifcont:                                           ; preds = %else, %unreachable_after_return
  %12 = load double, double* %x, align 8
  %13 = fcmp ult double %12, 0.000000e+00
  br i1 %13, label %then1, label %else2

then1:                                            ; preds = %ifcont
  %14 = load double, double* %r, align 8
  %15 = load double, double* %y, align 8
  %16 = fsub double %14, %15
  store double %16, double* %r, align 8
  br label %ifcont3

else2:                                            ; preds = %ifcont
  br label %ifcont3

ifcont3:                                          ; preds = %else2, %then1
  %17 = load double, double* %y, align 8
  %18 = fcmp ult double %17, 0.000000e+00
  br i1 %18, label %then4, label %else5

then4:                                            ; preds = %ifcont3
  %19 = load double, double* %r, align 8
  %20 = load double, double* %y, align 8
  %21 = fsub double %19, %20
  store double %21, double* %r, align 8
  br label %ifcont6

else5:                                            ; preds = %ifcont3
  br label %ifcont6

ifcont6:                                          ; preds = %else5, %then4
  br label %return

return:                                           ; preds = %ifcont6, %then
  %22 = load double, double* %r, align 8
  ret double %22
}

define double @__module_lfortran_intrinsic_math2_dmodulo(double* %x, double* %y) {
.entry:
  %call_arg_value = alloca double, align 8
  %r = alloca double, align 8
  %"~fma_arg@6" = alloca double, align 8
  %0 = load double, double* %x, align 8
  %1 = load double, double* %y, align 8
  %2 = fdiv double %0, %1
  store double %2, double* %call_arg_value, align 8
  %3 = call i32 @__module_lfortran_intrinsic_math2_dfloor(double* %call_arg_value)
  %4 = sitofp i32 %3 to double
  %5 = fsub double 0.000000e+00, %4
  store double %5, double* %"~fma_arg@6", align 8
  call void @fmar64(double* %x, double* %"~fma_arg@6", double* %y, double* @"~fmaresult@7")
  %6 = load double, double* @"~fmaresult@7", align 8
  store double %6, double* %r, align 8
  br label %return

return:                                           ; preds = %.entry
  %7 = load double, double* %r, align 8
  ret double %7
}

define i32 @__module_lfortran_intrinsic_math2_dnint(double* %x) {
.entry:
  %r = alloca i32, align 4
  %0 = load double, double* %x, align 8
  %1 = fcmp uge double %0, 0.000000e+00
  br i1 %1, label %then, label %else

then:                                             ; preds = %.entry
  %2 = load double, double* %x, align 8
  %3 = fadd double %2, 5.000000e-01
  %4 = fptosi double %3 to i32
  store i32 %4, i32* %r, align 4
  br label %ifcont

else:                                             ; preds = %.entry
  %5 = load double, double* %x, align 8
  %6 = fsub double %5, 1.000000e+00
  %7 = fadd double %6, 5.000000e-01
  %8 = fptosi double %7 to i32
  store i32 %8, i32* %r, align 4
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  br label %return

return:                                           ; preds = %ifcont
  %9 = load i32, i32* %r, align 4
  ret i32 %9
}

define double @__module_lfortran_intrinsic_math2_dphuge(double* %x) {
.entry:
  %r = alloca double, align 8
  store double 0x3FFCC359E067A348, double* %r, align 8
  br label %return

return:                                           ; preds = %.entry
  %0 = load double, double* %r, align 8
  ret double %0
}

define double @__module_lfortran_intrinsic_math2_dsqrt(double* %x) {
.entry:
  %r = alloca double, align 8
  %0 = load double, double* %x, align 8
  %1 = fcmp uge double %0, 0.000000e+00
  br i1 %1, label %then, label %else

then:                                             ; preds = %.entry
  %2 = load double, double* %x, align 8
  %3 = call double @llvm.pow.f64(double %2, double 5.000000e-01)
  store double %3, double* %r, align 8
  br label %ifcont

else:                                             ; preds = %.entry
  call void (i8*, ...) @_lfortran_printf(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @0, i32 0, i32 0))
  call void @exit(i32 1)
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  br label %return

return:                                           ; preds = %ifcont
  %4 = load double, double* %r, align 8
  ret double %4
}

define i32 @__module_lfortran_intrinsic_math2_i32huge(i32* %x) {
.entry:
  %r = alloca i32, align 4
  store i32 2147483647, i32* %r, align 4
  br label %return

return:                                           ; preds = %.entry
  %0 = load i32, i32* %r, align 4
  ret i32 %0
}

define i32 @__module_lfortran_intrinsic_math2_iabs(i32* %x) {
.entry:
  %r = alloca i32, align 4
  %0 = load i32, i32* %x, align 4
  %1 = icmp sge i32 %0, 0
  br i1 %1, label %then, label %else

then:                                             ; preds = %.entry
  %2 = load i32, i32* %x, align 4
  store i32 %2, i32* %r, align 4
  br label %ifcont

else:                                             ; preds = %.entry
  %3 = load i32, i32* %x, align 4
  %4 = sub i32 0, %3
  store i32 %4, i32* %r, align 4
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  br label %return

return:                                           ; preds = %ifcont
  %5 = load i32, i32* %r, align 4
  ret i32 %5
}

define i32 @__module_lfortran_intrinsic_math2_imax(i32* %x, i32* %y) {
.entry:
  %r = alloca i32, align 4
  %0 = load i32, i32* %x, align 4
  %1 = load i32, i32* %y, align 4
  %2 = icmp sgt i32 %0, %1
  br i1 %2, label %then, label %else

then:                                             ; preds = %.entry
  %3 = load i32, i32* %x, align 4
  store i32 %3, i32* %r, align 4
  br label %ifcont

else:                                             ; preds = %.entry
  %4 = load i32, i32* %y, align 4
  store i32 %4, i32* %r, align 4
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  br label %return

return:                                           ; preds = %ifcont
  %5 = load i32, i32* %r, align 4
  ret i32 %5
}

define i32 @__module_lfortran_intrinsic_math2_imax_6args(i32* %a, i32* %b, i32* %c, i32* %d, i32* %e, i32* %f) {
.entry:
  %args = alloca %array.1, align 8
  %0 = getelementptr %array.1, %array.1* %args, i32 0, i32 1
  store i32 0, i32* %0, align 4
  %1 = getelementptr %array.1, %array.1* %args, i32 0, i32 2
  %2 = getelementptr [1 x %dimension_descriptor], [1 x %dimension_descriptor]* %1, i32 0, i32 0
  %3 = getelementptr %dimension_descriptor, %dimension_descriptor* %2, i32 0, i32 0
  %4 = getelementptr %dimension_descriptor, %dimension_descriptor* %2, i32 0, i32 1
  %5 = getelementptr %dimension_descriptor, %dimension_descriptor* %2, i32 0, i32 2
  %6 = getelementptr %dimension_descriptor, %dimension_descriptor* %2, i32 0, i32 3
  store i32 1, i32* %3, align 4
  store i32 1, i32* %4, align 4
  store i32 6, i32* %5, align 4
  %7 = load i32, i32* %5, align 4
  %8 = load i32, i32* %4, align 4
  %9 = sub i32 %7, %8
  %10 = add i32 %9, 1
  store i32 %10, i32* %6, align 4
  %curr_value = alloca i32, align 4
  %itr = alloca i32, align 4
  %r = alloca i32, align 4
  %11 = getelementptr %array.1, %array.1* %args, i32 0, i32 2
  %12 = getelementptr [1 x %dimension_descriptor], [1 x %dimension_descriptor]* %11, i32 0, i32 0
  %13 = getelementptr %dimension_descriptor, %dimension_descriptor* %12, i32 0, i32 1
  %14 = load i32, i32* %13, align 4
  %15 = sub i32 1, %14
  %16 = mul i32 1, %15
  %17 = add i32 0, %16
  %18 = getelementptr %dimension_descriptor, %dimension_descriptor* %12, i32 0, i32 3
  %19 = load i32, i32* %18, align 4
  %20 = mul i32 1, %19
  %21 = getelementptr %array.1, %array.1* %args, i32 0, i32 0
  %22 = getelementptr [6 x i32], [6 x i32]* %21, i32 0, i32 %17
  %23 = load i32, i32* %a, align 4
  store i32 %23, i32* %22, align 4
  %24 = getelementptr %array.1, %array.1* %args, i32 0, i32 2
  %25 = getelementptr [1 x %dimension_descriptor], [1 x %dimension_descriptor]* %24, i32 0, i32 0
  %26 = getelementptr %dimension_descriptor, %dimension_descriptor* %25, i32 0, i32 1
  %27 = load i32, i32* %26, align 4
  %28 = sub i32 2, %27
  %29 = mul i32 1, %28
  %30 = add i32 0, %29
  %31 = getelementptr %dimension_descriptor, %dimension_descriptor* %25, i32 0, i32 3
  %32 = load i32, i32* %31, align 4
  %33 = mul i32 1, %32
  %34 = getelementptr %array.1, %array.1* %args, i32 0, i32 0
  %35 = getelementptr [6 x i32], [6 x i32]* %34, i32 0, i32 %30
  %36 = load i32, i32* %b, align 4
  store i32 %36, i32* %35, align 4
  %37 = getelementptr %array.1, %array.1* %args, i32 0, i32 2
  %38 = getelementptr [1 x %dimension_descriptor], [1 x %dimension_descriptor]* %37, i32 0, i32 0
  %39 = getelementptr %dimension_descriptor, %dimension_descriptor* %38, i32 0, i32 1
  %40 = load i32, i32* %39, align 4
  %41 = sub i32 3, %40
  %42 = mul i32 1, %41
  %43 = add i32 0, %42
  %44 = getelementptr %dimension_descriptor, %dimension_descriptor* %38, i32 0, i32 3
  %45 = load i32, i32* %44, align 4
  %46 = mul i32 1, %45
  %47 = getelementptr %array.1, %array.1* %args, i32 0, i32 0
  %48 = getelementptr [6 x i32], [6 x i32]* %47, i32 0, i32 %43
  %49 = load i32, i32* %c, align 4
  store i32 %49, i32* %48, align 4
  %50 = getelementptr %array.1, %array.1* %args, i32 0, i32 2
  %51 = getelementptr [1 x %dimension_descriptor], [1 x %dimension_descriptor]* %50, i32 0, i32 0
  %52 = getelementptr %dimension_descriptor, %dimension_descriptor* %51, i32 0, i32 1
  %53 = load i32, i32* %52, align 4
  %54 = sub i32 4, %53
  %55 = mul i32 1, %54
  %56 = add i32 0, %55
  %57 = getelementptr %dimension_descriptor, %dimension_descriptor* %51, i32 0, i32 3
  %58 = load i32, i32* %57, align 4
  %59 = mul i32 1, %58
  %60 = getelementptr %array.1, %array.1* %args, i32 0, i32 0
  %61 = getelementptr [6 x i32], [6 x i32]* %60, i32 0, i32 %56
  %62 = load i32, i32* %d, align 4
  store i32 %62, i32* %61, align 4
  %63 = getelementptr %array.1, %array.1* %args, i32 0, i32 2
  %64 = getelementptr [1 x %dimension_descriptor], [1 x %dimension_descriptor]* %63, i32 0, i32 0
  %65 = getelementptr %dimension_descriptor, %dimension_descriptor* %64, i32 0, i32 1
  %66 = load i32, i32* %65, align 4
  %67 = sub i32 5, %66
  %68 = mul i32 1, %67
  %69 = add i32 0, %68
  %70 = getelementptr %dimension_descriptor, %dimension_descriptor* %64, i32 0, i32 3
  %71 = load i32, i32* %70, align 4
  %72 = mul i32 1, %71
  %73 = getelementptr %array.1, %array.1* %args, i32 0, i32 0
  %74 = getelementptr [6 x i32], [6 x i32]* %73, i32 0, i32 %69
  %75 = load i32, i32* %e, align 4
  store i32 %75, i32* %74, align 4
  %76 = getelementptr %array.1, %array.1* %args, i32 0, i32 2
  %77 = getelementptr [1 x %dimension_descriptor], [1 x %dimension_descriptor]* %76, i32 0, i32 0
  %78 = getelementptr %dimension_descriptor, %dimension_descriptor* %77, i32 0, i32 1
  %79 = load i32, i32* %78, align 4
  %80 = sub i32 6, %79
  %81 = mul i32 1, %80
  %82 = add i32 0, %81
  %83 = getelementptr %dimension_descriptor, %dimension_descriptor* %77, i32 0, i32 3
  %84 = load i32, i32* %83, align 4
  %85 = mul i32 1, %84
  %86 = getelementptr %array.1, %array.1* %args, i32 0, i32 0
  %87 = getelementptr [6 x i32], [6 x i32]* %86, i32 0, i32 %82
  %88 = load i32, i32* %f, align 4
  store i32 %88, i32* %87, align 4
  %89 = load i32, i32* %a, align 4
  store i32 %89, i32* %r, align 4
  store i32 0, i32* %itr, align 4
  br label %loop.head

loop.head:                                        ; preds = %loop.body, %.entry
  %90 = load i32, i32* %itr, align 4
  %91 = add i32 %90, 1
  %92 = icmp sle i32 %91, 6
  br i1 %92, label %loop.body, label %loop.end

loop.body:                                        ; preds = %loop.head
  %93 = load i32, i32* %itr, align 4
  %94 = add i32 %93, 1
  store i32 %94, i32* %itr, align 4
  %95 = load i32, i32* %itr, align 4
  %96 = getelementptr %array.1, %array.1* %args, i32 0, i32 2
  %97 = getelementptr [1 x %dimension_descriptor], [1 x %dimension_descriptor]* %96, i32 0, i32 0
  %98 = getelementptr %dimension_descriptor, %dimension_descriptor* %97, i32 0, i32 1
  %99 = load i32, i32* %98, align 4
  %100 = sub i32 %95, %99
  %101 = mul i32 1, %100
  %102 = add i32 0, %101
  %103 = getelementptr %dimension_descriptor, %dimension_descriptor* %97, i32 0, i32 3
  %104 = load i32, i32* %103, align 4
  %105 = mul i32 1, %104
  %106 = getelementptr %array.1, %array.1* %args, i32 0, i32 0
  %107 = getelementptr [6 x i32], [6 x i32]* %106, i32 0, i32 %102
  %108 = load i32, i32* %107, align 4
  store i32 %108, i32* %curr_value, align 4
  %109 = call i32 @__module_lfortran_intrinsic_math2_imax(i32* %curr_value, i32* %r)
  store i32 %109, i32* %r, align 4
  br label %loop.head

loop.end:                                         ; preds = %loop.head
  br label %return

return:                                           ; preds = %loop.end
  %110 = load i32, i32* %r, align 4
  ret i32 %110
}

define i32 @__module_lfortran_intrinsic_math2_imin(i32* %x, i32* %y) {
.entry:
  %r = alloca i32, align 4
  %0 = load i32, i32* %x, align 4
  %1 = load i32, i32* %y, align 4
  %2 = icmp slt i32 %0, %1
  br i1 %2, label %then, label %else

then:                                             ; preds = %.entry
  %3 = load i32, i32* %x, align 4
  store i32 %3, i32* %r, align 4
  br label %ifcont

else:                                             ; preds = %.entry
  %4 = load i32, i32* %y, align 4
  store i32 %4, i32* %r, align 4
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  br label %return

return:                                           ; preds = %ifcont
  %5 = load i32, i32* %r, align 4
  ret i32 %5
}

define i32 @__module_lfortran_intrinsic_math2_imin_6args(i32* %a, i32* %b, i32* %c, i32* %d, i32* %e, i32* %f) {
.entry:
  %args = alloca %array.1, align 8
  %0 = getelementptr %array.1, %array.1* %args, i32 0, i32 1
  store i32 0, i32* %0, align 4
  %1 = getelementptr %array.1, %array.1* %args, i32 0, i32 2
  %2 = getelementptr [1 x %dimension_descriptor], [1 x %dimension_descriptor]* %1, i32 0, i32 0
  %3 = getelementptr %dimension_descriptor, %dimension_descriptor* %2, i32 0, i32 0
  %4 = getelementptr %dimension_descriptor, %dimension_descriptor* %2, i32 0, i32 1
  %5 = getelementptr %dimension_descriptor, %dimension_descriptor* %2, i32 0, i32 2
  %6 = getelementptr %dimension_descriptor, %dimension_descriptor* %2, i32 0, i32 3
  store i32 1, i32* %3, align 4
  store i32 1, i32* %4, align 4
  store i32 6, i32* %5, align 4
  %7 = load i32, i32* %5, align 4
  %8 = load i32, i32* %4, align 4
  %9 = sub i32 %7, %8
  %10 = add i32 %9, 1
  store i32 %10, i32* %6, align 4
  %curr_value = alloca i32, align 4
  %itr = alloca i32, align 4
  %r = alloca i32, align 4
  %11 = getelementptr %array.1, %array.1* %args, i32 0, i32 2
  %12 = getelementptr [1 x %dimension_descriptor], [1 x %dimension_descriptor]* %11, i32 0, i32 0
  %13 = getelementptr %dimension_descriptor, %dimension_descriptor* %12, i32 0, i32 1
  %14 = load i32, i32* %13, align 4
  %15 = sub i32 1, %14
  %16 = mul i32 1, %15
  %17 = add i32 0, %16
  %18 = getelementptr %dimension_descriptor, %dimension_descriptor* %12, i32 0, i32 3
  %19 = load i32, i32* %18, align 4
  %20 = mul i32 1, %19
  %21 = getelementptr %array.1, %array.1* %args, i32 0, i32 0
  %22 = getelementptr [6 x i32], [6 x i32]* %21, i32 0, i32 %17
  %23 = load i32, i32* %a, align 4
  store i32 %23, i32* %22, align 4
  %24 = getelementptr %array.1, %array.1* %args, i32 0, i32 2
  %25 = getelementptr [1 x %dimension_descriptor], [1 x %dimension_descriptor]* %24, i32 0, i32 0
  %26 = getelementptr %dimension_descriptor, %dimension_descriptor* %25, i32 0, i32 1
  %27 = load i32, i32* %26, align 4
  %28 = sub i32 2, %27
  %29 = mul i32 1, %28
  %30 = add i32 0, %29
  %31 = getelementptr %dimension_descriptor, %dimension_descriptor* %25, i32 0, i32 3
  %32 = load i32, i32* %31, align 4
  %33 = mul i32 1, %32
  %34 = getelementptr %array.1, %array.1* %args, i32 0, i32 0
  %35 = getelementptr [6 x i32], [6 x i32]* %34, i32 0, i32 %30
  %36 = load i32, i32* %b, align 4
  store i32 %36, i32* %35, align 4
  %37 = getelementptr %array.1, %array.1* %args, i32 0, i32 2
  %38 = getelementptr [1 x %dimension_descriptor], [1 x %dimension_descriptor]* %37, i32 0, i32 0
  %39 = getelementptr %dimension_descriptor, %dimension_descriptor* %38, i32 0, i32 1
  %40 = load i32, i32* %39, align 4
  %41 = sub i32 3, %40
  %42 = mul i32 1, %41
  %43 = add i32 0, %42
  %44 = getelementptr %dimension_descriptor, %dimension_descriptor* %38, i32 0, i32 3
  %45 = load i32, i32* %44, align 4
  %46 = mul i32 1, %45
  %47 = getelementptr %array.1, %array.1* %args, i32 0, i32 0
  %48 = getelementptr [6 x i32], [6 x i32]* %47, i32 0, i32 %43
  %49 = load i32, i32* %c, align 4
  store i32 %49, i32* %48, align 4
  %50 = getelementptr %array.1, %array.1* %args, i32 0, i32 2
  %51 = getelementptr [1 x %dimension_descriptor], [1 x %dimension_descriptor]* %50, i32 0, i32 0
  %52 = getelementptr %dimension_descriptor, %dimension_descriptor* %51, i32 0, i32 1
  %53 = load i32, i32* %52, align 4
  %54 = sub i32 4, %53
  %55 = mul i32 1, %54
  %56 = add i32 0, %55
  %57 = getelementptr %dimension_descriptor, %dimension_descriptor* %51, i32 0, i32 3
  %58 = load i32, i32* %57, align 4
  %59 = mul i32 1, %58
  %60 = getelementptr %array.1, %array.1* %args, i32 0, i32 0
  %61 = getelementptr [6 x i32], [6 x i32]* %60, i32 0, i32 %56
  %62 = load i32, i32* %d, align 4
  store i32 %62, i32* %61, align 4
  %63 = getelementptr %array.1, %array.1* %args, i32 0, i32 2
  %64 = getelementptr [1 x %dimension_descriptor], [1 x %dimension_descriptor]* %63, i32 0, i32 0
  %65 = getelementptr %dimension_descriptor, %dimension_descriptor* %64, i32 0, i32 1
  %66 = load i32, i32* %65, align 4
  %67 = sub i32 5, %66
  %68 = mul i32 1, %67
  %69 = add i32 0, %68
  %70 = getelementptr %dimension_descriptor, %dimension_descriptor* %64, i32 0, i32 3
  %71 = load i32, i32* %70, align 4
  %72 = mul i32 1, %71
  %73 = getelementptr %array.1, %array.1* %args, i32 0, i32 0
  %74 = getelementptr [6 x i32], [6 x i32]* %73, i32 0, i32 %69
  %75 = load i32, i32* %e, align 4
  store i32 %75, i32* %74, align 4
  %76 = getelementptr %array.1, %array.1* %args, i32 0, i32 2
  %77 = getelementptr [1 x %dimension_descriptor], [1 x %dimension_descriptor]* %76, i32 0, i32 0
  %78 = getelementptr %dimension_descriptor, %dimension_descriptor* %77, i32 0, i32 1
  %79 = load i32, i32* %78, align 4
  %80 = sub i32 6, %79
  %81 = mul i32 1, %80
  %82 = add i32 0, %81
  %83 = getelementptr %dimension_descriptor, %dimension_descriptor* %77, i32 0, i32 3
  %84 = load i32, i32* %83, align 4
  %85 = mul i32 1, %84
  %86 = getelementptr %array.1, %array.1* %args, i32 0, i32 0
  %87 = getelementptr [6 x i32], [6 x i32]* %86, i32 0, i32 %82
  %88 = load i32, i32* %f, align 4
  store i32 %88, i32* %87, align 4
  %89 = load i32, i32* %a, align 4
  store i32 %89, i32* %r, align 4
  store i32 0, i32* %itr, align 4
  br label %loop.head

loop.head:                                        ; preds = %loop.body, %.entry
  %90 = load i32, i32* %itr, align 4
  %91 = add i32 %90, 1
  %92 = icmp sle i32 %91, 6
  br i1 %92, label %loop.body, label %loop.end

loop.body:                                        ; preds = %loop.head
  %93 = load i32, i32* %itr, align 4
  %94 = add i32 %93, 1
  store i32 %94, i32* %itr, align 4
  %95 = load i32, i32* %itr, align 4
  %96 = getelementptr %array.1, %array.1* %args, i32 0, i32 2
  %97 = getelementptr [1 x %dimension_descriptor], [1 x %dimension_descriptor]* %96, i32 0, i32 0
  %98 = getelementptr %dimension_descriptor, %dimension_descriptor* %97, i32 0, i32 1
  %99 = load i32, i32* %98, align 4
  %100 = sub i32 %95, %99
  %101 = mul i32 1, %100
  %102 = add i32 0, %101
  %103 = getelementptr %dimension_descriptor, %dimension_descriptor* %97, i32 0, i32 3
  %104 = load i32, i32* %103, align 4
  %105 = mul i32 1, %104
  %106 = getelementptr %array.1, %array.1* %args, i32 0, i32 0
  %107 = getelementptr [6 x i32], [6 x i32]* %106, i32 0, i32 %102
  %108 = load i32, i32* %107, align 4
  store i32 %108, i32* %curr_value, align 4
  %109 = call i32 @__module_lfortran_intrinsic_math2_imin(i32* %curr_value, i32* %r)
  store i32 %109, i32* %r, align 4
  br label %loop.head

loop.end:                                         ; preds = %loop.head
  br label %return

return:                                           ; preds = %loop.end
  %110 = load i32, i32* %r, align 4
  ret i32 %110
}

define i32 @__module_lfortran_intrinsic_math2_imod(i32* %x, i32* %y) {
.entry:
  %call_arg_value = alloca float, align 4
  %r = alloca i32, align 4
  %0 = load i32, i32* %x, align 4
  %1 = load i32, i32* %x, align 4
  %2 = sitofp i32 %1 to float
  %3 = load i32, i32* %y, align 4
  %4 = sitofp i32 %3 to float
  %5 = fdiv float %2, %4
  store float %5, float* %call_arg_value, align 4
  %6 = call i32 @__module_lfortran_intrinsic_math2_sfloor(float* %call_arg_value)
  %7 = load i32, i32* %y, align 4
  %8 = mul i32 %6, %7
  %9 = sub i32 %0, %8
  store i32 %9, i32* %r, align 4
  %10 = load i32, i32* %x, align 4
  %11 = icmp slt i32 %10, 0
  %12 = load i32, i32* %y, align 4
  %13 = icmp slt i32 %12, 0
  %14 = and i1 %11, %13
  br i1 %14, label %then, label %else

then:                                             ; preds = %.entry
  br label %return

unreachable_after_return:                         ; No predecessors!
  br label %ifcont

else:                                             ; preds = %.entry
  br label %ifcont

ifcont:                                           ; preds = %else, %unreachable_after_return
  %15 = load i32, i32* %x, align 4
  %16 = icmp slt i32 %15, 0
  br i1 %16, label %then1, label %else2

then1:                                            ; preds = %ifcont
  %17 = load i32, i32* %r, align 4
  %18 = load i32, i32* %y, align 4
  %19 = sub i32 %17, %18
  store i32 %19, i32* %r, align 4
  br label %ifcont3

else2:                                            ; preds = %ifcont
  br label %ifcont3

ifcont3:                                          ; preds = %else2, %then1
  %20 = load i32, i32* %y, align 4
  %21 = icmp slt i32 %20, 0
  br i1 %21, label %then4, label %else5

then4:                                            ; preds = %ifcont3
  %22 = load i32, i32* %r, align 4
  %23 = load i32, i32* %y, align 4
  %24 = sub i32 %22, %23
  store i32 %24, i32* %r, align 4
  br label %ifcont6

else5:                                            ; preds = %ifcont3
  br label %ifcont6

ifcont6:                                          ; preds = %else5, %then4
  br label %return

return:                                           ; preds = %ifcont6, %then
  %25 = load i32, i32* %r, align 4
  ret i32 %25
}

define i32 @__module_lfortran_intrinsic_math2_imodulo(i32* %x, i32* %y) {
.entry:
  %call_arg_value = alloca float, align 4
  %r = alloca i32, align 4
  %0 = load i32, i32* %x, align 4
  %1 = load i32, i32* %x, align 4
  %2 = sitofp i32 %1 to float
  %3 = load i32, i32* %y, align 4
  %4 = sitofp i32 %3 to float
  %5 = fdiv float %2, %4
  store float %5, float* %call_arg_value, align 4
  %6 = call i32 @__module_lfortran_intrinsic_math2_sfloor(float* %call_arg_value)
  %7 = load i32, i32* %y, align 4
  %8 = mul i32 %6, %7
  %9 = sub i32 %0, %8
  store i32 %9, i32* %r, align 4
  br label %return

return:                                           ; preds = %.entry
  %10 = load i32, i32* %r, align 4
  ret i32 %10
}

define float @__module_lfortran_intrinsic_math2_sabs(float* %x) {
.entry:
  %r = alloca float, align 4
  %0 = load float, float* %x, align 4
  %1 = fcmp uge float %0, 0.000000e+00
  br i1 %1, label %then, label %else

then:                                             ; preds = %.entry
  %2 = load float, float* %x, align 4
  store float %2, float* %r, align 4
  br label %ifcont

else:                                             ; preds = %.entry
  %3 = load float, float* %x, align 4
  %4 = fsub float 0.000000e+00, %3
  store float %4, float* %r, align 4
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  br label %return

return:                                           ; preds = %ifcont
  %5 = load float, float* %r, align 4
  ret float %5
}

define float @__module_lfortran_intrinsic_math2_saimag(%complex_4* %x) {
.entry:
  %r = alloca float, align 4
  store float 3.000000e+00, float* %r, align 4
  br label %return

return:                                           ; preds = %.entry
  %0 = load float, float* %r, align 4
  ret float %0
}

define i32 @__module_lfortran_intrinsic_math2_sceiling(float* %x) {
.entry:
  %r = alloca i32, align 4
  %0 = call i32 @__module_lfortran_intrinsic_math2_sfloor(float* %x)
  store i32 %0, i32* %r, align 4
  %1 = load i32, i32* %r, align 4
  %2 = sitofp i32 %1 to float
  %3 = load float, float* %x, align 4
  %4 = fsub float %2, %3
  %5 = fcmp une float %4, 0.000000e+00
  br i1 %5, label %then, label %else

then:                                             ; preds = %.entry
  %6 = load i32, i32* %r, align 4
  %7 = add i32 %6, 1
  store i32 %7, i32* %r, align 4
  br label %ifcont

else:                                             ; preds = %.entry
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  br label %return

return:                                           ; preds = %ifcont
  %8 = load i32, i32* %r, align 4
  ret i32 %8
}

define i32 @__module_lfortran_intrinsic_math2_sfloor(float* %x) {
.entry:
  %r = alloca i32, align 4
  %0 = load float, float* %x, align 4
  %1 = fcmp uge float %0, 0.000000e+00
  br i1 %1, label %then, label %else

then:                                             ; preds = %.entry
  %2 = load float, float* %x, align 4
  %3 = fptosi float %2 to i32
  store i32 %3, i32* %r, align 4
  br label %ifcont

else:                                             ; preds = %.entry
  %4 = load float, float* %x, align 4
  %5 = fsub float %4, 1.000000e+00
  %6 = fptosi float %5 to i32
  store i32 %6, i32* %r, align 4
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  br label %return

return:                                           ; preds = %ifcont
  %7 = load i32, i32* %r, align 4
  ret i32 %7
}

define float @__module_lfortran_intrinsic_math2_smax(float* %x, float* %y) {
.entry:
  %r = alloca float, align 4
  %0 = load float, float* %x, align 4
  %1 = load float, float* %y, align 4
  %2 = fcmp ugt float %0, %1
  br i1 %2, label %then, label %else

then:                                             ; preds = %.entry
  %3 = load float, float* %x, align 4
  store float %3, float* %r, align 4
  br label %ifcont

else:                                             ; preds = %.entry
  %4 = load float, float* %y, align 4
  store float %4, float* %r, align 4
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  br label %return

return:                                           ; preds = %ifcont
  %5 = load float, float* %r, align 4
  ret float %5
}

define float @__module_lfortran_intrinsic_math2_smin(float* %x, float* %y) {
.entry:
  %r = alloca float, align 4
  %0 = load float, float* %x, align 4
  %1 = load float, float* %y, align 4
  %2 = fcmp ult float %0, %1
  br i1 %2, label %then, label %else

then:                                             ; preds = %.entry
  %3 = load float, float* %x, align 4
  store float %3, float* %r, align 4
  br label %ifcont

else:                                             ; preds = %.entry
  %4 = load float, float* %y, align 4
  store float %4, float* %r, align 4
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  br label %return

return:                                           ; preds = %ifcont
  %5 = load float, float* %r, align 4
  ret float %5
}

define float @__module_lfortran_intrinsic_math2_smod(float* %x, float* %y) {
.entry:
  %call_arg_value = alloca float, align 4
  %r = alloca float, align 4
  %"~fma_arg@8" = alloca float, align 4
  %0 = load float, float* %x, align 4
  %1 = load float, float* %y, align 4
  %2 = fdiv float %0, %1
  store float %2, float* %call_arg_value, align 4
  %3 = call i32 @__module_lfortran_intrinsic_math2_sfloor(float* %call_arg_value)
  %4 = sitofp i32 %3 to float
  %5 = fsub float 0.000000e+00, %4
  store float %5, float* %"~fma_arg@8", align 4
  call void @fmar32(float* %x, float* %"~fma_arg@8", float* %y, float* @"~fmaresult@9")
  %6 = load float, float* @"~fmaresult@9", align 4
  store float %6, float* %r, align 4
  %7 = load float, float* %x, align 4
  %8 = fcmp ult float %7, 0.000000e+00
  %9 = load float, float* %y, align 4
  %10 = fcmp ult float %9, 0.000000e+00
  %11 = and i1 %8, %10
  br i1 %11, label %then, label %else

then:                                             ; preds = %.entry
  br label %return

unreachable_after_return:                         ; No predecessors!
  br label %ifcont

else:                                             ; preds = %.entry
  br label %ifcont

ifcont:                                           ; preds = %else, %unreachable_after_return
  %12 = load float, float* %x, align 4
  %13 = fcmp ult float %12, 0.000000e+00
  br i1 %13, label %then1, label %else2

then1:                                            ; preds = %ifcont
  %14 = load float, float* %r, align 4
  %15 = load float, float* %y, align 4
  %16 = fsub float %14, %15
  store float %16, float* %r, align 4
  br label %ifcont3

else2:                                            ; preds = %ifcont
  br label %ifcont3

ifcont3:                                          ; preds = %else2, %then1
  %17 = load float, float* %y, align 4
  %18 = fcmp ult float %17, 0.000000e+00
  br i1 %18, label %then4, label %else5

then4:                                            ; preds = %ifcont3
  %19 = load float, float* %r, align 4
  %20 = load float, float* %y, align 4
  %21 = fsub float %19, %20
  store float %21, float* %r, align 4
  br label %ifcont6

else5:                                            ; preds = %ifcont3
  br label %ifcont6

ifcont6:                                          ; preds = %else5, %then4
  br label %return

return:                                           ; preds = %ifcont6, %then
  %22 = load float, float* %r, align 4
  ret float %22
}

define float @__module_lfortran_intrinsic_math2_smodulo(float* %x, float* %y) {
.entry:
  %call_arg_value = alloca float, align 4
  %r = alloca float, align 4
  %"~fma_arg@10" = alloca float, align 4
  %0 = load float, float* %x, align 4
  %1 = load float, float* %y, align 4
  %2 = fdiv float %0, %1
  store float %2, float* %call_arg_value, align 4
  %3 = call i32 @__module_lfortran_intrinsic_math2_sfloor(float* %call_arg_value)
  %4 = sitofp i32 %3 to float
  %5 = fsub float 0.000000e+00, %4
  store float %5, float* %"~fma_arg@10", align 4
  call void @fmar32(float* %x, float* %"~fma_arg@10", float* %y, float* @"~fmaresult@11")
  %6 = load float, float* @"~fmaresult@11", align 4
  store float %6, float* %r, align 4
  br label %return

return:                                           ; preds = %.entry
  %7 = load float, float* %r, align 4
  ret float %7
}

define i32 @__module_lfortran_intrinsic_math2_snint(float* %x) {
.entry:
  %r = alloca i32, align 4
  %0 = load float, float* %x, align 4
  %1 = fcmp uge float %0, 0.000000e+00
  br i1 %1, label %then, label %else

then:                                             ; preds = %.entry
  %2 = load float, float* %x, align 4
  %3 = fadd float %2, 5.000000e-01
  %4 = fptosi float %3 to i32
  store i32 %4, i32* %r, align 4
  br label %ifcont

else:                                             ; preds = %.entry
  %5 = load float, float* %x, align 4
  %6 = fsub float %5, 1.000000e+00
  %7 = fadd float %6, 5.000000e-01
  %8 = fptosi float %7 to i32
  store i32 %8, i32* %r, align 4
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  br label %return

return:                                           ; preds = %ifcont
  %9 = load i32, i32* %r, align 4
  ret i32 %9
}

define float @__module_lfortran_intrinsic_math2_sphuge(float* %x) {
.entry:
  %r = alloca float, align 4
  store float 0x47EFFFFFE0000000, float* %r, align 4
  br label %return

return:                                           ; preds = %.entry
  %0 = load float, float* %r, align 4
  ret float %0
}

define float @__module_lfortran_intrinsic_math2_ssqrt(float* %x) {
.entry:
  %r = alloca float, align 4
  %0 = load float, float* %x, align 4
  %1 = fcmp uge float %0, 0.000000e+00
  br i1 %1, label %then, label %else

then:                                             ; preds = %.entry
  %2 = load float, float* %x, align 4
  %3 = call float @llvm.pow.f32(float %2, float 5.000000e-01)
  store float %3, float* %r, align 4
  br label %ifcont

else:                                             ; preds = %.entry
  call void (i8*, ...) @_lfortran_printf(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @1, i32 0, i32 0))
  call void @exit(i32 1)
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  br label %return

return:                                           ; preds = %ifcont
  %4 = load float, float* %r, align 4
  ret float %4
}

define double @__module_lfortran_intrinsic_math2_zabs(%complex_8* %x) {
.entry:
  %r = alloca double, align 8
  store double 1.000000e+00, double* %r, align 8
  br label %return

return:                                           ; preds = %.entry
  %0 = load double, double* %r, align 8
  ret double %0
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double, double) #0

declare void @_lfortran_printf(i8*, ...)

declare void @exit(i32)

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.pow.f32(float, float) #0

define void @__module_lfortran_intrinsic_optimization_flipsigni32r32(i32* %signal, float* %variable) {
.entry:
  %call_arg_value = alloca i32, align 4
  store i32 2, i32* %call_arg_value, align 4
  %0 = call i32 @__module_lfortran_intrinsic_math2_imodulo(i32* %signal, i32* %call_arg_value)
  %1 = icmp eq i32 %0, 1
  br i1 %1, label %then, label %else

then:                                             ; preds = %.entry
  %2 = load float, float* %variable, align 4
  %3 = fsub float 0.000000e+00, %2
  store float %3, float* %variable, align 4
  br label %ifcont

else:                                             ; preds = %.entry
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  br label %return

return:                                           ; preds = %ifcont
  ret void
}

define void @__module_lfortran_intrinsic_optimization_flipsigni32r64(i32* %signal, double* %variable) {
.entry:
  %call_arg_value = alloca i32, align 4
  store i32 2, i32* %call_arg_value, align 4
  %0 = call i32 @__module_lfortran_intrinsic_math2_imodulo(i32* %signal, i32* %call_arg_value)
  %1 = icmp eq i32 %0, 1
  br i1 %1, label %then, label %else

then:                                             ; preds = %.entry
  %2 = load double, double* %variable, align 8
  %3 = fsub double 0.000000e+00, %2
  store double %3, double* %variable, align 8
  br label %ifcont

else:                                             ; preds = %.entry
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  br label %return

return:                                           ; preds = %ifcont
  ret void
}

attributes #0 = { nounwind readnone speculatable willreturn }
